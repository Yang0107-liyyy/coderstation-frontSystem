[{
  "_id": {
    "$oid": "634e46292fac4881713db259"
  },
  "interviewTitle": "HTML中的文档声明是什么",
  "interviewContent": "<h2>经典真题</h2><ul><li><p>什么是<code data-backticks=\"1\">&lt;!DOCTYPE&gt;</code>？是否需要在 <em>HTML5</em> 中使用？</p></li><li><p>什么是严格模式与混杂模式？</p></li><li><p>列举几条怪异模式中的怪癖行为</p></li></ul><h2>文档声明概念</h2><p><em>HTML</em> 文档通常以文档声明开始，该声明的作用是帮助浏览器确定其尝试解析和显示的 <em>HTML</em> 文档类型。</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;!DOCTYPE html&gt;</code></pre></div><p>文档声明必须是 <em>HTML</em> 文档的第一行、且顶格显示，对大小写不敏感。因为任何放在 <em>DOCTYPE</em> 前面的东西，比如批注或 <em>XML</em> 声明，会令 <em>IE9</em> 或更早期的浏览器触发怪异模式（后面的渲染模式会介绍）</p><p><br></p><p>文档声明并非一个 <em>HTML</em> 标签。它是一条“信息”，告知浏览器期望的文档类型。</p><p><br></p><p>那么说到文档类型，我们首先有必要先了解一下 <em>HTML</em> 的发展历史。如下图所示：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-020539.png\" alt=\"image-20210907100539198\" contenteditable=\"false\"><br></p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-020626.png\" alt=\"image-20210907100626110\" contenteditable=\"false\"><br></p><p><br></p><p>可以看到，<em>HTML</em> 版本从最开始诞生到最新的 <em>HTML5</em>，中间经历了很多版本。</p><p><br></p><p>那不同的版本有啥区别么？当然有区别，比如一个最显著的区别就是支持的 <em>HTML</em> 元素不同。例如：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-021238.png\" alt=\"image-20210907101237957\" contenteditable=\"false\"><br></p><blockquote><p>更多各版本所支持的不同 <em>HTML</em> 元素可以参阅：<em>https://www.w3school.com.cn/tags/html_ref_dtd.asp</em></p></blockquote><p>所以，你现在就知道为什么要书写文档声明了。原因是不同版本所支持的 <em>HTML</em> 元素类型是不同的，我需要告诉浏览器以哪一种文档类型方式来解析当前的这个 <em>HTML</em> 文件。</p><p><br></p><p>那么，最新的 <em>HTML5</em> 的文档类型倒是很简单，前面我们已经看到了</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;!DOCTYPE html&gt;</code></pre></div><p>那么稍微老一点的版本，例如 <em>HTML4</em> 或 <em>XHTML</em> 的文档类型声明长啥样呢？</p><p><br></p><p>这里我们来看两个。</p><p><br></p><p><strong><em>HTML 4.01 Strict</em></strong></p><p><br></p><p>该 <em>DTD</em> 包含所有 <em>HTML</em> 元素和属性，但不包括展示性的和弃用的元素（比如 <em>font</em>）。不允许框架集（<em>Framesets</em>）。</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"&gt;</code></pre></div><p><strong><em>HTML 4.01 Transitional</em></strong></p><p><br></p><p>该 <em>DTD</em> 包含所有 <em>HTML</em> 元素和属性，包括展示性的和弃用的元素（比如 <em>font</em>）。不允许框架集（<em>Framesets</em>）。</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \n\"http://www.w3.org/TR/html4/loose.dtd\"&gt;</code></pre></div><blockquote><p>更多不同文档类型的声明写法可以参阅：<em>https://www.w3school.com.cn/tags/tag_doctype.asp</em></p></blockquote><p>首先，给我们的第一直观感受，就是声明写得很长。</p><p><br></p><p>那么为什么会这么长呢？</p><p><br></p><p>原因很简单，<em>HTML5</em> 不需要引入 <em>DTD</em> 文件，而其他类型的文档声明是需要引入 <em>DTD</em> 的。</p><p><br></p><p>很好，一个新的名词出现了，<em>DTD</em>。</p><p><br></p><p>在早期的 <em>HTML</em> 版本，例如 <em>HTML 4.01</em> 中，<em>&lt;!DOCTYPE&gt;</em> 声明之所以要引用 <em>DTD</em>，是因为 <em>HTML 4.01</em> 基于 <em>SGML</em>。而 <em>DTD</em> 规定的是标记语言的规则，这样浏览器才能正确地呈现内容。</p><p><br></p><p>但是最新的 <em>HTML5</em> 不基于 <em>SGML</em>，所以不需要引用 <em>DTD</em>。</p><p><br></p><p>到这里估计有的小伙伴要懵圈了，怎么又冒出来一个 <em>SGML</em> ？？</p><p><br></p><p>是的，你没有看错，我们有：<em>SGML、HTML、XML、XHTML、HTML5</em></p><p><br></p><p>从这五者的名字中，我们都可以看到 “<em>ML</em>” 这两个字母，所以我们先从 “<em>ML</em>” 说起。</p><p><br></p><p>“<em>ML</em>”即 “<em>Markup language</em>(置标语言)”。</p><p><br></p><p>根据维基百科对其的解释，“<em>Markup language</em>” 是用标准的标记来解释纯文本文档的内容，从而提供关于文档结构或文档该如何渲染的信息。置标语言的发展可以用下图来表示：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-023423.png\" alt=\"image-20210907103423285\" contenteditable=\"false\"><br></p><p><br></p><p><em>GML</em> 是第一代置标语言，使文档能明确将标示和内容分开，所有文件使用同样的标示方法。</p><p><br></p><p><em>SGML</em> 在 <em>GML</em> 的基础上进行整理，形成了一套非常严谨的文件描述方法。它的组成包括语法定义，<em>DTD</em>，文件实例三部分。<em>SGML</em> 因太严谨规范达 <em>500</em> 多页，故而不易学、不易用、难以实现，所以在它的基础上又发展出了其他的更易用的置标语言。</p><p><br></p><p><em>HTML</em> 抛弃了<em>SGML</em> 复杂庞大的缺点，继承了 <em>SGML</em> 的很多优点。<em>HTML</em> 最大的特点是简单性和跨平台性。它只使用了 <em>SGML</em> 中很少的一部分标记，例如 <em>HTML 4.0</em> 中只定义了 <em>70</em> 余种标记。为了便于在计算机上实现，<em>HTML</em> 规定的标记是固定的，即 <em>HTML</em> 语法是不可扩展的。</p><p><br></p><p>随着 <em>Web</em> 应用的不断发展，<em>HTML</em> 的局限性也越来越明显地显现了出来，如 <em>HTML</em> 无法描述数据、可读性差、搜索时间长等。人们又把目光转向 <em>SGML</em>，再次改造 <em>SGML</em> 使之适应现在的网络需求。<em>1998</em> 年 <em>2</em> 月 <em>10</em> 日，<em>W3C</em>(<em>World Wide Web Consortium</em>，万维网联盟)公布 <em>XML 1.0</em> 标准，<em>XML</em> 诞生了。很长一段时间，<em>XML</em> 都作为网络传输的标准数据格式。</p><p><br></p><p><em>XHTML</em> 的出现是因为当时的 <em>HTML</em> 语法要求比较松散，这样对网页编写者来说，比较方便，但对于机器来说，语言的语法越松散，处理起来就越困难，对于传统的计算机来说，还有能力兼容松散语法，但对于许多其他设备，比如手机，难度就比较大。因此产生了由 <em>DTD</em> 定义规则，语法要求更加严格的 <em>XHTML</em>。</p><blockquote><p><em>DTD</em> 教程可以参阅：<em>https://www.w3school.com.cn/dtd/index.asp</em></p></blockquote><p>最终，<em>HTML5</em> 是 <em>HTML</em> 的第五个修订版，该版本不在基于 <em>SGML</em> 了，所以也就不用再引入 <em>DTD</em> 声明了。</p><p><br></p><p><em>HTML5</em> 的出现，其主要的目标是将互联网语义化，以便更好地被人类和机器阅读，并同时提供更好地支持各种媒体的嵌入。</p><p><br></p><p>现在国内通常所说的 <em>H5</em> 开发，实际上是 <em>HTML5</em> 与 <em>CSS3</em> 及 <em>ES6</em> 的一个组合，大概可以用以下公式说明：<em>HTML5 ≈ HTML + CSS3 + ES6</em></p><h2>渲染模式</h2><p>明白了文档类型声明的作用之后，接下来我们还需要看一个东西，那就是渲染模式。</p><p><br></p><p>浏览器渲染模式分为 <em>3</em> 种：</p><ul><li><p>怪癖模式（混杂模式）[<em>Quirks mode</em>]</p></li><li><p>严格模式（标准模式） [<em>Standars mode</em>]</p></li><li><p>几乎标准模式 [<em>Almost standards mode</em>]</p></li></ul><blockquote><p>之所以出现不同的渲染模式，是由于历史原因造成的。</p><p><br></p><p>当年 <em>Netscape4</em>（网景公司早期的浏览器）和 <em>IE4</em>（微软公司早期的浏览器）实现 <em>CSS</em> 机制时，没有遵循 <em>W3C</em> 提出的标准。<em>Netscape4</em> 提供了糟糕的支持，而 <em>IE4</em> 虽然接近标准，但依旧未能完全正确的支持标准。</p><p><br></p><p>所以，在 <em>W3C</em> 标准推出以前，浏览器在对页面的渲染上没有统一规范，产生了差异（<em>Quirks mode</em> 或者称为 <em>Compatibility Mode</em>）</p><p><br></p><p>为了保障自己的网站在各个浏览器上显示正确，网页开发者们不得不依据各个浏览器自身的规范来使用 <em>CSS</em>，因此大部分网站的 <em>CSS</em> 实现并不符合 <em>W3C</em> 规范的标准。</p><p><br></p><p><em>W3C</em> 标准推出后，浏览器渲染页面有了统一的标准（<em>Strict mode</em> 也有叫做 <em>Standars mode</em>）浏览器都开始采纳新标准，但存在一个问题就是如何保证旧的网页还能继续浏览，在标准出来以前，很多页面都是根据旧的渲染方法编写的，如果用的标准来渲染，将导致页面显示异常。</p><p><br></p><p>为保持浏览器渲染的兼容性，使以前的页面能够正常浏览，浏览器都保留了旧的渲染方法（如：微软的 <em>IE</em>）。这样浏览器渲染上就产生了 <em>Quircks mode</em> 和 <em>Standars mode</em>，两种渲染方法共存在一个浏览器上。混杂模式服务于旧式规则，而严格模式服务于标准规则。</p></blockquote><p>对于 <em>HTML</em> 文档来说，浏览器使用文档开头的 <em>DOCTYPE</em> 来决定用怪异模式处理或标准模式处理。</p><p><br></p><p>如果文档中没有 <em>DOCTYPE</em> 将触发文档的怪异模式。怪异模式最明显的影响是会触发怪异盒模型。</p><p><br></p><p>在 <em>DOCTYPE</em> 声明中，没有使用 <em>DTD</em> 声明或者使用 <em>HTML4</em> 以下的 <em>DTD</em> 声明时，基本所有的浏览器都是使用 <em>Quirks mode</em> 呈现，其他的则使用 <em>Standars mode</em> 解析。</p><p><br></p><p><strong>严格模式和怪异模式的部分渲染区别</strong></p><ol><li><p>盒模型的高宽包含内边距 <em>padding</em> 和边框 <em>border</em></p></li></ol><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-035904.png\" alt=\"img\" contenteditable=\"false\"><br></p><p><br></p><p>在 <em>W3C</em> 标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在 <em>IE5.5</em> 及以下的浏览器及其他版本的 <em>Quirks</em> 模式下，<em>IE</em> 的宽度和高度还包含了 <em>padding</em> 和 <em>border</em>。</p><ol start=\"2\"><li><p>可以设置行内元素的高宽</p></li></ol><p>在 <em>standards</em> 模式下，给 <em>span</em> 等行内元素设置 <em>wdith</em> 和 <em>height</em> 都不会生效，而在 <em>Quirks</em> 模式下，则会生效。</p><ol start=\"3\"><li><p>可设置百分比的高度</p></li></ol><p>在 <em>standards</em> 模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。</p><ol start=\"4\"><li><p>用 <em>margin:0 auto</em> 设置水平居中在 <em>IE</em> 下会失效</p></li></ol><p>使用 <em>margin:0 auto</em> 在 <em>standards</em> 模式下可以使元素水平居中，但在 <em>Quirks</em> 模式下却会失效，<em>Quirks</em> 模式下的解决办法，用 <em>text-align</em> 属性：<em>body{text-align:center};#content{text-align:left}</em></p><ol start=\"5\"><li><p><em>Quirks</em> 模式下设置图片的 <em>padding</em> 会失效</p></li><li><p><em>Quirks</em> 模式下 <em>Table</em> 中的字体属性不能继承上层的设置</p></li><li><p><em>Quirks</em> 模式下 <em>white-space:pre</em> 会失效</p></li></ol><blockquote><p>更多可以参阅 <em>MDN</em> 上对怪异模式和标准模式的解释：<em>https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standards_Mode</em></p></blockquote><blockquote><p><em>MDN</em> 上还给出了不同模式在不同浏览器下的渲染区别（英文）：<em>https://hsivonen.fi/doctype/</em></p></blockquote><h2>真题解答</h2><ul><li><p>什么是<code data-backticks=\"1\">&lt;!DOCTYPE&gt;</code>？是否需要在 <em>HTML5</em> 中使用？</p></li></ul><blockquote><p>它是 <em>HTML</em> 的文档声明，通过它告诉浏览器，使用哪一个 <em>HTML</em> 版本标准解析文档。</p><p><br></p><p>在浏览器发展的历史中，<em>HTML</em> 出现过很多个版本，不同版本在元素、属性等书写格式上略有差异，如果不预先告诉浏览器，浏览器就不知道我们的文档标准是什么，在这种情况下，大部分浏览器将开启最大兼容模式来解析网页，我们称之为怪异模式。这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的 <em>bug</em>，所以文档声明是必须的。</p><p><br></p><p>而文档声明有多种书写格式，对应不同的 <em>HTML</em> 版本，<code data-backticks=\"1\">&lt;!DOCTYPE&gt;</code>这种书写是告诉浏览器，整个文档使用 <em>HTML5</em> 的标准进行解析。</p></blockquote><ul><li><p>什么是严格模式与混杂模式？</p></li></ul><blockquote><p>严格模式：又称标准模式，是指浏览器按照 <em>W3C</em> 标准解析代码。</p><p><br></p><p>混杂模式：又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。</p><p><br></p><p>如何区分：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 <em>DTD</em> 直接相关。</p><ol><li><p>如果文档包含严格的 <em>DOCTYPE</em> ，那么它一般以严格模式呈现。<strong>（严格 <em>DTD</em> ——严格模式）</strong></p></li><li><p>包含过渡 <em>DTD</em> 和 <em>URI</em> 的 <em>DOCTYPE</em> ，也以严格模式呈现，但有过渡 <em>DTD</em> 而没有 <em>URI</em> （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。<strong>（有 <em>URI</em> 的过渡 <em>DTD</em> ——严格模式；没有 <em>URI</em> 的过渡 <em>DTD</em> ——混杂模式）</strong></p></li><li><p><em>DOCTYPE</em> 不存在或形式不正确会导致文档以混杂模式呈现。<strong>（<em>DTD</em> 不存在或者格式不正确——混杂模式）</strong></p></li><li><p><em>HTML5</em> 没有 <em>DTD</em> ，因此也就没有严格模式与混杂模式的区别，<em>HTML5</em> 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。<strong>（ <em>HTML5</em> 没有严格和混杂之分）</strong></p></li></ol><p>意义：严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。</p></blockquote><ul><li><p>列举几条怪异模式中的怪癖行为</p></li></ul><blockquote><ol><li><p>宽高的算法与 <em>W3C</em> 盒模型不同</p></li><li><p>在表格中的字体样式不会继承</p></li><li><p>怪异模式下可以设置行内元素宽高</p></li><li><p>怪异模式下 <em>white-space:pre</em> 会失效</p></li></ol></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666074153364",
  "typeId": {
    "$oid": "634d7f707797638ec96fe2e9"
  }
},
{
  "_id": {
    "$oid": "634e47a62fac4881713db273"
  },
  "interviewTitle": "请谈一谈HTML中的语义化",
  "interviewContent": "<h1>语义化</h1><h2>经典真题</h2><ul><li><p>说说对 <em>html</em> 语义化的理解</p></li></ul><h2>什么是语义元素？</h2><p>语义是指对一个词或者句子含义的正确解释。很多 <em>HTML</em> 标签也具有语义的意义，也就是说元素本身传达了关于标签所包含内容类型的一些信息。例如，当浏览器解析到<code data-backticks=\"1\">&lt;h1&gt;&lt;/h1&gt;</code>标签时，它将该标签解释为包含这一块内容的最重要的标题。<em>h1</em> 标签的语义就是用它来标识特定网页或部分最重要的标题。</p><h2>为什么要语义化？</h2><ul><li><p>代码结构：使页面没有css的情况下，也能够呈现出很好的内容结构</p></li><li><p>有利于 <em>SEO</em>： 爬虫依赖标签来确定关键字的权重，因此可以和搜索引擎建立良好的沟通，帮助爬虫抓取更多的有效信息</p></li><li><p>提升用户体验：例如 <em>title、alt</em> 可以用于解释名称或者解释图片信息，以及 <em>label</em> 标签的灵活运用。</p></li><li><p>便于团队开发和维护：语义化使得代码更具有可读性，让其他开发人员更加理解你的 <em>html</em> 结构，减少差异化。</p></li><li><p>方便其他设备解析：如屏幕阅读器、盲人阅读器、移动设备等，以有意义的方式来渲染网页。</p></li></ul><h2><em>HTML5</em> 常用的语义元素</h2><p><em>HTML5</em> 提供了新的语义元素来定义网页的不同部分，它们被称为“切片元素”，如图所示 ：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-062515.png\" alt=\"image-20210907142515375\" contenteditable=\"false\"><br></p><ul><li><p><em>header</em>：用于定义页面的头部区域，通常包括网站 <em>logo</em>、主导航、全站链接以及搜索框。</p></li><li><p><em>nav</em>：定义页面的导航链接部分区域。</p></li><li><p><em>main</em>：定义文档的主要内容，该内容在文档中应当是独一无二的</p></li><li><p><em>article</em>：定义页面独立的内容，它可以有自己的 <em>header、footer、sections</em> 等，专注于单个主题的博客文章，报纸文章或网页文章。</p></li><li><p><em>section</em>：表示文档中的一个区域（或节），比如，内容中的一个专题组。</p></li><li><p><em>aside</em>：表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分且可以被单独的拆分出来而不会影响整体。通常表现为侧边栏或嵌入内容。</p></li><li><p><em>footer</em>：定义最近一个章节内容或者根节点元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。</p></li></ul><p>大约有 <em>100</em> 多个 <em>HTML</em> 语义元素可供选择，以下是常用的语义元素：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-062552.png\" alt=\"image-20210907142551909\" contenteditable=\"false\"><br></p><blockquote><p>更多的语义化标签可以参阅：<em>https://developer.mozilla.org/en-US/docs/Web/HTML/Element</em></p></blockquote><h2>无障碍网页</h2><p><em>W3C</em> 在 <em>1997</em> 年发起了一项 <em>WAI</em>（<em>Web Accessibility Initiative</em>）的计划，该计划的目标是提升网站的易用性(<em>accessibility</em>)，而其中有一个很重要的指标，那就是能够被残障人士使用的网站才能称得上一个易用的（易访问的）网站。</p><p><br></p><p><em>HTML5</em> 在无障碍方面进行了加强，加入了无障碍属性。</p><p><br></p><p>所谓 <em>HTML5</em> 无障碍属性，主要针对的是视觉缺陷，失聪，行动不便的残疾人以及假装残疾的测试人员。尤其像盲人，眼睛看不到，其浏览网页则需要借助辅助设备，如屏幕阅读器，屏幕阅读机可以大声朗读或者输出盲文。</p><p><br></p><p>而 <em>HTML5</em> 无障碍属性就是可以让屏幕阅读器准确识别网页中的内容，变化，状态的技术规范，可以让盲人这类用户也能无障碍阅读！</p><blockquote><p>关于无障碍的更多说明，可以参阅 <em>MDN</em>：<em>https://developer.mozilla.org/zh-CN/docs/Web/Accessibility</em></p></blockquote><p><strong>常见的无障碍属性</strong></p><p><br></p><p><em>WAI-ARIA</em> 是 <em>W3C</em> 编写的规范，定义了一组可用于其他元素的 <em>HTML</em> 特性，用于提供额外的语义化以及改善缺乏的可访问性。以下是规范中三个主要的特性：</p><ul><li><p>角色：这定义了元素是干什么的。许多「标志性的角色」，其实重复了 <em>HTML5</em> 的结构元素的语义价值。例如 <em>role=\"navigation\"</em> (<em>nav</em>) 或者 <em>role=\"complementary\"</em> (<em>aside</em>)。</p></li><li><p>属性：我们能通过定义一些属性给元素，让他们具备更多的语义。例如：<em>aria-required=\"true\"</em> 意味着元素在表单上是必填的。然而 <em>aria-labelledby=\"label\"</em> 允许在元素上设置一个 <em>ID</em>，用于 <em>labelledby</em> 引用作为屏幕阅读器指定的 <em>label</em> 内容 ，多个也可以。</p></li><li><p>状态：用于表达元素当前的条件的特殊属性，例如 <em>aria-disabled=\"true\"</em>，屏幕阅读器就会这个表单禁止输入。状态和属性的差异之处就是：属性在应用的生命周期中不会改变，而状态可以，通常我们用编程的方法改变它，例如 <em>Javascript</em>。</p></li></ul><p>关于 <em>WAI-ARIA</em> 属性重要的一点是它不会对 <em>Web</em> 页面有任何影响，除了让更多的信息从浏览器暴露给 <em>accessibility APIs</em> (无障碍 <em>API</em>)，这也是屏幕阅读器这一类软件的信息源。<em>WAI-ARIA</em> 不会影响网页的结构，以及 <em>DOM</em> 等等，尽管这些属性可用于作为 <em>CSS</em> 选择器。</p><blockquote><p>更多无障碍属性可以参阅：<em>https://developer.mozilla.org/zh-CN/docs/Learn/Accessibility/WAI-ARIA_basics</em></p></blockquote><h2>真题解答</h2><ul><li><p>说说对 <em>html</em> 语义化的理解</p></li></ul><blockquote><p>语义化的目的主要有以下几点：</p><ol><li><p>去掉或者丢失样式的时候能够让页面呈现出清晰的结构</p></li><li><p>有利于 <em>SEO</em>：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重</p></li><li><p>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页</p></li><li><p>便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循 <em>W3C</em> 标准的团队都遵循这个标准，可以减少差异化。<em>HTML5</em> 中新增加的很多标签，例如：<em>article、nav、header</em> 和 <em>footer</em> 等，就是基于语义化设计原则</p></li></ol></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666074534205",
  "typeId": {
    "$oid": "634d7f707797638ec96fe2e9"
  }
},
{
  "_id": {
    "$oid": "634e48032fac4881713db281"
  },
  "interviewTitle": "是否了解W3C组织",
  "interviewContent": "<h1><em>W3C</em> 标准组织</h1><h2>经典真题</h2><ul><li><p>对于 <em>WEB</em> 标准以及 <em>W3C</em> 的理解与认识问题</p></li></ul><h2>什么是 <em>W3C</em></h2><ul><li><p>W3C 指万维网联盟（<em>World Wide Web Consortium</em>）</p></li><li><p>W3C 创建于<em>1994年10月</em></p></li><li><p>W3C 由 <em>Tim Berners-Lee</em> 创建</p></li><li><p>W3C 是一个<em>会员组织</em></p></li><li><p>W3C 的工作是<em>对 web 进行标准化</em></p></li><li><p>W3C 创建并维护 <em>WWW 标准</em></p></li><li><p>W3C 标准被称为 <em>W3C 推荐（W3C 规范）</em></p></li></ul><h2><em>W3C</em> 是如何创建的？</h2><p>万维网（<em>World Wide Web</em>）是作为欧洲核子研究组织的一个项目发展起来的，在那里 <em>Tim Berners-Lee</em> 开发出万维网的雏形。<em>Tim Berners-Lee</em> 是万维网的发明人，目前是万维网联盟的主任。</p><p><br></p><p><em>W3C</em> 在 <em>1994</em> 年被创建，其创立目的是为了完成麻省理工学院（<em>MIT</em>）与欧洲粒子物理研究所（<em>CERN</em>）之间的协同工作，并得到了美国国防部高级研究计划局（<em>DARPA</em>）和欧洲委员会（<em>European Commission</em>）的支持。</p><h2>标准化 <em>Web</em></h2><p><em>W3C</em> 致力于实现所有的用户都能够对 <em>Web</em> 加以利用（不论其文化教育背景、能力、财力以及其身体残疾）。</p><p><br></p><p><em>W3C</em> 同时与其他标准化组织协同工作，比如 <em>Internet</em> 工程工作小组（<em>Internet Engineering Task Force</em>）、无线应用协议（<em>WAP</em>）以及 <em>Unicode</em> 联盟（<em>Unicode Consortium</em>）。</p><p><br></p><p><em>W3C</em> 由美国麻省理工学院计算机科学和人工智能实验室 (<em>MIT CSAIL</em>)，总部位于法国的欧洲信息数学研究联盟(<em>ERCIM</em>) 和日本的庆应大学（<em>Keio University</em>）联合运作，并且在世界范围内拥有分支办事处。</p><h2><em>W3C</em> 成员</h2><p>正因为 <em>Web</em> 是如此的重要（不论在其影响范围还是在投资方面），以至于不应由任何一家单独的组织来对它的未来进行控制，因此 <em>W3C</em> 扮演着一个会员组织的角色：</p><p><br></p><p>一些知名的会员包括：</p><ul><li><p><em>IBM</em></p></li><li><p><em>Microsoft</em></p></li><li><p><em>America Online</em></p></li><li><p><em>Apple</em></p></li><li><p><em>Adobe</em></p></li><li><p><em>Macromedia</em></p></li><li><p><em>Sun Microsystems</em></p></li></ul><p><em>W3C</em> 的会员包括了：软件开发商、内容提供商、企业用户、通信公司、研究机构、研究实验室、标准化团体以及政府。</p><h2><em>W3C</em> 规范的批准步骤</h2><p>在 <em>W3C</em> 发布某个新标准的过程中，规范是通过下面的严格程序由一个简单的理念逐步确立为推荐标准的：</p><ul><li><p><em>W3C</em> 收到一份提交</p></li><li><p>由 <em>W3C</em> 发布一份记录</p></li><li><p>由 <em>W3C</em> 创建一个工作组</p></li><li><p>由 <em>W3C</em> 发布一份工作草案</p></li><li><p>由 <em>W3C</em> 发布一份候选的推荐</p></li><li><p>由 <em>W3C</em> 发布一份被提议的推荐</p></li><li><p>由 <em>W3C</em> 发布推荐</p></li></ul><blockquote><p>具体步骤可以参阅：<em>https://www.runoob.com/w3c/w3c-process.html</em></p></blockquote><h2>真题解答</h2><ul><li><p>对于 <em>WEB</em> 标准以及 <em>W3C</em> 的理解与认识问题</p></li></ul><blockquote><p>任何东西都需要一个标准，有了标准才能够更好的进行交流和推广。不同的标准，得出的便是不同的结果。因此，制定什么样的标准，如何确立标准，至关重要。</p><p><br></p><p>正因为有了网页的标准，才能降低开发难度及开发成本，减少各种 <em>BUG</em>、安全问题， 提高网站易用性。</p><p><br></p><p>就好比 <em>HTML</em> 在 <em>W3C</em> 组织推出标准之前，不同的浏览器厂商有一套自己的标准，这对于开发人员来讲是痛苦的，所以才会遗留下浏览器的标准模式和怪异模式这个历史问题。</p><p><br></p><p><em>W3C</em> 就是一个推出标准的组织，被称之为万维网联盟，<em>W3C</em> 最重要的工作是发展 <em>Web</em> 规范。</p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666074627332",
  "typeId": {
    "$oid": "634d7f707797638ec96fe2e9"
  }
},
{
  "_id": {
    "$oid": "634e48302fac4881713db288"
  },
  "interviewTitle": "请描述下 SEO 中的 TDK？",
  "interviewContent": "<h1><em>SEO</em></h1><h2>经典真题</h2><ul><li><p>请描述下 <em>SEO</em> 中的 <em>TDK</em>？</p></li></ul><h2>什么是 <em>SEO</em>？</h2><p><em>SEO</em> 由英文 <em>Search Engine Optimization</em> 缩写而来，中文意译为“搜索引擎优化”。</p><p><br></p><p>其实叫做针对搜索引擎优化更容易理解。它是指从自然搜索结果获得网站流量的技术和过程，是在了解搜索引擎自然排名机制的基础上，对网站进行内部及外部的调整优化，改进网站在搜索引擎中的关键词自然排名，获得更多流量，从而达成网站销售及品牌建设的目标。</p><h2>如何进行 <em>SEO</em> 优化工作？</h2><p>有的同学第一反应：给钱。</p><p><br></p><p>虽然，国内的百度搜索引擎，确实存在给钱就把你排在前面的情况，但是在不给钱的情况下，我们也能够通过一些优化手段来提升页面的权重，从而使我们的页面获取更多流量。</p><p><br></p><p>下面就介绍一些常见的 <em>SEO</em> 优化手段。</p><p><br></p><p>整个 <em>SEO</em> 工作大致可以分为<strong>内部优化</strong>和<strong>外部优化</strong>。</p><h3>内部优化</h3><h4>1. 合理的 <em>title、description、keywords</em></h4><p>这个就是上面经典面试题中出现的 <em>TDK</em>，其实就是这 <em>3</em> 个单词的缩写。</p><ul><li><p><em>title</em>：浏览器上显示的那些内容，不仅用户能看到，也能被搜索引擎检索到，搜索引擎在抓取网页时，最先读取的就是网页标题，所以 <em>title</em> 是否正确设置极其重要。<em>title</em> 一般不超过 <em>80</em> 个字符，而且词语间要用英文 “-” 隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。</p></li><li><p><em>description</em>：也就是网页的内容摘要，这是对于一个网页的简要内容概况。<em>description</em> 一般不超过 <em>150</em> 个字符，描述内容要和页面内容相关。</p></li><li><p><em>keywords</em>：主要作用是告诉搜索引擎本页内容是围绕哪些词展开的。因此 <em>keywords</em> 的每个词都要能在内容中找到相应匹配，才有利于排名。<em>keywords</em> 一般不超过 <em>3</em> 个，每个关键词不宜过长，而且词语间要用英文 “,” 隔开，尽量将重要的关键字靠前放。</p></li></ul><h4>2. 语义化的 <em>HTML</em> 代码，符合 <em>W3C</em> 规范</h4><p>语义化代码能够让搜索引擎容易理解网页，即使脱去了 <em>CSS</em> 这一层外衣，整个网页的结构也是清清楚楚的，无论是搜索引擎还是阅读者，都能够很容易的分辨网页的结构。</p><p><br></p><p>关于语义化的具体内容，可以参阅《语义化》章节。</p><h4>3. 非装饰性图片必须加 <em>alt</em></h4><p><em>img</em> 标签的 <em>alt</em> 属性指定了替代文本，用于在图像无法显示或者用户禁用图像显示时，代替图像显示在浏览器中的内容。</p><p><br></p><p>例如：<code data-backticks=\"1\">&lt;img src=\"/xxx.jpg\" alt=\"海尔官网-双门冰箱\" /&gt;</code></p><p><br></p><p><em>alt</em> 标签的作用：</p><ul><li><p>增强内容相关性：它是可以利用汉字介绍文章内容的，对于一些特定的企业产品，由于视觉的体验，它往往是少文字的。</p></li><li><p>提高关键词密度：在操作企业站的时候，我们经常遇到是站点首屏一个大的横幅 <em>banner</em>，几乎占用了首页的大部分页面，为了有效的提高首页核心关键词密度，我们只能利用一切办法增添关键词，比如：在图片的 <em>alt</em> 标签中添加。</p></li></ul><h4>4. 对于不显示的对象谨慎使用 <em>display:none</em></h4><p>对于不想显示的文字内容，应当设置 <em>z-index</em> 或设置到浏览器显示器之外。因为搜索引擎会过滤掉 <em>display:none</em> 其中的内容。</p><h4>5. 重要内容 <em>HTML</em> 代码放在最前</h4><p>索引擎抓取 <em>HTML</em> 顺序是从上到下，所以我们尽量将重要的内容放在前面，保证重要内容一定会被抓取。</p><h4>6. 少用 <em>iframe</em></h4><p>少用或者尽量不用 <em>iframe</em>，因为搜索引擎不会抓取 <em>iframe</em> 中的内容</p><p><br></p><p>优化的细节还有很多，更多细节可以参阅这篇博文：<em>https://blog.csdn.net/yanyihan16/article/details/89209436?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.control</em></p><h3>外部优化</h3><p>外部优化主要是指放友情链接和外链。好的友情链接可以快速的提高网站的权重，高质量的外链，会给你的网站提高源源不断的权重提升。另外，就是要向各大搜索引擎登陆入口提交尚未收录站点。</p><h2>真题解答</h2><ul><li><p>请描述下 <em>SEO</em> 中的 <em>TDK</em>？</p></li></ul><blockquote><p>在 <em>SEO</em> 中，所谓的 <em>TDK</em> 其实就是 <em>title、description、keywords</em>。</p><ul><li><p><em>title</em>：浏览器上显示的那些内容，不仅用户能看到，也能被搜索引擎检索到，搜索引擎在抓取网页时，最先读取的就是网页标题，所以 <em>title</em> 是否正确设置极其重要。<em>title</em> 一般不超过 <em>80</em> 个字符，而且词语间要用英文 “-” 隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。</p></li><li><p><em>description</em>：也就是网页的内容摘要，这是对于一个网页的简要内容概况。<em>description</em> 一般不超过 <em>150</em> 个字符，描述内容要和页面内容相关。</p></li><li><p><em>keywords</em>：主要作用是告诉搜索引擎本页内容是围绕哪些词展开的。因此 <em>keywords</em> 的每个词都要能在内容中找到相应匹配，才有利于排名。<em>keywords</em> 一般不超过 <em>3</em> 个，每个关键词不宜过长，而且词语间要用英文 “,” 隔开，尽量将重要的关键字靠前放。</p></li></ul></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666074672834",
  "typeId": {
    "$oid": "634d7f707797638ec96fe2e9"
  }
},
{
  "_id": {
    "$oid": "634e48622fac4881713db290"
  },
  "interviewTitle": "知道什么是微格式吗？",
  "interviewContent": "<h1>微格式</h1><h2>经典真题</h2><ul><li><p>知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？</p></li></ul><h2>微格式介绍</h2><p>所谓微格式，是建立在已有的、被广泛采用的标准基础之上的一组简单的、开放的数据格式。</p><p><br></p><p>具体表现是把语义嵌入到 <em>HTML</em> 中，以便有助于分离式开发，并通过制定一些简单的约定，来兼顾 <em>HTML</em> 文档的人机可读性，相当于对 <em>Web</em> 网页进行了语义注解。</p><p><br></p><p><em>talk is cheap，show me code</em></p><p><br></p><p>以前我们是这样写一个链接到首页的代码的：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;a href=”http://www.bbon.cn”&gt;Web Design Blog&lt;/a&gt;</code></pre></div><p>而现在我们要为这个代码元素 <em>a</em> 加上 <em>rel</em> 属性：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;a href=”http://www.bbon.cn“ rel=”homepage”&gt;Web Design Blog&lt;/a&gt;</code></pre></div><p>通过上面的代码，我们可以发现，多了一个 <em>rel</em> 属性。这个 <em>rel=”home”</em> 属性显示链接的目标页面是该网站的首页。</p><p><br></p><p>通过为已有的链接元素添加语义化属性，就为这个链接添加了具体的结构和意义。</p><p><br></p><p>就这？</p><p><br></p><p><em>No、No、No</em>，我们再去微格式的官网瞅一瞅：<em>https://microformats.org/</em></p><p><br></p><p>官网对微格式是这么介绍的：</p><blockquote><p><em>Microformats are based on simple markup conventions that enable you to add meaningful structure to your web content.</em></p><p><br></p><p>微格式基于简单的标记约定，使您能够向web内容添加有意义的结构。</p><p><br></p><p><em>One of the key principles of microformats, is to privilege human readable content. This means that you should think first and foremost of your content design being readable and accessible to web viewers.</em></p><p><br></p><p>微格式的一个关键原则是赋予人类可读内容特权。这意味着您应该首先考虑内容设计的可读性和可访问性。</p><p><br></p><p><em>Using the most appropriate HTML elements and applying structured class names to your markup enables you to produce content that can be clearly understood by a human audience and also used in a structured way by automated programs and other online tools.</em></p><p><br></p><p>通过使用最合适的HTML元素并将结构化类名应用到标记中，您可以生成人类观众可以清楚理解的内容，并通过自动化程序和其他在线工具以结构化方式使用这些内容。</p><p><br></p><p><em>But the point is that you shouldn't have to go out of your way to produce such machine friendly markup - microformats make it easy to integrate this greater degree of structure into your websites, without the overhead of having to learn complicated new languages or formats.</em></p><p><br></p><p>但关键是，你不应该不遗余力地制作这样的机器友好型标记——微格式可以轻松地将这种更高程度的结构集成到你的网站中，而无需学习复杂的新语言或格式。</p></blockquote><p>正如前面所介绍的，微格式就是为了兼顾 <em>HTML</em> 文档的人机可读性，在标签中添加的语义注解。</p><p><br></p><p>那好，那么我们以后书写所有的 <em>HTML</em> 代码，都要这样书写注解么？</p><p><br></p><p>并不是，否则人都傻了。微格式一般用于标记人员、组织、事件、地点、博客帖子、产品、评论、简历、食谱等的 <em>HTML</em>。</p><p><br></p><p>例如：</p><blockquote><p><em>Mark-up your contact info with h-card, link to other profiles with rel=\"me\"</em></p><p><br></p><p>使用 <em>h-card</em> 标记您的联系信息，使用 <em>rel=“me”</em> 链接到其他个人资料</p><p><br></p><p><em>Mark-up your blog with h-entry.</em></p><p><br></p><p>用 <em>h-entry</em> 标记你的博客。</p></blockquote><p>这里我们以  <em>h-card</em> 为例。</p><p><br></p><p><em>h-card</em> 是一种微格式，用来发布个人，公司，组织，地点等详细的联系信息。 它可以使分析器（比如其他网站，<em>Firefox</em> 的 <em>Operator</em> 插件）获得详细的信息，并通过别的网站或者地图工具进行显示，或者载入到地址簿等其他程序。</p><p><br></p><p>例如，没有加入 <em>h-card</em> 微格式时，我们的 <em>HTML</em> 结构如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div&gt;\n  &lt;div&gt;Joe Doe&lt;/div&gt;\n  &lt;div&gt;The Example Company&lt;/div&gt;\n  &lt;div&gt;604-555-1234&lt;/div&gt;\n  &lt;a href=\"http://example.com/\"&gt;http://example.com/&lt;/a&gt;\n&lt;/div&gt;</code></pre></div><p>加入微格式后，成为：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"vcard\"&gt;\n  &lt;div class=\"fn\"&gt;Joe Doe&lt;/div&gt;\n  &lt;div class=\"org\"&gt;The Example Company&lt;/div&gt;\n  &lt;div class=\"tel\"&gt;604-555-1234&lt;/div&gt;\n  &lt;a class=\"url\" href=\"http://example.com/\"&gt;http://example.com/&lt;/a&gt;\n&lt;/div&gt;</code></pre></div><p>这里，正式名称（<em>class=”fn”</em>），组织（<em>class=”org”</em>），电话号码（<em>class=”tel”</em>）和 <em>url</em>（<em>class=”url”</em>）分别用相应的 <em>class</em> 标示。</p><p><br></p><p>同时，所有内容都包含在 <em>class=\"vcard\"</em> 里。</p><p><br></p><p>再例如，我们用一个维基媒体基金会的联系方式，来作为 <em>h-card</em> 微格式实例。</p><p><br></p><p>加入  <em>h-card</em> 微格式之前的信息内容如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">Wikimedia Foundation Inc.\n200 2nd Ave. South #358\nSt. Petersburg, FL 33701-4313\nUSA\nPhone: +1-727-231-0101\nEmail: info@wikimedia.org\nFax: +1-727-258-0207</code></pre></div><p>加入微格式后，成为：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"vcard\"&gt;\n  &lt;div class=\"fn org\"&gt;Wikimedia Foundation Inc.&lt;/div&gt;\n  &lt;div class=\"adr\"&gt;\n  \t&lt;div class=\"street-address\"&gt;200 2nd Ave. South #358&lt;/div&gt;\n    &lt;div&gt;\n      &lt;span class=\"locality\"&gt;St. Petersburg&lt;/span&gt;,\n      &lt;span class=\"region\"&gt;FL&lt;/span&gt; &lt;span class=\"postal-code\"&gt;33701-4313&lt;/span&gt;\n    &lt;/div&gt;\n  \t&lt;div class=\"country-name\"&gt;USA&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div&gt;Phone: &lt;span class=\"tel\"&gt;+1-727-231-0101&lt;/span&gt;&lt;/div&gt;\n  &lt;div&gt;Email: &lt;span class=\"email\"&gt;info@wikimedia.org&lt;/span&gt;&lt;/div&gt;\n  &lt;div&gt;\n    &lt;span class=\"tel\"&gt;&lt;span class=\"type\"&gt;Fax&lt;/span&gt;:\n    &lt;span class=\"value\"&gt;+1-727-258-0207&lt;/span&gt;&lt;/span&gt;\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre></div><p>在这个例子中，正式名称（<em>class=”fn”</em>）和组织（<em>class=”org”</em>）写在了一个属性中，表示这是一个组织，而不是个人。</p><p><br></p><p>这个时候，有的小伙伴就要提问了，这些 <em>h-card</em> 里面的属性名是固定的么？</p><p><br></p><p>没错，常用的  <em>h-card</em>  属性还包括：<em>bday</em>（生日）、<em>email</em>（邮箱）、<em>tel</em>（电话）、<em>nickname</em>（昵称）等。</p><p><br></p><p>目前已具备完整规范的微格式还包括：<em>hCard、hCalendar、XOXO、XFN、VoteLinks</em> 和 <em>3</em> 个 “rel-” 的微格式：<em>rel- license、rel-nofollow</em> 和 <em>rel-tag</em>。</p><p><br></p><p>至于每一种微格式的规范（里面有哪些属性）是什么，我们可以在官网进行查阅。</p><p><br></p><p>例如：  <em>h-card</em>  的规范就可以参阅：<em>https://microformats.org/wiki/h-card</em></p><h2>真题解答</h2><ul><li><p>知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>所谓微格式，是建立在已有的、被广泛采用的标准基础之上的一组简单的、开放的数据格式。</p><p><br></p><p>具体表现是把语义嵌入到 <em>HTML</em> 中，以便有助于分离式开发，并通过制定一些简单的约定，来兼顾 <em>HTML</em> 文档的人机可读性，相当于对 <em>Web</em> 网页进行了语义注解。</p><p><br></p><p>采用微格式的 <em>Web</em> 页面，在 <em>HTML</em> 文档中给一些标签增加一些属性，这些属性对信息的语义结构进行注解，有助于处理 <em>HTML</em> 文档的软件，更好的理解该 <em>HTML</em> 文档。</p><p><br></p><p><strong>在前端构建中微格式的意义</strong></p><p><br></p><p>微格式按照某种已有的被广泛应用的标准，通过对内容块的语义标记，可以让外部应用程序、聚合程序和搜索引擎能够做以下事情：</p><ol><li><p>在爬取 <em>Web</em> 内容时，能够更为准确地识别内容块的语义；</p></li><li><p>对内容进行操作，包括提供访问、校对，还可以将其转化成其他的相关格式，提供给外部程序和Web服务使用。</p></li></ol><p>总结： 微格式可以对网站进行 <em>SEO</em> 优化，如果需要可以考虑。</p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666074722699",
  "typeId": {
    "$oid": "634d7f707797638ec96fe2e9"
  }
},
{
  "_id": {
    "$oid": "634e48952fac4881713db294"
  },
  "interviewTitle": "什么是可替换元素，什么是非可替换元素，它们各自有什么特点？",
  "interviewContent": "<h1>替换元素</h1><h2>经典真题</h2><ul><li><p>什么是可替换元素，什么是非可替换元素，它们各自有什么特点？</p></li></ul><h2>什么是替换元素</h2><p>所谓可替换元素（<em>replaced element</em>），是指一些展现效果不由 <em>CSS</em> 来控制的元素。这些元素是一种外部对象，它们外观的渲染，是独立于 <em>CSS</em> 的。</p><p><br></p><p>简单来说，它们的内容不受当前文档的样式的影响。<em>CSS</em> 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。某些可替换元素，例如 <code data-backticks=\"1\">&lt;iframe&gt;</code> 元素，可能具有自己的样式表，但它们不会继承父文档的样式。</p><p><br></p><p>与替换元素相对应的，就是非替换元素，顾名思义就是那些样式完全由 <em>CSS</em> 来控制的元素，例如 <em>p，h1～h6</em> 等。</p><blockquote><p>更多可替换元素内容可以参阅 <em>MDN</em>：<em>https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element</em></p></blockquote><h2>常见的替换元素</h2><ul><li><p>图片标签 <em>img</em></p></li><li><p>内联框架 <em>iframe</em></p></li><li><p>音频视频标签</p></li></ul><h2>真题解答</h2><ul><li><p>什么是可替换元素，什么是非可替换元素，它们各自有什么特点？</p></li></ul><blockquote><p>可替换元素是指这样一种元素，它在页面中的大部分展现效果不由 <em>CSS</em> 决定。</p><p><br></p><p>比如 <em>img</em> 元素就是一个可替换元素，它在页面中显示出的效果主要取决于你连接的是什么图片，图片是什么它就展示什么，<em>CSS</em> 虽然可以控制图片的尺寸位置，但永远无法控制图片本身。</p><p><br></p><p>再比如，<em>select</em> 元素也是一个典型的可替换元素，它在页面上呈现的是用户操作系统上的下拉列表样式，因此，它的展现效果是由操作系统决定的。所以，同一个 <em>select</em> 元素，放到不同操作系统的电脑上会呈现不同的外观。</p><p><br></p><p><em>img、video、audio</em>、大部分表单元素都属于可替换元素。</p><p><br></p><p>非可替换元素就是指的普通元素，它具体在页面上呈现什么，完全由 <em>CSS</em> 来决定。</p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666074773186",
  "typeId": {
    "$oid": "634d7f707797638ec96fe2e9"
  }
},
{
  "_id": {
    "$oid": "634e48b72fac4881713db298"
  },
  "interviewTitle": "页面可见性 API 可以有哪些用途？",
  "interviewContent": "<h1>页面可见性</h1><h2>经典真题</h2><ul><li><p>页面可见性（<em>Page Visibility</em>）<em>API</em> 可以有哪些用途？</p></li></ul><h2>页面可见性介绍</h2><p>长期以来我们一直缺少一个判断用户是否正在浏览某个指定标签页的方法。</p><p><br></p><p>用户是否去看别的网站了？他们切换回来了么？</p><p><br></p><p>现在，<em>HTML5</em> 里页面可见性接口就提供给了程序员一个方法，让他们使用 <em>visibilitychange</em> 页面事件来判断当前页面可见性的状态，并针对性的执行某些任务。同时还有新的 <em>document.hidden</em> 属性可以使用。</p><p><br></p><p>常用的 <em>API</em> 如下：</p><ul><li><p><strong><em>document.hidden</em></strong>：这个新出现的 <em>document.hidden</em> 属性，它显示页面是否为用户当前观看的页面，值为 <em>ture</em> 或 <em>false</em>。</p></li><li><p><strong><em>document.visibilityState</em></strong>：<em>visibilityState</em> 的值要么是 <em>visible</em> ，表明页面为浏览器当前激活 <em>tab</em>，而且窗口不是最小化状态；要么是 <em>hidden</em> ，表示页面不是当前激活 <em>tab</em> 页面，或者窗口最小化了；或者 <em>prerender</em> ，表示页面在重新生成，对用户不可见。</p></li><li><p><strong><em>visibilitychange</em></strong> 事件：监听页面可见性变化事件</p></li></ul><p>下面是一个页面可见性的具体示例：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;body&gt;\n    &lt;p&gt;页面可见性示例&lt;/p&gt;\n    &lt;script&gt;\n        document.addEventListener(\"visibilitychange\", function () {\n            if(document.visibilityState === \"hidden\"){\n                document.title = \"小样去哪儿了？快回来\"\n            }\n            if(document.visibilityState === \"visible\"){\n                document.title = \"页面可见性示例\"\n            }\n        });\n    &lt;/script&gt;\n&lt;/body&gt;</code></pre></div><blockquote><p>更多有关页面可见性的内容可以参阅 <em>MDN</em>：<em>https://developer.mozilla.org/zh-CN/docs/Web/API/Page_Visibility_API</em></p></blockquote><h2>真题解答</h2><ul><li><p>页面可见性（<em>Page Visibility</em>）<em>API</em> 可以有哪些用途？</p></li></ul><blockquote><p>所谓页面可见性，就是获取当前页面的可见状态。因为对于用户来讲可以打开好多标签页面来回切换，然而始终只有一个页面处于显示状态。所以我们可以通过页面可见性（<em>Page Visibility</em>）<em>API</em> 来判断当前页面是显示状态还是隐藏状态。</p><p><br></p><p>常用的 <em>API</em> 有三个，<em>document.hidden</em> 返回一个布尔值，如果是 <em>true</em>，表示当前页面隐藏，<em>false</em> 则表示页面可见。不同页面之间来回切换，会触发 <em>visibilitychange</em> 事件，还有一个 <em>document.visibilityState</em>，表示页面所处的状态。</p><p><br></p><p>常见的用途：</p><ul><li><p>网站有图片轮播效果，只有在用户观看轮播的时候，才会自动展示下一张幻灯片。</p></li><li><p>显示信息仪表盘的应用程序不希望在页面不可见时轮询服务器进行更新。</p></li><li><p>页面想要检测是否正在渲染，以便可以准确的计算网页浏览量</p></li><li><p>当设备进入待机模式时，网站想要关闭设备声音（用户按下电源键关闭屏幕）</p></li></ul></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666074807077",
  "typeId": {
    "$oid": "634d7f707797638ec96fe2e9"
  }
},
{
  "_id": {
    "$oid": "634e49a12fac4881713db29f"
  },
  "interviewTitle": "请简述 px 和 em 的区别 ？",
  "interviewContent": "<h1><em>CSS</em> 单位总结</h1><h2>经典真题</h2><ul><li><p><em>px</em> 和 <em>em</em> 的区别</p></li></ul><h2><em>CSS</em> 中的哪些单位</h2><p>首先，在 <em>CSS</em> 中，单位分为两大类，<strong>绝对长度单位</strong>和<strong>相对长度单位</strong>。</p><h3>绝对长度单位</h3><p>我们先来说这个，绝对长度单位最好理解，和我们现实生活中是一样的。在我们现实生活中，常见的长度单位有米（<em>m</em>）、厘米（<em>cm</em>）、毫米（<em>mm</em>），每一种单位的长度都是固定，比如 <em>5cm</em>，你走到任何地方 <em>5cm</em> 的长度都是一致的</p><p><br></p><p>例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"container\"&gt;&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.container{\n  width: 5cm;\n  height: 5cm;\n  background-color: pink;\n}</code></pre></div><p>在上面的代码中，我们设置了盒子的宽高都是 <em>5cm</em>，这里用的就是绝对长度单位。</p><p><br></p><p>常见的绝对单位长度如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-14-073818.png\" alt=\"image-20210914153818508\" contenteditable=\"false\"><br></p><p><br></p><p>这些值中的大多数在用于打印时比用于屏幕输出时更有用。例如，我们通常不会在屏幕上使用 <em>cm</em>。</p><p><br></p><p>惟一一个经常使用的值，估计就是 <em>px</em>(像素)。</p><h3>相对长度单位</h3><p>相对长度单位相对于其他一些东西，比如父元素的字体大小，或者视图端口的大小。使用相对单位的好处是，经过一些仔细的规划，我们可以使文本或其他元素的大小与页面上的其他内容相对应。</p><p><br></p><p>下表列出了 <em>web</em> 开发中一些最有用的单位。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-14-074021.png\" alt=\"image-20210914154021389\" contenteditable=\"false\"><br></p><p><br></p><p>上面的单位中，常用的有 <em>em、rem、vw、vh</em>，其中 <em>vw</em> 和 <em>vh</em> 代表的是视口的宽度和高度，例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"container\"&gt;&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">*{\n  margin: 0;\n  padding: 0;\n}\n.container {\n  width: 50vw;\n  height: 100vh;\n  background-color: pink;\n}</code></pre></div><p>在上面的代码中，我们设置了容器的宽度为 <em>50vw</em>，也就是占视口的一半，而高度我们设置的是 <em>100vh</em>，就是占满整个视图。</p><p><br></p><p>接下来来看一下 <em>em</em> 和 <em>rem</em>。</p><p><br></p><p><em>em</em> 和 <em>rem</em> 相对于 <em>px</em> 更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。</p><p><br></p><p>对于 <em>em</em> 和 <em>rem</em> 的区别一句话概括：<strong><em>em</em> 相对于父元素，<em>rem</em> 相对于根元素。</strong></p><p><br></p><p>来看关于 <em>em</em> 和 <em>rem</em> 示例。</p><p><br></p><p><em>em</em> 示例</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div&gt;\n  我是父元素div\n  &lt;p&gt;\n    我是子元素p\n    &lt;span&gt;我是孙元素span&lt;/span&gt;\n  &lt;/p&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">* {\n  margin: 0;\n  padding: 0;\n}\n\ndiv {\n  font-size: 40px;\n  width: 10em;\n  /* 400px */\n  height: 10em;\n  outline: solid 1px black;\n  margin: 10px;\n}\n\np {\n  font-size: 0.5em;\n  /* 20px */\n  width: 10em;\n  /* 200px */\n  height: 10em;\n  outline: solid 1px red;\n}\n\nspan {\n  font-size: 0.5em;\n  width: 10em;\n  height: 10em;\n  outline: solid 1px blue;\n  display: block;\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-14-075220.png\" alt=\"image-20210914155219732\" contenteditable=\"false\"><br></p><p><br></p><p><em>rem</em> 示例</p><p><br></p><p><em>rem</em> 是全部的长度都相对于根元素，根元素是谁？</p><p><br></p><p>那就是 <em>html</em>元素。通常做法是给 <em>html</em> 元素设置一个字体大小，然后其他元素的长度单位就为 <em>rem</em>。</p><p><br></p><p>例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div&gt;\n  我是父元素div\n  &lt;p&gt;\n    我是子元素p\n    &lt;span&gt;我是孙元素span&lt;/span&gt;\n  &lt;/p&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">* {\n  margin: 0;\n  padding: 0;\n}\n\nhtml {\n  font-size: 10px;\n}\n\ndiv {\n  font-size: 4rem;\n  /* 40px */\n  width: 30rem;\n  /* 300px */\n  height: 30rem;\n  /* 300px */\n  outline: solid 1px black;\n  margin: 10px;\n}\n\np {\n  font-size: 2rem;\n  /* 20px */\n  width: 15rem;\n  /* 150px */\n  height: 15rem;\n  /* 150px */\n  outline: solid 1px red;\n}\n\nspan {\n  font-size: 1.5rem;\n  width: 10rem;\n  height: 10rem;\n  outline: solid 1px blue;\n  display: block;\n}</code></pre></div><p>所以当用 <em>rem</em> 做响应式时，直接在媒体中改变 <em>html</em> 的 <em>font-size</em>，此时用 <em>rem</em> 作为单位的元素的大小都会相应改变，很方便。</p><p><br></p><p>看到这里我想大家都能够更深刻的体会了 <em>em</em> 和 <em>rem</em> 的区别了，其实就是参照物不同。</p><h2>真题解答</h2><ul><li><p><em>px</em> 和 <em>em</em> 的区别</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p><em>px</em> 即 <em>pixel</em> 像素，是相对于屏幕分辨率而言的，是一个绝对单位，但是具有一定的相对性。因为在同一设备上每个设备像素所代表的物理长度是固定不变的（绝对性），但在不同设备间每个设备像素所代表的物理长度是可以变化的（相对性）。</p><p><br></p><p><em>em</em> 是相对长度单位，具体的大小要相对于父元素来计算，例如父元素的字体大小为 <em>40px</em>，那么子元素 <em>1em</em> 就代表字体大小和父元素一样为 <em>40px</em>，<em>0.5em</em> 就代表字体大小为父元素的一半即 <em>20px</em>。</p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666075041417",
  "typeId": {
    "$oid": "634d7fc47797638ec96fe2ee"
  }
},
{
  "_id": {
    "$oid": "634e49d12fac4881713db2a7"
  },
  "interviewTitle": "怎么让一个 div 水平垂直居中",
  "interviewContent": "<h1>居中方式总结</h1><h2>经典真题</h2><ul><li><p>怎么让一个 <em>div</em> 水平垂直居中</p></li></ul><h2>盒子居中</h2><p>首先题目问到了如何进行居中，那么居中肯定分 <em>2</em> 个方向，一个是水平方向，一个是垂直方向。</p><h3>水平方向居中</h3><p>水平方向居中很简单，有 <em>2</em> 种常见的方式：</p><ol><li><p>设置盒子 <em>margin : 0 auto</em>：这种居中方式的原理在于设置 <em>margin-left</em> 为 <em>auto</em> 时，<em>margin-left</em> 就会被设置为能有多大就设置多大，所以盒子会跑到最右边，而设置 <em>margin-right</em> 为 <em>auto</em> 时，同理盒子就会跑到最左边。所以，当我们设置左右的 <em>margin</em> 都是 <em>auto</em> 的时候，盒子就跑到了中间，从而形成了水平居中。</p></li><li><p>第二种常见的方式就是通过 <em>display : flex</em> 设置盒子的外层盒子是一个弹性盒，然后通过 <em>justify-content : center</em> 使得内部的盒子居中。</p></li></ol><h3>垂直方向居中</h3><p>关于盒子的垂直方向居中，方法就比较多了，这里介绍几种：</p><ol><li><p>通过 <em>verticle-align:middle</em> 实现垂直居中</p></li></ol><p>通过 <em>vertical-align:middle</em> 实现垂直居中是最常使用的方法，但是有一点需要格外注意，<em>vertical</em> 生效的前提是元素的 <em>display：inline-block</em>。并且在使用 <em>vertical-align:middle</em> 的时候需要一个兄弟元素做参照物，让它垂直于兄弟元素的中心点。<em>vertical-align</em> 对齐的方法是寻找兄弟元素中最高的元素作为参考。</p><p><br></p><p>代码示例如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"container\"&gt;\n  &lt;div class=\"item\"&gt;&lt;/div&gt;\n  &lt;div class=\"brotherBox\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.container{\n  width: 500px;\n  height: 300px;\n  background-color: pink;\n  text-align: center;\n}\n.item{\n  width: 100px;\n  height: 100px;\n  background-color: skyblue;\n  vertical-align: middle;\n  margin: 0 auto;\n  display: inline-block;\n}\n.brotherBox{\n  height: 100%;\n  /* width: 2px; */\n  background: red;\n  display: inline-block;\n  vertical-align: middle;\n}</code></pre></div><ol start=\"2\"><li><p>通过伪元素 :<em>before</em> 实现垂直居中</p></li></ol><p>平白无故添加一个无意义的参考元素不怎么好，我们可以去除作为参考的兄弟元素，转为给父元素添加一个伪元素，如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"container\"&gt;\n  &lt;div class=\"item\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.container{\n  width: 500px;\n  height: 300px;\n  background-color: pink;\n  text-align: center;\n}\n.container::before{\n  content : '';\n  display: inline-block;\n  vertical-align: middle;\n  height: 100%;\n}\n.item{\n  width: 100px;\n  height: 100px;\n  background-color: skyblue;\n  vertical-align: middle;\n  margin: 0 auto;\n  display: inline-block;\n}</code></pre></div><ol start=\"3\"><li><p>通过绝对定位实现垂直居中</p></li></ol><p>这种方式需要设置父元素为相对定位，子元素为绝对定位，然后配合 <em>margin-left</em> 为负的盒子高度一半来实现垂直居中</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"container\"&gt;\n  &lt;div class=\"item\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.container{\n  width: 500px;\n  height: 300px;\n  background-color: pink;\n  position: relative;\n}\n.item{\n  width: 100px;\n  height: 100px;\n  background-color: skyblue;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  margin-left: -50px;\n  margin-top: -50px;\n}</code></pre></div><ol start=\"4\"><li><p>通过 <em>transform</em> 实现垂直居中</p></li></ol><p>可以通过定位配合 <em>transform</em> 也可以实现垂直居中</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"container\"&gt;\n  &lt;div class=\"item\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.container{\n  width: 500px;\n  height: 300px;\n  background-color: pink;\n  position: relative;\n}\n.item{\n  width: 100px;\n  height: 100px;\n  background-color: skyblue;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translateX(-50px) translateY(-50px);\n}</code></pre></div><ol start=\"5\"><li><p>使用弹性盒子居中</p></li></ol><p>通过设置父元素为弹性盒子，然后使用 <em>justify-content: center</em> 和 <em>align-items: center</em> 来设置内部盒子水平垂直居中</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"container\"&gt;\n  &lt;div class=\"item\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.container{\n  width: 500px;\n  height: 300px;\n  background-color: pink;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.item{\n  width: 100px;\n  height: 100px;\n  background-color: skyblue;\n}</code></pre></div><p>以上就是比较常见的盒子居中的解决方案，当然目前来讲最推荐的就是使用弹性盒子，这是目前最常用的一种方式，也是最推荐的一种方式。</p><h2>真题解答</h2><ul><li><p>怎么让一个 <em>div</em> 水平垂直居中</p></li></ul><blockquote><p>参考答案：</p><ol><li><p>通过 <em>verticle-align:middle</em> 实现垂直居中</p></li><li><p>通过父元素设置伪元素 :<em>before</em> ，然后设置子元素  <em>verticle-align:middle</em> 实现垂直居中</p></li><li><p>通过绝对定位实现垂直居中</p></li><li><p>通过 <em>transform</em> 实现垂直居中</p></li><li><p>使用弹性盒子居中</p></li></ol></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666075089866",
  "typeId": {
    "$oid": "634d7fc47797638ec96fe2ee"
  }
},
{
  "_id": {
    "$oid": "634e4a2c2fac4881713db2b4"
  },
  "interviewTitle": "隐藏页面中的某个元素的方法有哪些？",
  "interviewContent": "<h1>隐藏元素方式总结</h1><h2>经典真题</h2><ul><li><p>隐藏页面中的某个元素的方法有哪些？</p></li></ul><h2>隐藏元素方案汇总</h2><p>首先什么叫隐藏元素，大家第一反应就是 <em>display:none</em>，元素就被隐藏了。</p><p><br></p><p>没错，这确实是隐藏元素的一种，但是太过于片面。我们隐藏元素实际上可以分为 <em>3</em> 大类：</p><ul><li><p>完全隐藏：元素从渲染树中消失，不占据空间。</p></li><li><p>视觉上的隐藏：屏幕中不可见，占据空间。</p></li><li><p>语义上的隐藏：读屏软件不可读，但正常占据空间。</p></li></ul><h3>完全隐藏</h3><p><strong><em>display</em> 属性</strong></p><p><br></p><p>首先就是设置 <em>display</em> 为 <em>none</em>，这样元素就被隐藏了，并且是不占据空间的。</p><p><br></p><p><strong><em>hidden</em> 属性</strong></p><p><br></p><p>这是 <em>HTML5</em> 新增属性，相当于 <em>display: none</em>，直接写在元素上面，例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div hidden&gt;&lt;/div&gt;</code></pre></div><h3>视觉上隐藏</h3><p>视觉上的隐藏，就是说元素还占据着位置，只是视觉上不可见而已。</p><p><br></p><p><strong><em>opacity</em> 属性</strong></p><p><br></p><p>这是大家比较熟知的一种方式，将透明度设置为 <em>0</em>，视觉上就会变得不可见。</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">opacity:0</code></pre></div><p><strong><em>visibility:hidden</em></strong></p><p><br></p><p>这也是大家比较熟知的一种方式，通过 <em>CSS</em> 中的 <em>visibility</em> 属性来隐藏元素，使其不可见，但是仍然会占位</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">visibility:hidden</code></pre></div><p><strong>绝对定位</strong></p><p><br></p><p>这种方式以前用的比较多，设置 <em>posoition</em> 为 <em>absolute</em> 或 <em>fixed</em>，\b通过设置 <em>top、left</em> 等值，将其移出可视区域。例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">position: absolute;\nleft: -999px;\ntop: -999px;</code></pre></div><p><strong>设置 <em>margin</em></strong></p><p><br></p><p>通过设置 <em>margin</em> 值，将其移出可视区域范围（可视区域占位）。例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">margin-left: -99999px;</code></pre></div><p><strong>设置宽高为 <em>0</em></strong></p><p><br></p><p>这也是比较常见的一种方式，简单说就是将元素的 <em>margin、border、padding、height</em> 和 <em>width</em> 等影响元素盒模型的属性设置成 <em>0</em>，如果元素内有子元素或内容，还应该设置其 <em>overflow:hidden</em> 来隐藏其子元素</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">width: 0px;\nheight: 0px;\noverflow: hidden</code></pre></div><p><strong>裁剪元素</strong></p><p><br></p><p>隐藏元素的另一种方法是通过剪裁它们实现，具体是通过 <em>clip-path</em> 属性，这个属性比较新，浏览器兼容性也会比较差，但是了解一下还是非常有必要的。例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px);</code></pre></div><h3>语义上隐藏</h3><p><strong><em>aria-hidden</em> 属性</strong></p><p><br></p><p>通过设置 <em>aria-hidden</em> 属性为 <em>true</em> 使读屏软件不可读，但是元素仍然占据空间并且可见。</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">&lt;div aria-hidden=\"true\"&gt;&lt;/div&gt;</code></pre></div><h2>真题解答</h2><ul><li><p>隐藏页面中的某个元素的方法有哪些？</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>隐藏元素可以分为 <em>3</em> 大类：</p><ul><li><p>完全隐藏：元素从渲染树中消失，不占据空间。</p></li><li><p>视觉上的隐藏：屏幕中不可见，占据空间。</p></li><li><p>语义上的隐藏：读屏软件不可读，但正常占据空。</p></li></ul><p>完全隐藏的方式有：设置 <em>display:none</em>、为元素设置 <em>hidden</em> 属性。</p><p><br></p><p>视觉上隐藏的方式有：设置 <em>opacity</em> 属性为 <em>0</em>、绝对定位的 <em>left</em> 和 <em>top</em> 值设置为 <em>-999px</em>、设置 <em>margin-left</em> 值为 <em>-999px</em>、设置宽高为 <em>0</em>、裁剪元素。</p><p><br></p><p>语义上的隐藏方式为将 <em>aria-hidden</em> 属性设置为 <em>true</em> 使读屏软件不可读。</p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666075180920",
  "typeId": {
    "$oid": "634d7fc47797638ec96fe2ee"
  }
},
{
  "_id": {
    "$oid": "634e4a5c2fac4881713db2bb"
  },
  "interviewTitle": "清除浮动的方法有哪些？",
  "interviewContent": "<h1>浮动</h1><h2>经典真题</h2><ul><li><p>清除浮动的方法</p></li><li><p>以下选项能够清除浮动的是（ ）</p></li></ul><blockquote><p>A. 空 <em>div</em></p><p><br></p><p>B. <em>hover</em> 伪选择器</p><p><br></p><p>C. <em>clear</em> 属性</p><p><br></p><p>D. <em>overflow</em> 属性</p></blockquote><h2>关于浮动，你需要知道的东西</h2><h3>浮动出现的背景</h3><p>浮动属性产生之初是为了实现“文字环绕”的效果，让文字环绕图片，从而使网页实现类似 <em>word</em> 中“图文混排”的效果。来看下面的例子：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"container\"&gt;\n  &lt;img src=\"./ok.png\" alt=\"\" width=\"200\"&gt;\n  &lt;p&gt;Lorem, ipsum dolor sit amet consectetur adipisicing elit. Doloribus quos est rerum repellat alias maiores\n    nobis harum recusandae corrupti assumenda qui aut ipsam deserunt dolorem modi, culpa hic ex illo repellendus\n    atque. Numquam iste porro perspiciatis. Harum esse magni exercitationem, perspiciatis libero soluta quo ea\n    dolorem. Delectus tempore magnam vitae voluptatibus, non quasi laudantium, aliquam consequuntur perspiciatis\n    maiores esse neque animi voluptate. Animi pariatur debitis quam aliquam recusandae quis ut nisi totam sint\n    consectetur distinctio, quos saepe cum quo iure natus delectus! Ad, dolore. Ut temporibus ea autem fugiat\n    laboriosam quidem iste rerum laborum. Repellendus recusandae sequi id excepturi alias?&lt;/p&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.container {\n  width: 800px;\n  border: 1px solid;\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-18-031725.png\" alt=\"image-20210918111724895\" contenteditable=\"false\"><br></p><p><br></p><p>由于 <em>p</em> 段落是块级元素，所以独占一行，图片和段落是分开的。</p><p><br></p><p>接下来我们设置图片浮动：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.container {\n  width: 800px;\n  border: 1px solid;\n}\nimg{\n  float: left;\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-18-032006.png\" alt=\"image-20210918112006064\" contenteditable=\"false\"><br></p><p><br></p><p>当我们设置了图片浮动后，就出现了类似 “<em>word</em>” 的文字环绕效果。</p><p><br></p><p>这实际上也是浮动最初被设计出来的目的。</p><h3>浮动实现布局</h3><p>到了后面，浮动渐渐被应用到了页面布局上。因为 <em>HTML</em> 里面的元素，要么是行内元素，要么是块级元素，这种方式是没办法做页面布局的，例如我想实现两个块级元素在一行。此时开发人员就想到了浮动，因为任何东西都可以浮动，而不仅仅是图像，所以浮动的使用范围扩大了，能够用来进行布局。</p><h4>两列布局</h4><p>下面我们来看一下使用浮动实现的两列布局：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;h1&gt;2 column layout example&lt;/h1&gt;\n&lt;div&gt;\n  &lt;h2&gt;First column&lt;/h2&gt;\n  &lt;p&gt; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem\n    placerat vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet\n    nunc, at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum,\n    tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada\n    et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus\n    sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec lacus varius\n    commodo et a urna. Ut id ornare felis, eget fermentum sapien.&lt;/p&gt;\n&lt;/div&gt;\n\n&lt;div&gt;\n  &lt;h2&gt;Second column&lt;/h2&gt;\n  &lt;p&gt;Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada ultrices. Phasellus turpis est,\n    posuere sit amet dapibus ut, facilisis sed est. Nam id risus quis ante semper consectetur eget aliquam\n    lorem. Vivamus tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus sed lobortis\n    finibus. Vivamus eu urna eget velit cursus viverra quis vestibulum sem. Aliquam tincidunt eget purus in\n    interdum. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.&lt;/p&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">body {\n  width: 90%;\n  max-width: 900px;\n  margin: 0 auto;\n}\n\ndiv:nth-of-type(1) {\n  width: 48%;\n  float: left;\n}\n\ndiv:nth-of-type(2) {\n  width: 48%;\n  float: right;\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-18-050209.png\" alt=\"image-20210918130208288\" contenteditable=\"false\"><br></p><p><br></p><p>在上面的代码中，我们让两个 <em>div</em> 一个左浮动一个右浮动，从而实现了两列布局的效果。</p><h4>三列布局</h4><p>现在我们已经有了一个两列布局工作，添加一个第三列（或更多）并不是太难。</p><p><br></p><p>下面是一个使用浮动实现的三列布局。</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;h1&gt;3 column layout example&lt;/h1&gt;\n&lt;div&gt;\n  &lt;h2&gt;First column&lt;/h2&gt;\n  &lt;p&gt; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem\n    placerat vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet\n    nunc, at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum,\n    tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada\n    et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus\n    sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec lacus varius\n    commodo et a urna. Ut id ornare felis, eget fermentum sapien.&lt;/p&gt;\n&lt;/div&gt;\n\n&lt;div&gt;\n  &lt;h2&gt;Second column&lt;/h2&gt;\n  &lt;p&gt;Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada ultrices. Phasellus turpis est,\n    posuere sit amet dapibus ut, facilisis sed est. Nam id risus quis ante semper consectetur eget aliquam\n    lorem. Vivamus tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus sed lobortis\n    finibus. Vivamus eu urna eget velit cursus viverra quis vestibulum sem. Aliquam tincidunt eget purus in\n    interdum. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.&lt;/p&gt;\n&lt;/div&gt;\n&lt;div&gt;\n  &lt;h2&gt;Third column&lt;/h2&gt;\n  &lt;p&gt;Nam consequat scelerisque mattis. Duis pulvinar dapibus magna, eget congue purus mollis sit amet. Sed euismod\n    lacus sit amet ex tempus, a semper felis ultrices. Maecenas a efficitur metus. Nullam tempus pharetra\n    pharetra. Morbi in leo mauris. Nullam gravida ligula eros, lacinia sagittis lorem fermentum ut. Praesent\n    dapibus eros vel mi pretium, nec convallis nibh blandit. Sed scelerisque justo ac ligula mollis laoreet. In\n    mattis, risus et porta scelerisque, augue neque hendrerit orci, sit amet imperdiet risus neque vitae lectus.\n    In tempus lectus a quam posuere vestibulum. Duis quis finibus mi. Nullam commodo mi in enim maximus\n    fermentum. Mauris finibus at lorem vel sollicitudin.&lt;/p&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">body {\n  width: 90%;\n  max-width: 900px;\n  margin: 0 auto;\n}\n\ndiv:nth-of-type(1) {\n  width: 36%;\n  float: left;\n}\n\ndiv:nth-of-type(2) {\n  width: 30%;\n  float: left;\n  margin-left: 4%;\n}\n\ndiv:nth-of-type(3) {\n  width: 26%;\n  float: right;\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-18-050610.png\" alt=\"image-20210918130610163\" contenteditable=\"false\"><br></p><h3>浮动的特性</h3><p>在上面，我们已经实现了两列布局和三列布局，可以看出，浮动确实能够拿来布局。</p><p><br></p><p>接下来我们就需要具体研究一下浮动有哪些特性了。</p><ol><li><p><strong>脱离标准流</strong></p></li></ol><p>浮动的第一个特点就是脱离标准流，例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"one\"&gt;&lt;/div&gt;\n&lt;div class=\"two\"&gt;&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.one {\n  width: 80px;\n  height: 80px;\n  background-color: red;\n  float: left;\n}\n\n.two {\n  width: 150px;\n  height: 150px;\n  background-color: blue;\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-18-051127.png\" alt=\"image-20210918131127272\" contenteditable=\"false\"><br></p><p><br></p><p>由于红色的 <em>div</em> 浮动脱离了标准流，所以蓝色的 <em>div</em> 自然而然就往上走了。</p><ol start=\"2\"><li><p><strong>浮动的元素互相贴靠</strong></p></li></ol><p>如果有多个浮动的元素，那么会相互贴靠，如果宽度不够，会重启一行。</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.two {\n  width: 150px;\n  height: 150px;\n  background-color: blue;\n  float: left;\n}</code></pre></div><p>还是上面的 <em>DOM</em> 结构，我们让 <em>two</em> 这个盒子也浮动，效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-18-051424.png\" alt=\"image-20210918131424633\" contenteditable=\"false\"><br></p><p><br></p><p>如果宽度不足以让后面的盒子贴靠，那么后面浮动的元素会被排列到下一行：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.two {\n  width: 850px;\n  height: 150px;\n  background-color: blue;\n  float: left;\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-18-051627.png\" alt=\"image-20210918131627324\" contenteditable=\"false\"><br></p><p><br></p><p>在上面的示例中，我们将蓝色盒子的宽度修改为了 <em>850px</em>，当我们缩小浏览器时，由于宽度不够蓝色盒子重新排列到了第二排。</p><ol start=\"3\"><li><p><strong>宽度收缩</strong></p></li></ol><p>在没有设置宽度的情况下，块级元素在标准流时很多时独占一行，宽度也会占满整个容器，但是一旦被设置为浮动后，宽度就会收缩。</p><p><br></p><p>例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div&gt;this is a test&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div{\n  background-color: red;\n  float: left;\n}</code></pre></div><p>本来 <em>div</em> 是占满整行的，但是当我们设置了浮动后，由于 <em>div</em> 又没有设置宽度，所以宽度就收缩了。</p><h3>清除浮动</h3><p>有些时候，浮动会带来副作用，所以我们需要清除浮动带来的副作用。</p><p><br></p><p>例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;ul&gt;\n  &lt;li&gt;导航1&lt;/li&gt;\n  &lt;li&gt;导航2&lt;/li&gt;\n  &lt;li&gt;导航3&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ul&gt;\n  &lt;li&gt;游戏&lt;/li&gt;\n  &lt;li&gt;动漫&lt;/li&gt;\n  &lt;li&gt;音乐&lt;/li&gt;\n&lt;/ul&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">li {\n  float: left;\n  width: 100px;\n  height: 20px;\n  background-color: pink;\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-18-052700.png\" alt=\"image-20210918132700157\" contenteditable=\"false\"><br></p><p><br></p><p>在上面的示例中，我们本来是打算做两个导航栏的，但是由于浮动的贴靠性质，导致所有的 <em>li</em> 都在一行了。</p><p><br></p><p>这个时候我们就需要一些方式来清除浮动。</p><ol><li><p><strong>给父元素设置高度</strong></p></li></ol><p>在上面的示例中，由于 <em>li</em> 的父元素 <em>ul</em> 没有高度，所以导致明明不是同一个父元素下的浮动子元素，也会相互贴靠。</p><p><br></p><p>此时我们就给 <em>li</em> 的父元素 <em>ul</em> 设置一个高度即可。例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">ul{\n  height: 50px;\n}\nli {\n  float: left;\n  width: 100px;\n  height: 20px;\n  background-color: pink;\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-18-053639.png\" alt=\"image-20210918133638708\" contenteditable=\"false\"><br></p><p><br></p><p>需要注意给父元素设置高度时，这个高度值一定要大于浮动子元素的高度，这样才能关注浮动。例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">ul{\n  height: 30px;\n}\nli {\n  float: left;\n  width: 100px;\n  height: 70px;\n  background-color: pink;\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-18-053929.png\" alt=\"image-20210918133928678\" contenteditable=\"false\"><br></p><p><br></p><p>在上面的示例中，虽然我们给父元素 <em>ul</em> 设置了高度，但是这个高度值是小于浮动元素 <em>li</em> 的高度的，此时我们会发现仍然有贴靠的现象。</p><p><br></p><p>因此，<strong>如果一个元素要浮动，那么它的祖先元素一定要有高度。有高度的盒子，才能关住浮动</strong>。</p><p><br></p><p>只要浮动在一个有高度的盒子中，那么这个浮动就不会影响后面的浮动元素。所以就是清除浮动带来的影响了。</p><ol start=\"2\"><li><p><strong><em>clear</em> 属性</strong></p></li></ol><p>在实际开发中，由于盒子的高度能够被内容撑开，所以很多时候我们不会设置高度。</p><p><br></p><p>那么这个时候又该如何清除浮动呢？</p><p><br></p><p>在 <em>CSS</em> 中有一个叫做 <em>clear</em> 的属性，该属性定义了元素的哪边上不允许出现浮动元素。</p><p><br></p><p>在 <em>CSS1</em> 和 <em>CSS2</em> 中，这是通过自动为清除元素（即设置了 <em>clear</em> 属性的元素）增加上外边距实现的。</p><p><br></p><p>在 <em>CSS2.1</em> 中，会在元素上外边距之上增加清除空间，而外边距本身并不改变。不论哪一种改变，最终结果都一样，如果声明为左边或右边清除，会使元素的上外边框边界刚好在该边上浮动元素的下外边距边界之下。</p><p><br></p><p><em>clear</em> 属性的取值如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-18-061612.png\" alt=\"image-20210918141612213\" contenteditable=\"false\"><br></p><p><br></p><p>接下来我们来用 <em>clear</em> 属性清除浮动：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;ul&gt;\n  &lt;li&gt;导航1&lt;/li&gt;\n  &lt;li&gt;导航2&lt;/li&gt;\n  &lt;li&gt;导航3&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ul class=\"two\"&gt;\n  &lt;li&gt;游戏&lt;/li&gt;\n  &lt;li&gt;动漫&lt;/li&gt;\n  &lt;li&gt;音乐&lt;/li&gt;\n&lt;/ul&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.two{\n  clear: left;\n}\nli {\n  float: left;\n  width: 100px;\n  height: 20px;\n  background-color: pink;\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-18-063311.png\" alt=\"image-20210918143310665\" contenteditable=\"false\"><br></p><p><br></p><p>可以看到，浮动的副作用确实是清除了，但是这种方式有一个问题，那就是 <em>margin</em> 属性失效了。</p><p><br></p><p>例如我们在 <em>two</em> 的样式里面添加一个 <em>margin-top</em>，会发现该 <em>margin</em> 属性的设置并不起效果。</p><ol start=\"3\"><li><p><strong>隔墙法</strong></p></li></ol><p>隔墙法的核心思想就是在两个浮动的元素之间添加一个空的 <em>div</em> 作为一堵“墙”，从而让后面的浮动元素，不去追前面的浮动元素。</p><p><br></p><p>例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;ul&gt;\n  &lt;li&gt;导航1&lt;/li&gt;\n  &lt;li&gt;导航2&lt;/li&gt;\n  &lt;li&gt;导航3&lt;/li&gt;\n&lt;/ul&gt;\n&lt;div class=\"clearfix\"&gt;&lt;/div&gt;\n&lt;ul class=\"two\"&gt;\n  &lt;li&gt;游戏&lt;/li&gt;\n  &lt;li&gt;动漫&lt;/li&gt;\n  &lt;li&gt;音乐&lt;/li&gt;\n&lt;/ul&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.two {\n  margin-top: 10px;\n}\n\n.clearfix {\n  clear: both;\n}\n\nli {\n  float: left;\n  width: 100px;\n  height: 20px;\n  background-color: pink;\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-18-064154.png\" alt=\"image-20210918144154274\" contenteditable=\"false\"><br></p><p><br></p><p>通过上面的示例我们可以看到，<em>margin</em> 已经恢复正常。</p><ol start=\"4\"><li><p><strong>内墙法</strong></p></li></ol><p>通过隔墙法，后面又衍生出了内墙法。内墙法的出现，可以让浮动的元素也能撑开父元素的高。</p><p><br></p><p>正常情况下，没有高的父元素，里面的子元素一旦浮动，高度也就没有了，例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div&gt;\n  &lt;p&gt;&lt;/p&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div{\n  background-color: green;\n}\np{\n  width: 100px;\n  height: 100px;\n  background-color: red;\n}</code></pre></div><p>当前效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-18-065913.png\" alt=\"image-20210918145912989\" contenteditable=\"false\"><br></p><p><br></p><p>一旦我们设置 <em>p</em> 元素为浮动，由于脱离了标准流，所以父元素的高也就消失了。</p><p><br></p><p>此时就可以使用内墙法来给父元素撑起高，如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div&gt;\n  &lt;p&gt;&lt;/p&gt;\n  &lt;div class=\"clearfix\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div{\n  background-color: green;\n}\np{\n  width: 100px;\n  height: 100px;\n  background-color: red;\n  float: left;\n}\n.clearfix{\n  clear: both;\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-18-070839.png\" alt=\"image-20210918150838625\" contenteditable=\"false\"><br></p><p><br></p><p>下面是使用内墙法清除浮动的示例：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div&gt;\n  &lt;ul&gt;\n    &lt;li&gt;导航1&lt;/li&gt;\n    &lt;li&gt;导航2&lt;/li&gt;\n    &lt;li&gt;导航3&lt;/li&gt;\n  &lt;/ul&gt;\n  &lt;div class=\"clearfix\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;ul class=\"two\"&gt;\n  &lt;li&gt;游戏&lt;/li&gt;\n  &lt;li&gt;动漫&lt;/li&gt;\n  &lt;li&gt;音乐&lt;/li&gt;\n&lt;/ul&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.two {\n  margin-top: 10px;\n}\n\n.clearfix {\n  clear: both;\n}\n\nli {\n  float: left;\n  width: 100px;\n  height: 20px;\n  background-color: pink;\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-18-071359.png\" alt=\"image-20210918151358700\" contenteditable=\"false\"><br></p><p><br></p><p>在上面的代码中，我们使用内墙法清除了浮动，并且父元素的高度也被撑起来了，<em>margin</em> 也是正常的。</p><ol start=\"5\"><li><p><strong><em>overflow</em> 属性</strong></p></li></ol><p><em>overflow</em> 属性本来是用作处理溢出内容的显示方式的。</p><p><br></p><p>当给父元素添加 <em>overflow:hidden</em> 之后，父元素就会形成一个 <em>BFC</em>，一块独立的显示区域，不受外界影响，所以通过这种方式也能够去除浮动的副作用。</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;ul&gt;\n  &lt;li&gt;导航1&lt;/li&gt;\n  &lt;li&gt;导航2&lt;/li&gt;\n  &lt;li&gt;导航3&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ul class=\"two\"&gt;\n  &lt;li&gt;游戏&lt;/li&gt;\n  &lt;li&gt;动漫&lt;/li&gt;\n  &lt;li&gt;音乐&lt;/li&gt;\n&lt;/ul&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.two {\n  margin-top: 10px;\n}\n\nul {\n  overflow: hidden;\n}\n\nli {\n  float: left;\n  width: 100px;\n  height: 20px;\n  background-color: pink;\n}</code></pre></div><p>在上面的代码中，我们设置两个父元素 <em>ul</em> 都为 <em>overflow:hidden</em> 之后，两个父元素形成了 <em>BFC</em>，我们可以看到父元素的高度也被撑开了，<em>margin</em> 也是正常的。</p><ol start=\"6\"><li><p><strong>伪类清除法</strong></p></li></ol><p>最后要介绍的，是目前最流行的浮动清除方式，伪类清除法。</p><p><br></p><p>该方法的核心思想就是为父元素设置一个伪元素，其实就是无形的添加了一堵墙，然后在伪元素中设置一系列的属性。例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;ul class=\"one\"&gt;\n  &lt;li&gt;导航1&lt;/li&gt;\n  &lt;li&gt;导航2&lt;/li&gt;\n  &lt;li&gt;导航3&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ul class=\"two\"&gt;\n  &lt;li&gt;游戏&lt;/li&gt;\n  &lt;li&gt;动漫&lt;/li&gt;\n  &lt;li&gt;音乐&lt;/li&gt;\n&lt;/ul&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.two {\n  margin-top: 10px;\n}\n\n.one::after {\n  content: \"\";\n  display: block;\n  height: 0;\n  clear: both;\n  visibility: hidden;\n}\n\nli {\n  float: left;\n  width: 100px;\n  height: 20px;\n  background-color: pink;\n}</code></pre></div><p>在上面的代码中，我们为第一个 <em>ul</em> 设置了 <em>after</em> 伪元素，并在伪元素中设置了诸如 <em>clear:both、visibility: hidden</em> 等一系列属性，这实际上就等同于在两个 <em>ul</em> 之间添加了一堵无形的墙。</p><h3>浮动的现状</h3><p>上面介绍了很多清除浮动的方法，一会儿外墙法、一会儿内墙法、一会儿 <em>overflow</em>，这些其实都是时代的眼泪。</p><p><br></p><p>目前来讲，除非要考虑古老的 <em>IE6/IE7</em>，否则布局压根儿就不会考虑浮动，有更好的弹性盒模型和网格布局供我们使用。</p><p><br></p><p>浮动目前仅仅也就在要制作文字环绕效果时，能发挥一席之地的作用。</p><p><br></p><p>然而，文字环绕这种 <em>90</em> 年代看着还不错的设计，现在又有几个设计师会这样设计网页呢？</p><h2>真题解答</h2><ul><li><p>清除浮动的方法</p></li></ul><blockquote><p>参考答案：</p><ul><li><p><em>clear</em> 清除浮动（添加空 <em>div</em> 法）在浮动元素下方添加空 <em>div</em>，并给该元素写 <em>css</em> 样式 <em>{clear:both;height:0;overflow:hidden;}</em></p></li><li><p>给浮动元素父级设置高度</p></li><li><p>父级同时浮动（需要给父级同级元素添加浮动）</p></li><li><p>父级设置成 <em>inline-block</em>，其 <em>margin: 0 auto</em> 居中方式失效</p></li><li><p>给父级添加 <em>overflow:hidden</em> 清除浮动方法</p></li><li><p>万能清除法 <em>after</em> 伪类清浮动（现在主流方法，推荐使用）</p></li></ul></blockquote><ul><li><p>以下选项能够清除浮动的是（ B ）</p></li></ul><blockquote><p>A. 空 <em>div</em></p><p><br></p><p>B. <em>hover</em> 伪选择器</p><p><br></p><p>C. <em>clear</em> 属性</p><p><br></p><p>D. <em>overflow</em> 属性</p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666075228016",
  "typeId": {
    "$oid": "634d7fc47797638ec96fe2ee"
  }
},
{
  "_id": {
    "$oid": "634e4ab32fac4881713db2c0"
  },
  "interviewTitle": "position有哪些值，各自的用法如何？",
  "interviewContent": "<h1>定位总结</h1><h2>经典真题</h2><ul><li><p>介绍下 <em>positon</em> 属性</p></li><li><p><em>position</em> 有哪些值，各自的用法如何？</p></li><li><p>相对定位、绝对定位、固定定位的区别</p></li></ul><h2><em>CSS</em> 中的定位</h2><p>经常有同学混淆定位与布局，两者傻傻分不清。</p><p><br></p><p>布局是针对整个页面来讲的，你采用什么布局，两栏布局、三栏布局，目标是整个页面。</p><p><br></p><p>而定位是针对某一个元素来讲的，把这个元素定位到什么位置。</p><p><br></p><p>目前在 <em>CSS</em> 中，有 <em>5</em> 种定位方案，分别是：</p><ul><li><p><em>static</em> 静态定位</p></li><li><p><em>relative</em> 相对定位</p></li><li><p><em>absolute</em> 绝对定位</p></li><li><p><em>fixed</em> 固定定位</p></li><li><p><em>sticky</em> 粘性定位</p></li></ul><p>下面我们依次来介绍这几种定位。</p><h3><em>static</em> 静态定位</h3><p>所谓静态定位，就是我们的标准流。</p><p><br></p><p>在标准流里面，块级元素独占一行，内嵌元素共享一行。静态定位是 <em>HTML</em> 元素的默认值，静态定位的元素不会受到 <em>top，bottom，left，right</em> 的影响。</p><h3><em>relative</em> 相对定位</h3><p>所谓相对定位，就是相对自己原来的位置进行定位。相对定位的最大特点就是不脱离标准流，相对于自己原来的位置上进行一定的偏移。</p><p><br></p><p>来看一个示例：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"one\"&gt;one&lt;/div&gt;\n&lt;div class=\"two\"&gt;two&lt;/div&gt;\n&lt;div class=\"three\"&gt;three&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">*{\n  margin: 0;padding: 0;\n}\ndiv{\n  width: 100px;\n  height: 100px;\n  outline: 1px solid;\n  line-height: 100px;\n  text-align: center;\n}\n.two{\n  position: relative;\n  left: 50px;\n  top: 50px;\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-022649.png\" alt=\"image-20210916102648561\" contenteditable=\"false\"><br></p><p><br></p><p>可以看到，我们对 <em>two</em> 这个盒子设置了 <em>left</em> 值为 <em>50px</em>，<em>top</em> 值为 <em>50px</em>，而由于是相对这个位置进行偏移，所以 <em>two</em> 这个盒子向右下进行了移动。</p><p><br></p><p>使用相对定位的作用主要有两个：</p><ul><li><p>微调元素</p></li><li><p>做绝对定位的参考，子绝父相</p></li></ul><h3><em>absolute</em> 绝对定位</h3><p>所谓绝对定位，就是相对于离自己最近的，并且定了位的元素进行偏移。使用了绝对定位后的盒子，会脱离标准流，设置的 <em>margin</em> 也会失效。</p><p><br></p><p>下面是一个绝对定位的示例：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"one\"&gt;one&lt;/div&gt;\n&lt;div class=\"two\"&gt;two&lt;/div&gt;\n&lt;div class=\"three\"&gt;three&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">*{\n  margin: 0;padding: 0;\n}\ndiv{\n  width: 100px;\n  height: 100px;\n  outline: 1px solid;\n  line-height: 100px;\n  text-align: center;\n}\n.two{\n  position: absolute;\n  left: 50px;\n  top: 50px;\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-022924.png\" alt=\"image-20210916102923743\" contenteditable=\"false\"><br></p><p><br></p><p>在浏览器中可以看到，第 <em>3</em> 个 <em>div</em> 往上面移动了，从而证明了绝对定位是脱离标准流的。</p><p><br></p><p>绝对定位后的盒子，其 <em>display</em> 属性会变为 <em>block</em>，例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;a href=\"#\"&gt;百度一下&lt;/a&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">*{\n  margin: 0;padding: 0;\n}\na{\n  outline: 1px solid;\n  width: 100px;\n  height: 100px;\n  position: absolute;\n  top: 50px;\n  left: 50px;\n}</code></pre></div><p>在浏览器中的浏览效果如下：原本不能设置宽高的行内元素，在进行了绝对定位以后，<em>display</em> 属性变为了 <em>block</em>，所以可以设置宽高了。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-023159.png\" alt=\"image-20210916103159181\" contenteditable=\"false\"><br></p><p><br></p><p>这里要重点强调一下绝对定位的参考点问题。默认情况下，绝对定位的参考点，如果用 <em>top</em> 来进行描述，那么定位参考点就是页面的左上角，而不是浏览器的左上角，如下图：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-023254.png\" alt=\"image-20210916103254157\" contenteditable=\"false\"><br></p><p><br></p><p>如果是使用 <em>bottom</em> 来进行描述，那么就是浏览器首屏窗口尺寸，对应的页面左下角，如下图：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-023329.png\" alt=\"image-20210916103329049\" contenteditable=\"false\"><br></p><p><br></p><p>下面是一道爱立信 <em>2014</em> 年的校园春招题目，该题目就是考察关于绝对定位默认参考点的相关知识，如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-023403.png\" alt=\"image-20210916103403155\" contenteditable=\"false\"><br></p><p><br></p><p>该题目的答案如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-023443.png\" alt=\"image-20210916103442461\" contenteditable=\"false\"><br></p><p><br></p><p>上面介绍的是绝对定位里参考点的默认情况，但是这种情况一般使用得非常的少。更多的则是使用接下来我们将要介绍的参照标准。</p><p><br></p><p>前面我们在介绍相对定位的时候，有提到子绝父相这个名字。事实上，当我们对一个元素设置绝对定位的时候，往往会将它的父级元素设置为相对定位。</p><p><br></p><p>这样的好处在于该元素的父级元素没有脱离标准流，该元素将会以这个相对定位了的父元素作为参考点，在父元素的范围内进行移动，方便我们对元素的位置进行掌控。如下图：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-023532.png\" alt=\"image-20210916103531326\" contenteditable=\"false\"><br></p><p><br></p><p>在该图中，容器盒子设置为相对定位，红色盒子为绝对定位。红色盒子将无视父元素的 <em>padding</em> 区域，以父元素的 <em>border</em> <strong>内侧</strong>作为自己定位的参考点。</p><p><br></p><p>需要大家记住的是当父级元素出现有定位时，绝对定位的参考点永远都是<strong>离自己最近的，并且定了位的祖先元素的左上角</strong>，下面我们来举例子进行说明，如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"one\"&gt;\n  &lt;div class=\"two\"&gt;\n    &lt;div class=\"three\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">*{\n  margin: 0;padding: 0;\n}\n.one{\n  width: 200px;\n  height: 200px;\n  outline: 1px solid;\n  position: absolute;\n  top: 100px;\n  left: 100px;\n}\n.two{\n  width: 100px;\n  height: 100px;\n  outline: 1px solid red;\n  position: absolute;\n  top: 50px;\n  left: 50px;\n}\n.three{\n  width: 50px;\n  height: 50px;\n  background-color: pink;\n  position: absolute;\n  top: 0;\n  left: 0;\n}</code></pre></div><p>在浏览器中的浏览效果如下：这里 <em>three</em> 盒子就是以 <em>two</em> 盒子的左上角作为的参考点</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-023731.png\" alt=\"image-20210916103730739\" contenteditable=\"false\"><br></p><p><br></p><p>如果我们对代码稍作修改，取消 <em>two</em> 盒子的定位，那么 <em>three</em> 盒子就会以 <em>one</em> 盒子的左上角来作为参考点，如下：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.two{\n  width: 100px;\n  height: 100px;\n  outline: 1px solid red;\n  margin: 50px 0 0 50px; /* 使用margin来让该盒子进行一些偏离 */      \n}</code></pre></div><p>在浏览器中的浏览效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-023917.png\" alt=\"image-20210916103916507\" contenteditable=\"false\"><br></p><h3><em>fixed</em> 固定定位</h3><p>所谓固定定位，可以看作是一种特殊的绝对定位，所以自然而然固定定位也是会脱离标准流的。</p><p><br></p><p>固定定位的特点是相对于浏览器窗口进行定位的。</p><p><br></p><p>换句话说，对一个盒子进行固定定位以后，无论页面如何滚动，这个盒子的显示位置都是不会变化的。</p><p><br></p><p>固定定位在 <em>PC</em> 端中经常用于显示在页面中位置固定不变的页面 <em>header</em>，以及移动端中位置固定不变的 <em>header</em> 和 <em>footer</em>。</p><h3><em>sticky</em> 粘性定位</h3><p>在 <em>CSS3</em> 中，新增了一种定位方式：<em>sticky</em>。</p><p><br></p><p><em>sticky</em>，中文的字面意思是“粘，粘贴”的意思，所以这种定位方式可以称之为粘性定位。</p><p><br></p><p>目前大部分浏览器都已经支持了这种定位方式。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-024626.png\" alt=\"image-20210916104626067\" contenteditable=\"false\"><br></p><p><br></p><p>要设置一个元素的定位方式为粘性定位，首先需要将 <em>position</em> 属性设置为 <em>sticky</em>。</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">position: sticky;   /* 设置定位方式为粘性定位 */</code></pre></div><p>接下来有如下几个需要注意的点：</p><ul><li><p>父元素的 <em>overflow</em> 必须是 <em>visible</em>，不能是 <em>hidden</em> 或者 <em>auto</em>，因为父节点定位设置为 <em>overflow:hidden</em> 则父容器无法进行滚动。</p></li><li><p>父元素的高度不能低于 <em>sticky</em> 元素的高度 。</p></li><li><p>如果父元素没有设置定位（<em>position:relative | absolute | fixed</em>），则相对于 <em>viewprot</em> 进行定位，否则以定位的父元素为参考点。</p></li><li><p>设置阀值：需要指定 <em>top</em>、<em>right</em>、<em>bottom</em> 或 <em>left</em> 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。并且 <em>top</em> 和 <em>bottom</em> 同时设置时，<em>top</em> 生效的优先级高；<em>left</em> 和 <em>right</em> 同时设置时，<em>left</em> 的优先级高。</p></li></ul><p>下面是一个粘性定位的示例：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;h1&gt;我是标题，题题，题，...&lt;/h1&gt;\n&lt;nav&gt;\n  &lt;h3&gt;导航A&lt;/h3&gt;\n  &lt;h3&gt;导航B&lt;/h3&gt;\n  &lt;h3&gt;导航C&lt;/h3&gt;\n&lt;/nav&gt;\n&lt;article&gt;\n  &lt;p&gt;今晚的爱奇艺尖叫之夜中，唐嫣上台领取年度戏剧女艺人奖，主持人朱丹希望她分享婚后甜蜜，可唐嫣已经下台，引发网友质疑场面尴尬。刚刚，朱丹发文回应，表示唐嫣没有不礼貌，自己也没有尴尬。随后，唐嫣也评论：“美丽的误会”\n  &lt;/p&gt;\n  &lt;p&gt;韩寒：我的生活有两个节点，一个是出书，另一个就是写博客。出书让我有了收入，博客让我有了跟读者的连接。我从小就被贴过很多标签，每多一个标签就更接近真实的我。微博也一样，每一次更新都跟随着时代的风向，与时代同行。&lt;/p&gt;\n  &lt;p&gt;《游戏人生》作者榎宫祐 表示，近日有朋友想成为漫画家，过来找他商量。&lt;br&gt;\n    他：“漫画家相当于无职啊，月收入又低，如果请助手花费更大。”（为了让朋友知道现实，又不否定梦想的小心翼翼的说法）&lt;br&gt;\n    朋友：“可是我有一栋公寓用来收租唉......”&lt;br&gt;\n    他：“那你想怎么活就怎么活吧！” ​​​​&lt;/p&gt;\n  &lt;p&gt;【湖北一小学三年级才教数学，校长回应争议：实验班的成绩远高于对比班】湖北赤壁一小学施行三年级才上数学课的教学设置，引起关注。该校校长表示，数学是一个抽象思维的功课，6岁的小孩是形象思维发展的最佳期，应该把数学往后移，按照知识发展规律。从三年级开始学数学，用3年时间学完原本5年的课程是可行的，并且经过3年的实验，实验班的成绩都要远高于对比班。\n  &lt;/p&gt;\n  &lt;p&gt;刘国梁：暮然回首这一路走来⋯⋯感恩国家队30年的培养，把我从一个13岁的孩子，培养成大满贯、总教练、再到乒协主席🏓️[心]感谢这么多年跟我一起努力征战国际赛场的教练员和运动员，是你们辛勤的付出取得的荣耀造就了今天的自己[抱抱][心]感动的是亿万国人和球迷粉丝，这么多年不离不弃的支持，才有了今日国乒的新辉煌。赢不狂.输不慌.陪国乒.战东京！\n  &lt;/p&gt;\n&lt;/article&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">body {\n  height: 5000px;\n  /* 为了让页面可以滑动 */\n}\n\nnav {\n  display: flex;\n  justify-content: start;\n  width: 100%;\n  position: sticky;\n  /* 设置定位方式为粘性定位 */\n  top: 20px;\n  /* 设置阀值，滚动到 top 值为 20px 的时候不再能够滚动*/\n}\n\nnav h3 {\n  outline: 1px solid #fff;\n  background-color: #333;\n  color: #fff;\n  text-align: center;\n  padding: 10px;\n}</code></pre></div><h2>真题解答</h2><ul><li><p><em>position</em> 有哪些值，各自的用法如何？</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>目前在 <em>CSS</em> 中，有 <em>5</em> 种定位方案，分别是：</p><ol><li><p><em>static</em>：该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。</p></li><li><p><em>relative</em>：相对定位的元素是在文档中的正常位置偏移给定的值，但是不影响其他元素的偏移。</p></li><li><p><em>absolute</em>：相对定位的元素并未脱离文档流，而绝对定位的元素则脱离了文档流。在布置文档流中其它元素时，绝对定位元素不占据空间。绝对定位元素相对于最近的非 <em>static</em> 祖先元素定位。</p></li><li><p><em>fixed</em>：固定定位与绝对定位相似，但元素的包含块为 <em>viewport</em> 视口。该定位方式常用于创建在滚动屏幕时仍固定在相同位置的元素。</p></li><li><p><em>sticky</em>：粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。</p></li></ol></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666075315765",
  "typeId": {
    "$oid": "634d7fc47797638ec96fe2ee"
  }
},
{
  "_id": {
    "$oid": "634e4b092fac4881713db2cb"
  },
  "interviewTitle": "介绍下 BFC 及其应用",
  "interviewContent": "<h1><em>BFC</em></h1><h2>经典真题</h2><ul><li><p>介绍下 <em>BFC</em> 及其应用</p></li><li><p>介绍下 <em>BFC、IFC、GFC</em> 和 <em>FFC</em></p></li></ul><h2>搞懂各种 <em>FC</em></h2><p>一看到 <em>BFC、IFC、GFC</em> 和 <em>FFC</em>，大家可能会想到 <em>KFC</em>。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-13-054223.png\" alt=\"image-20210913134223247\" contenteditable=\"false\"><br></p><p><br></p><p>然而这里所说的 <em>xFC</em> 和 <em>KFC</em> 没有任何关系。</p><p><br></p><p>那么这些 <em>FC</em> 究竟是啥呢？</p><p><br></p><p>不着急，我们先搞懂一个，后面的陆陆续续也就融会贯通了。</p><p><br></p><p>我们首先就来看这个 <em>BFC</em>，英语全称 <em>Block formatting contexts</em>，翻译成中文就是“块级格式化上下文”。</p><p><br></p><p>简单来说，就是页面中的一块渲染区域，并且有一套属于自己的渲染规则，它决定了元素如何对齐内容进行布局，以及与其他元素的关系和相互作用。 当涉及到可视化布局的时候，<em>BFC</em> 提供了一个环境，<em>HTML</em> 元素在这个环境中按照一定规则进行布局。</p><p><br></p><p>再简短一点，那就是：<strong><em>BFC</em> 是一个独立的布局环境，<em>BFC</em> 内部的元素布局与外部互不影响</strong></p><p><br></p><p>这就好比你在你自己家里面，你想怎么摆放你的家具都可以，你家的家具布局并不会影响邻居家的家具布局。</p><p><br></p><p>当然，虽然说 <em>BFC</em> 是一个独立的布局环境，里外不影响，但也不是意味着布局没有章法，基本的规矩还是要有的。</p><p><br></p><p>例如，<em>BFC</em> 的布局规则有如下几条：</p><ol><li><p>内部的 <em>Box</em> 会在垂直方向一个接着一个地放置。</p></li><li><p><em>Box</em> 垂直方向上的距离由 <em>margin</em> 决定。属于同一个 <em>BFC</em> 的两个相邻的 <em>Box</em> 的 <em>margin</em> 会发生重叠。</p></li><li><p>每个盒子的左外边框紧挨着包含块的左边框，即使浮动元素也是如此。</p></li><li><p><em>BFC</em> 的区域不会与浮动 <em>Box</em> 重叠。</p></li><li><p><em>BFC</em> 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。</p></li><li><p>计算 <em>BFC</em> 的高度时，浮动子元素也参与计算。</p></li></ol><p>诶？？</p><p><br></p><p>这好像在我们的 <em>body</em> 元素里面，盒子天然就是这样的布局规则呀？</p><p><br></p><p>没错，实际上在一个标准流中 <em>body</em> 元素就是一个天然的 <em>BFC</em>。</p><p><br></p><p>那么如果其他区域，我想单独设置成一个 <em>BFC</em>，该怎么办呢？这里记录了一些常见的方式：</p><table><thead><tr><th><p>元素或属性</p></th><th><p>属性值</p></th></tr></thead><tbody><tr><td><p>根元素</p></td><td><p><br></p></td></tr><tr><td><p>float</p></td><td><p>left、right</p></td></tr><tr><td><p>postion</p></td><td><p>absolute、fixed</p></td></tr><tr><td><p>overflow</p></td><td><p>auto、scroll、hidden</p></td></tr><tr><td><p>display</p></td><td><p>inline-block、table-cell</p></td></tr></tbody></table><blockquote><p>上面只记录了一些常见的方式，完整的 <em>BFC</em> 触发方式可以参阅：<em>https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</em></p></blockquote><p>那么块级格式化上下文有啥具体的用处呢？我们来看几个场景</p><ol><li><p>解决浮动元素令父元素高度坍塌的问题</p></li></ol><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"father\"&gt;\n   &lt;div class=\"son\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.father{\n  border: 5px solid;\n}\n.son{\n  width: 100px;\n  height: 100px;\n  background-color: blue;\n  float: left;\n}</code></pre></div><p>在上面的代码中，父元素的高度是靠子元素撑起来的，但是一旦我们给子元素设置了浮动，那么父元素的高度就塌陷了。如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-13-060809.png\" alt=\"image-20210913140809007\" contenteditable=\"false\"><br></p><p><br></p><p>此时我们就可以将父元素设置成一个 <em>BFC</em>，例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.father{\n  border: 5px solid;\n  overflow: hidden; \n  /* 将父元素设置为一个 BFC */\n}\n.son{\n  width: 100px;\n  height: 100px;\n  background-color: blue;\n  float: left;\n}</code></pre></div><p>效果：可以看到由于父元素变成 <em>BFC</em>，高度并没有产生塌陷了，其原因是在计算 <em>BFC</em> 的高度时，浮动子元素也参与计算</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-13-060948.png\" alt=\"image-20210913140948390\" contenteditable=\"false\"><br></p><ol start=\"2\"><li><p>非浮动元素被浮动元素覆盖</p></li></ol><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"box1\"&gt;&lt;/div&gt;\n&lt;div class=\"box2\"&gt;&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.box1{\n  width: 100px;\n  height: 50px;\n  background-color: red;\n  float: left;\n}\n.box2{\n  width: 50px;\n  height: 50px;\n  background-color: blue;\n}</code></pre></div><p>在上面的代码中，由于 <em>box1</em> 设置了浮动效果，所以会脱离标准流，自然而然 <em>box2</em> 会往上面跑，结果就被高度和自己一样的 <em>box1</em> 给挡住了。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-13-061556.png\" alt=\"image-20210913141555490\" contenteditable=\"false\"><br></p><p><br></p><p>接下来我们设置 <em>box2</em> 为 <em>BFC</em>，如下：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.box1{\n  width: 100px;\n  height: 50px;\n  background-color: red;\n  float: left;\n}\n.box2{\n  width: 50px;\n  height: 50px;\n  background-color: blue;\n  overflow: hidden;\n}</code></pre></div><p>效果：由于 <em>BFC</em> 的区域不会与浮动 <em>box</em> 重叠，所以即使 <em>box1</em> 因为浮动脱离了标准流，<em>box2</em> 也不会被 <em>box1</em> 遮挡</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-13-061805.png\" alt=\"image-20210913141805543\" contenteditable=\"false\"><br></p><p><br></p><p>基于此特点，我们就可以制作两栏自适应布局，方法就是给固定栏设置固定宽度，给不固定栏开启 <em>BFC</em>。</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"left\"&gt;导航栏&lt;/div&gt;\n&lt;div class=\"right\"&gt;这是右侧&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">*{\n  margin: 0;\n  padding: 0;\n}\n.left {\n  width: 200px;\n  height: 100vh;\n  background-color: skyblue;\n  float: left;\n}\n\n.right {\n  width: calc(100% - 200px); \n  height: 100vh;\n  background-color: yellowgreen;\n}</code></pre></div><p>效果：在上面的代码中，我们要设置两栏布局，左边栏宽度固定，右边栏自适应。结果我们发现右侧出现了空白</p><p><br></p><p>究其原因就是右侧区域与浮动盒子重叠了</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-13-063034.png\" alt=\"image-20210913143033581\" contenteditable=\"false\"><br></p><p><br></p><p>修改 <em>.right</em> 部分的代码，添加 <em>overflow:hidden</em> 使其成为一个 <em>BFC</em>：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.right {\n  width: calc(100% - 200px); \n  height: 100vh;\n  background-color: yellowgreen;\n  overflow: hidden;\n}</code></pre></div><p>效果：因为 <em>BFC</em> 的区域不会与浮动 <em>Box</em> 重叠，所以右侧空白没有了</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-13-063330.png\" alt=\"image-20210913143330616\" contenteditable=\"false\"><br></p><ol start=\"3\"><li><p>外边距垂直方向重合的问题</p></li></ol><p><em>BFC</em> 还能够解决 <em>margin</em> 折叠的问题，例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"box1\"&gt;&lt;/div&gt;\n&lt;div class=\"box2\"&gt;&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">* {\n  margin: 0;\n  padding: 0;\n}\n\n.box1{\n  width: 100px;\n  height: 100px;\n  background-color: red;\n  margin-bottom: 10px;\n}\n.box2{\n  width: 100px;\n  height: 100px;\n  background-color: blue;\n  margin-top: 10px;\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-13-063850.png\" alt=\"image-20210913143849932\" contenteditable=\"false\"><br></p><p><br></p><p>此时我们可以在 box2 外部再包含一个 div，并且将这个 div 设置为 <em>BFC</em>，如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"box1\"&gt;&lt;/div&gt;\n&lt;div class=\"container\"&gt;\n  &lt;div class=\"box2\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">* {\n  margin: 0;\n  padding: 0;\n}\n\n.box1{\n  width: 100px;\n  height: 100px;\n  background-color: red;\n  margin-bottom: 10px;\n}\n.box2{\n  width: 100px;\n  height: 100px;\n  background-color: blue;\n  margin-top: 10px;\n}\n.container{\n  overflow: hidden;\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-13-064106.png\" alt=\"image-20210913144106258\" contenteditable=\"false\"><br></p><p><br></p><p><em>OK</em>，到这里你应该明白什么是 <em>BFC</em> 以及 <em>BFC</em> 的触发规则和其使用场景了。</p><p><br></p><p>明白了 <em>BFC</em>，那么其他的 <em>IFC、GFC</em> 和 <em>FFC</em> 也就大同小异了。</p><ul><li><p><em>IFC</em>（<em>Inline formatting context</em>）：翻译成中文就是“行内格式化上下文”，也就是一块区域以行内元素的形式来格式化</p></li><li><p><em>GFC</em>（<em>GrideLayout formatting contexts</em>）：翻译成中文就是“网格布局格式化上下文”，将一块区域以 <em>grid</em> 网格的形式来格式化</p></li><li><p><em>FFC</em>（<em>Flex formatting contexts</em>）：翻译成中文就是“弹性格式化上下文“，将一块区域以弹性盒的形式来格式化</p></li></ul><blockquote><p>更多关于格式化上下文的内容，可以参阅 <em>MDN</em>：</p><p><br></p><p><em>BFC</em>：<em>https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</em></p><p><br></p><p><em>IFC</em>：<em>https://developer.mozilla.org/zh-CN/docs/Web/CSS/Inline_formatting_context</em></p></blockquote><h2>真题解答</h2><ul><li><p>介绍下 <em>BFC</em> 及其应用</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>所谓 <em>BFC</em>，指的是一个独立的布局环境，<em>BFC</em> 内部的元素布局与外部互不影响。</p><p><br></p><p>触发 <em>BFC</em> 的方式有很多，常见的有：</p><ul><li><p>设置浮动</p></li><li><p><em>overflow</em> 设置为 <em>auto、scroll、hidden</em></p></li><li><p><em>positon</em> 设置为 <em>absolute、fixed</em></p></li></ul><p>常见的 <em>BFC</em> 应用有：</p><ul><li><p>解决浮动元素令父元素高度坍塌的问题</p></li><li><p>解决非浮动元素被浮动元素覆盖问题</p></li><li><p>解决外边距垂直方向重合的问题</p></li></ul></blockquote><ul><li><p>介绍下 <em>BFC、IFC、GFC</em> 和 <em>FFC</em></p></li></ul><blockquote><p>参考答案：</p><ul><li><p><em>BFC</em>：块级格式上下文，指的是一个独立的布局环境，<em>BFC</em> 内部的元素布局与外部互不影响。</p></li><li><p><em>IFC</em>：行内格式化上下文，将一块区域以行内元素的形式来格式化。</p></li><li><p><em>GFC</em>：网格布局格式化上下文，将一块区域以 <em>grid</em> 网格的形式来格式化</p></li><li><p><em>FFC</em>：弹性格式化上下文，将一块区域以弹性盒的形式来格式化</p></li></ul></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666075401295",
  "typeId": {
    "$oid": "634d7fc47797638ec96fe2ee"
  }
},
{
  "_id": {
    "$oid": "634e4bcc2fac4881713db2e0"
  },
  "interviewTitle": "请简述 CSS 中属性的计算过程是怎样的",
  "interviewContent": "<h1>CSS 属性计算过程</h1><p>你是否了解 CSS 的属性计算过程呢？</p><p><br></p><p>有的同学可能会讲，CSS属性我倒是知道，例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">p{\n  color : red;\n}</code></pre></div><p>上面的 CSS 代码中，p 是元素选择器，color 就是其中的一个 CSS 属性。</p><p><br></p><p>但是要说 CSS 属性的计算过程，还真的不是很清楚。</p><p><br></p><p>没关系，通过此篇文章，能够让你彻底明白什么是 CSS 属性的计算流程。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-060434.png\" alt=\"image-20220813140434032\" contenteditable=\"false\"><br></p><p><br></p><p>首先，不知道你有没有考虑过这样的一个问题，假设在 HTML 中有这么一段代码：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;body&gt;\n  &lt;h1&gt;这是一个h1标题&lt;/h1&gt;\n&lt;/body&gt;</code></pre></div><p>上面的代码也非常简单，就是在 body 中有一个 h1 标题而已，该 h1 标题呈现出来的外观是如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-060724.png\" alt=\"image-20220813140724136\" contenteditable=\"false\"><br></p><p><br></p><p>目前我们没有设置该 h1 的任何样式，但是却能看到该 h1 有一定的默认样式，例如有默认的字体大小、默认的颜色。</p><p><br></p><p>那么问题来了，我们这个 h1 元素上面除了有默认字体大小、默认颜色等属性以外，究竟还有哪些属性呢？</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-15-014216.png\" alt=\"image-20220815094215982\" contenteditable=\"false\"><br></p><p><br></p><p>答案是**该元素上面会有 CSS 所有的属性。**你可以打开浏览器的开发者面板，选择【元素】，切换到【计算样式】，之后勾选【全部显示】，此时你就能看到在此 h1 上面所有 CSS 属性对应的值。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-061516.png\" alt=\"image-20220813141516153\" contenteditable=\"false\"><br></p><p><br></p><p>换句话说，<strong>我们所书写的任何一个 HTML 元素，实际上都有完整的一整套 CSS 样式</strong>。这一点往往是让初学者比较意外的，因为我们平时在书写 CSS 样式时，往往只会书写必要的部分，例如前面的：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">p{\n  color : red;\n}</code></pre></div><p>这往往会给我们造成一种错觉，认为该 p 元素上面就只有 color 属性。而真实的情况确是，任何一个 HTML 元素，都有一套完整的 CSS 样式，只不过你没有书写的样式，<strong>大概率可能</strong>会使用其默认值。例如上图中 h1 一个样式都没有设置，全部都用的默认值。</p><p><br></p><p>但是注意，我这里强调的是“大概率可能”，难道还有我们“没有设置值，但是不使用默认值”的情况么？</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-15-014459.png\" alt=\"image-20220815094458940\" contenteditable=\"false\"><br></p><p><br></p><p>嗯，确实有的，所以我才强调你要了解“CSS 属性的计算过程”。</p><p><br></p><p>总的来讲，属性值的计算过程，分为如下这么 <em>4</em> 个步骤：</p><ul><li><p>确定声明值</p></li><li><p>层叠冲突</p></li><li><p>使用继承</p></li><li><p>使用默认值</p></li></ul><h2>确定声明值</h2><p>首先第一步，是确定声明值。所谓声明值就是作者自己所书写的 CSS 样式，例如前面的：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">p{\n  color : red;\n}</code></pre></div><p>这里我们声明了 p 元素为红色，那么就会应用此属性设置。</p><p><br></p><p>当然，除了作者样式表，一般浏览器还会存在“用户代理样式表”，简单来讲就是浏览器内置了一套样式表。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-063500.png\" alt=\"image-20220813143500066\" contenteditable=\"false\"><br></p><p><br></p><p>在上面的示例中，作者样式表中设置了 color 属性，而用户代理样式表（浏览器提供的样式表）中设置了诸如 display、margin-block-start、margin-block-end、margin-inline-start、margin-inline-end 等属性对应的值。</p><p><br></p><p>这些值目前来讲也没有什么冲突，因此最终就会应用这些属性值。</p><h2>层叠冲突</h2><p>在确定声明值时，可能出现一种情况，那就是声明的样式规则发生了冲突。</p><p><br></p><p>此时会进入解决层叠冲突的流程。而这一步又可以细分为下面这三个步骤：</p><ul><li><p>比较源的重要性</p></li><li><p>比较优先级</p></li><li><p>比较次序</p></li></ul><p>来来来，我们一步一步来看。</p><h3>比较源的重要性</h3><p>当不同的 CSS 样式来源拥有相同的声明时，此时就会根据样式表来源的重要性来确定应用哪一条样式规则。</p><p><br></p><p>那么问题来了，咱们的样式表的源究竟有几种呢？</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-23-100047.png\" alt=\"image-20220823180047075\" contenteditable=\"false\"><br></p><p><br></p><p>整体来讲有三种来源：</p><ul><li><p>浏览器会有一个基本的样式表来给任何网页设置默认样式。这些样式统称<strong>用户代理样式</strong>。</p></li><li><p>网页的作者可以定义文档的样式，这是最常见的样式表，称之为<strong>页面作者样式</strong>。</p></li><li><p>浏览器的用户，可以使用自定义样式表定制使用体验，称之为<strong>用户样式</strong>。</p></li></ul><p>对应的重要性顺序依次为：页面作者样式 &gt; 用户样式 &gt; 用户代理样式</p><p><br></p><p>更详细的来源重要性比较，可以参阅 <em>MDN</em>：<em>https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade</em></p><p><br></p><p>我们来看一个示例。</p><p><br></p><p>例如现在有<strong>页面作者样式表</strong>和<strong>用户代理样式表</strong>中存在属性的冲突，那么会以作者样式表优先。</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">p{\n  color : red;\n  display: inline-block;\n}</code></pre></div><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-064222.png\" alt=\"image-20220813144222152\" contenteditable=\"false\"><br></p><p><br></p><p>可以明显的看到，作者样式表和用户代理样式表中同时存在的 display 属性的设置，最终作者样式表干掉了用户代理样式表中冲突的属性。这就是第一步，根据不同源的重要性来决定应用哪一个源的样式。</p><h3>比较优先级</h3><p>那么接下来，如果是在在同一个源中有样式声明冲突怎么办呢？此时就会进行样式声明的优先级比较。</p><p><br></p><p>例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"test\"&gt;\n  &lt;h1&gt;test&lt;/h1&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.test h1{\n  font-size: 50px;\n}\n\nh1 {\n  font-size: 20px;\n}</code></pre></div><p>在上面的代码中，同属于<strong>页面作者样式</strong>，源的重要性是相同的，此时会以选择器的权重来比较重要性。</p><p><br></p><p>很明显，上面的选择器的权重要大于下面的选择器，因此最终标题呈现为 <em>50px</em>。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-071546.png\" alt=\"image-20210916151546500\" contenteditable=\"false\"><br></p><p><br></p><p>可以看到，落败的作者样式在 <em>Elements&gt;Styles</em> 中会被划掉。</p><p><br></p><p>有关选择器权重的计算方式，不清楚的同学，可以进入此传送门：<em>https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity</em></p><h3>比较次序</h3><p>经历了上面两个步骤，大多数的样式声明能够被确定下来。但是还剩下最后一种情况，那就是样式声明既是同源，权重也相同。</p><p><br></p><p>此时就会进入第三个步骤，比较样式声明的次序。</p><p><br></p><p>举个例子：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">h1 {\n  font-size: 50px;\n}\n\nh1 {\n  font-size: 20px;\n}</code></pre></div><p>在上面的代码中，同样都是<strong>页面作者样式</strong>，<strong>选择器的权重也相同</strong>，此时位于下面的样式声明会层叠掉上面的那一条样式声明，最终会应用 <em>20px</em> 这一条属性值。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-23-103928.png\" alt=\"image-20220823183928330\" contenteditable=\"false\"><br></p><p><br></p><p>至此，样式声明中存在冲突的所有情况，就全部被解决了。</p><h2>使用继承</h2><p>层叠冲突这一步完成后，解决了相同元素被声明了多条样式规则究竟应用哪一条样式规则的问题。</p><p><br></p><p>那么如果没有声明的属性呢？此时就使用默认值么？</p><p><br></p><p><em>No、No、No</em>，别急，此时还有第三个步骤，那就是使用继承而来的值。</p><p><br></p><p>例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div&gt;\n  &lt;p&gt;Lorem ipsum dolor sit amet.&lt;/p&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div {\n  color: red;\n}</code></pre></div><p>在上面的代码中，我们针对 div 设置了 color 属性值为红色，而针对 p 元素我们没有声明任何的属性，但是由于 color 是可以继承的，因此 p 元素从最近的 div 身上继承到了 color 属性的值。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-065102.png\" alt=\"image-20220813145102293\" contenteditable=\"false\"><br></p><p><br></p><p>这里有两个点需要同学们注意一下。</p><p><br></p><p>首先第一个是我强调了是<strong>最近的</strong> div 元素，看下面的例子：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"test\"&gt;\n  &lt;div&gt;\n    &lt;p&gt;Lorem ipsum dolor sit amet.&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div {\n  color: red;\n}\n.test{\n  color: blue;\n}</code></pre></div><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-065653.png\" alt=\"image-20220813145652726\" contenteditable=\"false\"><br></p><p><br></p><p>因为这里并不涉及到选中 p 元素声明 color 值，而是从父元素上面继承到 color 对应的值，因此这里是<strong>谁近就听谁</strong>的，初学者往往会产生混淆，又去比较权重，但是这里根本不会涉及到权重比较，因为压根儿就没有选中到 p 元素。</p><p><br></p><p>第二个就是哪些属性能够继承？</p><p><br></p><p>关于这一点的话，大家可以在 MDN 上面很轻松的查阅到。例如我们以 text-align 为例，如下图所示：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-070148.png\" alt=\"image-20220813150147885\" contenteditable=\"false\"><br></p><h2>使用默认值</h2><p>好了，目前走到这一步，如果属性值都还不能确定下来，那么就只能是使用默认值了。</p><p><br></p><p>如下图所示：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-070825.png\" alt=\"image-20220813150824752\" contenteditable=\"false\"><br></p><p><br></p><p>前面我们也说过，一个 HTML 元素要在浏览器中渲染出来，必须具备所有的 CSS 属性值，但是绝大部分我们是不会去设置的，用户代理样式表里面也不会去设置，也无法从继承拿到，因此最终都是用默认值。</p><p><br></p><p>好了，这就是关于 CSS 属性计算过程的所有知识了。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154655.png\" alt=\"image-20220814234654914\" contenteditable=\"false\"><br></p><h2>一道面试题</h2><p>好了，学习了今天的内容，让我来用一道面试题测试测试大家的理解程度。</p><p><br></p><p>下面的代码，最终渲染出来的效果，a 元素是什么颜色？p 元素又是什么颜色？</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div&gt;\n  &lt;a href=\"\"&gt;test&lt;/a&gt;\n  &lt;p&gt;test&lt;/p&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div {\n  color: red;\n}</code></pre></div><p>大家能说出为什么会呈现这样的结果么？</p><p><br></p><p>解答如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-071941.png\" alt=\"image-20220813151941113\" contenteditable=\"false\"><br></p><p><br></p><p>实际上原因很简单，因为 a 元素在用户代理样式表中已经设置了 color 属性对应的值，因此会应用此声明值。而在 p 元素中无论是作者样式表还是用户代理样式表，都没有对此属性进行声明，然而由于 color 属性是可以继承的，因此最终 p 元素的 color 属性值通过继承来自于父元素。</p><p><br></p><p>你答对了么？-）</p><div contenteditable=\"false\"><hr></div><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666075596460",
  "typeId": {
    "$oid": "634d7fc47797638ec96fe2ee"
  }
},
{
  "_id": {
    "$oid": "634e4c932fac4881713db2ea"
  },
  "interviewTitle": "请简述一下 CSS 中的层叠规则",
  "interviewContent": "<h1><em>CSS</em> 层叠继承规则总结</h1><h2>经典真题</h2><ul><li><p>请简述一下 <em>CSS</em> 中的层叠规则</p></li></ul><h2><em>CSS</em> 中的层叠继承规则</h2><p>在前面《<em>CSS</em>属性的计算过程》中，我们介绍了每一个元素都有都有所有的属性，每一个属性都会通过一系列的计算过程得到最终的值。</p><p><br></p><p>这里来回顾一下计算过程，大致有以下几个步骤：</p><ul><li><p>确定声明值</p></li><li><p>层叠冲突</p></li><li><p>使用继承</p></li><li><p>使用默认值</p></li></ul><p>其中的第二步和第三步层叠和继承会有一些需要注意的知识点，这里我们一起来看一下。</p><h2>层叠规则</h2><p><em>CSS</em> 是 <em>Cascading Style Sheets</em> 的缩写，这暗示层叠（<em>cascade</em>）的概念是很重要的。</p><p><br></p><p>在最基本的层面上，它表明 <em>CSS</em> 规则的顺序很重要，但它比那更复杂。</p><p><br></p><p>什么选择器在层叠中胜出取决于三个因素（这些都是按重量级顺序排列的，前面的的一种会否决后一种）：</p><ul><li><p>重要性（<em>Importance</em>）</p></li><li><p>专用性（<em>Specificity</em>）</p></li><li><p>源代码次序（<em>Source order</em>）</p></li></ul><h3>重要性</h3><p>在 <em>CSS</em> 中，有一个特别的语法可以让一条规则总是优先于其他规则： <em>!important</em> 。</p><p><br></p><p>知道 <em>!important</em> 存在是很有用的，这样当你在别人的代码中遇到它时，你就知道它是什么了。</p><p><br></p><p>但是！建议你千万不要使用它，除非你绝对必须使用它。您可能不得不使用它的一种情况是，当您在修改某个组件样式时，你不能编辑该组件核心的 <em>CSS</em> 模块，又或者你确实想要重写一种不能以其他方式覆盖的样式。</p><p><br></p><p>但是，如果你能避免的话，不要使用它。由于 <em>!important</em> 改变了层叠正常工作的方式，因此调试 <em>CSS</em> 问题，尤其是在大型样式表中，会变得非常困难。</p><h3>专用性</h3><p>专用性基本上是衡量选择器的具体程度的一种方法，主要是指它能匹配多少元素。</p><p><br></p><p>元素选择器具有很低的专用性。类选择器具有更高的专用性，所以将战胜元素选择器。<em>ID</em> 选择器有甚至更高的专用性, 所以将战胜类选择器，战胜 <em>ID</em> 选择器的方法则是 <em>style</em> 中的样式或者 <em>!important</em>。</p><p><br></p><p>一个选择器具有的专用性的量可以用四种不同的值（或组件）来衡量的，它们可以被认为是千位，百位，十位和个位，在四个列中的四个简单数字：</p><ul><li><p>千位：如果声明是在 <em>style</em> 属性中该列加 <em>1</em> 分（这样的声明没有选择器，所以它们的专用性总是 <em>1000</em>）否则为 <em>0</em>。</p></li><li><p>百位：在整个选择器中每包含一个 <em>ID</em> 选择器就在该列中加 <em>1</em> 分。</p></li><li><p>十位：在整个选择器中每包含一个类选择器、属性选择器、或者伪类就在该列中加 <em>1</em> 分。</p></li><li><p>个位：在整个选择器中每包含一个元素选择器或伪元素就在该列中加 <em>1</em> 分。</p></li></ul><blockquote><p>注：通用选择器（*）, 复合选择器（+、&gt;、~、空格）和否定伪类（:not）在专用性中无影响。</p></blockquote><p>举个例子：</p><table><thead><tr><th><p><strong>选择器</strong></p></th><th><p>千位</p></th><th><p>百位</p></th><th><p>十位</p></th><th><p>个位</p></th><th><p>合计值</p></th></tr></thead><tbody><tr><td><p>h1</p></td><td><p>0</p></td><td><p>0</p></td><td><p>0</p></td><td><p>1</p></td><td><p>0001</p></td></tr><tr><td><p>#indentifier</p></td><td><p>0</p></td><td><p>1</p></td><td><p>0</p></td><td><p>0</p></td><td><p>0100</p></td></tr><tr><td><p>h1 + p::first-letter</p></td><td><p>0</p></td><td><p>0</p></td><td><p>0</p></td><td><p>3</p></td><td><p>0003</p></td></tr><tr><td><p>li &gt; a[href*=” zh-CN”] &gt; .inline-warning</p></td><td><p>0</p></td><td><p>0</p></td><td><p>2</p></td><td><p>2</p></td><td><p>0022</p></td></tr><tr><td><p>没有选择器, 规则在一个元素的 <em>style</em> 属性里</p></td><td><p>1</p></td><td><p>0</p></td><td><p>0</p></td><td><p>0</p></td><td><p>1000</p></td></tr></tbody></table><h3>源代码次序</h3><p>如果多个相互竞争的选择器具有相同的重要性和专用性，那么第三个因素将帮助决定哪一个规则获胜，也就是说，选择哪一个选择器取决于源码顺序。</p><p><br></p><p>例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">p {\n    color: red;\n}\n\n\np {\n    color: blue;\n}</code></pre></div><p>不过有一点大家需要注意的是，当多个 <em>CSS</em> 规则匹配相同的元素时，它们都被应用到该元素中。只不过后面因为层叠规则被层叠掉了而已。打开 <em>Elements &gt; Styles</em> 我们就能看到：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-18-014022.png\" alt=\"image-20210918094021662\" contenteditable=\"false\"><br></p><h2>继承规则</h2><p>所谓继承，就是应用于某个元素的一些属性值将由该元素的子元素继承，而有些则不会。</p><p><br></p><p>究竟哪些属性能够被子元素继承，可以参阅：<em>https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference</em></p><p><br></p><p><em>CSS</em> 为处理继承提供了四种特殊的通用属性值：</p><ul><li><p><em>inherit</em>：该值将应用到选定元素的属性值设置为与其父元素一样。</p></li><li><p><em>initial</em>：该值将应用到选定元素的属性值设置为与浏览器默认样式表中该元素设置的值一样。如果浏览器默认样式表中没有设置值，并且该属性是自然继承的，那么该属性值就被设置为 <em>inherit</em>。</p></li><li><p><em>unset</em>：该值将属性重置为其自然值，即如果属性是自然继承的，那么它就表现得像 <em>inherit</em>，否则就是表现得像 <em>initial</em>。</p></li><li><p><em>revert</em>：如果当前的节点没有应用任何样式，则将该属性恢复到它所拥有的值。换句话说，属性值被设置成自定义样式所定义的属性（如果被设置）， 否则属性值被设置成用户代理的默认样式。</p></li></ul><blockquote><p>注： <em>initial</em> 和 <em>unset</em> 不被 <em>IE</em> 支持。</p></blockquote><p><strong>继承的就近原则</strong></p><p><br></p><p>由于属性值是由继承而来，所以属性值会继承离自己近的那个元素的属性。例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"one\"&gt;\n  &lt;div class=\"two\"&gt;\n    &lt;p&gt;Lorem ipsum dolor sit amet.&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.two {\n  color: blue;\n}\n\n.one {\n  color: red;\n}</code></pre></div><p>在上面的示例中，<em>two</em> 比 <em>one</em> 更加接近 <em>p</em>，所以最终采用的是 <em>two</em> 的 <em>color</em> 值。段落呈现蓝色。</p><h2>真题解答</h2><ul><li><p>请简述一下 <em>CSS</em> 中的层叠规则</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p><em>CSS</em> 中当属性值发生冲突时，通过层叠规则来计算出最终的属性值，层叠规则可以分为 <em>3</em> 块：</p><ul><li><p>重要性（<em>Importance</em>）：<em>!important</em>  设置该条属性值最重要，但是一般不推荐使用。</p></li><li><p>专用性（<em>Specificity</em>）：专用性主要是指它能匹配多少元素，匹配得越少专用性越高。</p></li><li><p>源代码次序（<em>Source order</em>）：在重要性和专用性都一致的情况下，属性值取决于源代码的先后顺序。</p></li></ul></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666075795223",
  "typeId": {
    "$oid": "634d7fc47797638ec96fe2ee"
  }
},
{
  "_id": {
    "$oid": "634e4cd32fac4881713db2ee"
  },
  "interviewTitle": "CSS引用的方式有哪些？link和@import的区别？",
  "interviewContent": "<h1><em>import</em> 指令</h1><h2>经典真题</h2><ul><li><p><em>CSS</em> 引用的方式有哪些？<em>link</em> 和 <em>@import</em> 的区别？</p></li></ul><h2>来看看 <em>import</em> 指令是啥</h2><p><em>import</em> 指令是用来导入 <em>CSS</em> 样式的。</p><p><br></p><p>什么？导入样式不是已经有 <em>link</em> 标签了么？</p><p><br></p><p>没错，<em>link</em> 标签可以导入外部 <em>CSS</em> 样式，<em>import</em> 仍然可以导入外部 <em>CSS</em> 样式。</p><p><br></p><p>我们首先来看一下 <em>import</em> 的基本用法</p><ol><li><p>在 <em>HTML</em> 文件中导入外部样式</p></li></ol><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;style&gt;\n  @import url('./index.css');\n&lt;/style&gt;</code></pre></div><p>要在 <em>HTML</em> 源代码直接应用 <em>@import</em> 引入外部 <em>CSS</em> 文件，须要将 <em>@import</em> 放入 <em>style</em> 标签</p><ol start=\"2\"><li><p>在 <em>CSS</em> 文件中引入另一个 <em>CSS</em> 文件</p></li></ol><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">@import url('./index.css');\n/* 后面书写其他样式 */</code></pre></div><p>除了 <em>HTML</em> 源代码中使用 <em>style</em> 标签来运用 <em>@import</em>，在 <em>CSS</em> 文件代码中依旧可以或许使用 <em>@import</em>，这个时候就不须要 <em>style</em> 标签，而是直接应用 <em>@import</em> 就可，这样便可实现一个（多个）<em>CSS</em> 文件中引入套入别的一个（多个）<em>CSS</em> 文件。</p><ol start=\"3\"><li><p><em>@import</em> 规则还支持媒体查询，因此可以允许依赖媒体的导入</p></li></ol><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">@import \"printstyle.css\" print;\n/* 只在媒体为 print 时导入 \"printstyle.css\" 样式表 */</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">@import \"mobstyle.css\" screen and (max-width: 768px);\n/* 只在媒体为 screen 且视口最大宽度 768 像素时导入 \"mobstyle.css\" 样式表 */</code></pre></div><p>看完了 <em>@import</em> 的基本使用后，接下来我们来看一下它和 <em>link</em> 的区别：</p><ol><li><p>link属于 <em>HTML</em> 标签，而 <em>@import</em> 完全是 <em>CSS</em> 提供的一种方式。</p><p><br></p><p><em>link</em> 标签除了可以加载 <em>CSS</em> 外，还可以做很多其它的事情，比如定义 <em>RSS</em>，定义 <em>rel</em> 连接属性等，<em>@import</em> 就只能加载 <em>CSS</em> 了。</p></li><li><p><strong>加载顺序的差别。</strong></p><p><br></p><p>比如，在 <em>a.css</em> 中使用 <em>import</em> 引用 <em>b.css</em>，只有当使用当使用 <em>import</em> 命令的宿主 <em>css</em> 文件 <em>a.css</em> 被下载、解析之后，浏览器才会知道还有另外一个 <em>b.css</em> 需要下载，这时才去下载，然后下载后开始解析、构建 <em>render tree</em> 等一系列操作.</p></li><li><p><strong>兼容性的差别。</strong></p><p><br></p><p>由于 <em>@import</em> 是 <em>CSS2.1</em> 提出的所以老的浏览器不支持，<em>@import</em> 只有在 <em>IE5</em> 以上的才能识别，而 <em>link</em> 标签无此问题。</p></li><li><p><strong>当使用 <em>JS</em> 控制 <em>DOM</em> 去改变样式的时候，只能使用 <em>link</em> 标签，因为 <em>@import</em> 不是 <em>DOM</em> 可以控制的</strong>。</p><p><br></p><p>对于可换皮肤的网站而言，可以通过改变 <em>link</em> 标签这两个的 <em>href</em> 值来改变应用不用的外部样式表，但是对于 <em>import</em> 是无法操作的，毕竟不是标签。</p></li></ol><p>另外，从性能优化的角度来讲，尽量要避免使用 <em>@import</em>。</p><p><br></p><p>使用 <em>@import</em> 引入 <em>CSS</em> 会影响浏览器的并行下载。使用 <em>@import</em> 引用的 <em>CSS</em> 文件只有在引用它的那个 <em>CSS</em> 文件被下载、解析之后，浏览器才会知道还有另外一个 <em>CSS</em> 需要下载，这时才去下载，然后下载后开始解析、构建 <em>Render Tree</em> 等一系列操作。</p><p><br></p><p>多个 <em>@import</em> 会导致下载顺序紊乱。在 <em>IE</em> 中，<em>@import</em> 会引发资源文件的下载顺序被打乱，即排列在 <em>@import</em> 后面的 <em>JS</em> 文件先于 <em>@import</em> 下载，并且打乱甚至破坏 <em>@import</em> 自身的并行下载。</p><h2>真题解答</h2><ul><li><p><em>CSS</em> 引用的方式有哪些？<em>link</em> 和 <em>@import</em> 的区别？</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p><em>CSS</em> 引用的方式有：</p><ul><li><p>外联，通过 <em>link</em> 标签外部链接样式表</p></li><li><p>内联，在 <em>head</em> 标记中使用 <em>style</em> 标记定义样式</p></li><li><p>嵌入，在元素的开始标记里通过 <em>style</em> 属性定义样式</p></li></ul><p><em>link</em> 和 <em>@import</em> 的区别：</p><ol><li><p>**<em>link</em> 属于 <em>HTML</em> 标签，而 <em>@import</em> 完全是 <em>CSS</em> 提供的一种方式。</p><p><br></p><p><em>link</em> 标签除了可以加载 <em>CSS</em> 外，还可以做很多其它的事情，比如定义 <em>RSS</em>，定义 <em>rel</em> 连接属性等，<em>@import</em> 就只能加载 <em>CSS</em> 了。</p></li><li><p><strong>加载顺序的差别。</strong></p><p><br></p><p>比如，在 <em>a.css</em> 中使用 <em>import</em> 引用 <em>b.css</em>，只有当使用当使用 <em>import</em> 命令的宿主 <em>css</em> 文件 <em>a.css</em> 被下载、解析之后，浏览器才会知道还有另外一个 <em>b.css</em> 需要下载，这时才去下载，然后下载后开始解析、构建 <em>render tree</em> 等一系列操作.</p></li><li><p><strong>兼容性的差别。</strong></p><p><br></p><p>由于 <em>@import</em> 是 <em>CSS2.1</em> 提出的所以老的浏览器不支持，<em>@import</em> 只有在 <em>IE5</em> 以上的才能识别，而 <em>link</em> 标签无此问题。</p></li><li><p><strong>当使用 <em>JS</em> 控制 <em>DOM</em> 去改变样式的时候，只能使用 <em>link</em> 标签，因为 <em>@import</em> 不是 <em>DOM</em> 可以控制的</strong>。</p><p><br></p><p>对于可换皮肤的网站而言，可以通过改变 <em>link</em> 便签这两个的 <em>href</em> 值来改变应用不用的外部样式表，但是对于 <em>import</em> 是无法操作的，毕竟不是标签。</p></li></ol></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666075859958",
  "typeId": {
    "$oid": "634d7fc47797638ec96fe2ee"
  }
},
{
  "_id": {
    "$oid": "634e4d382fac4881713db303"
  },
  "interviewTitle": "CSS 的计算属性知道吗？",
  "interviewContent": "<h1><em>CSS3</em> 的 <em>calc</em> 函数</h1><h2>经典真题</h2><ul><li><p><em>CSS</em> 的计算属性知道吗？</p></li></ul><h2><em>CSS3</em> 中的 <em>calc</em> 函数</h2><p><em>calc</em> 是英文单词 <em>calculate</em>（计算）的缩写，是 <em>CSS3</em> 的一个新增的功能。</p><p><br></p><p><em>MDN</em> 的解释为可以用在任何长度、数值、时间、角度、频率等处，语法如下：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">/* property: calc(expression) */\nwidth: calc(100% - 80px);</code></pre></div><p>可以用常见的 + - * / 符号来进行运算，但需要注意的是 + 和 - 必须用空格隔开，原因很简单，如果 - 号和计算的数字挨在一起，则浏览器在解析时会认为这可能是一个负值。</p><p><br></p><p>例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">width: calc(100% -8px); /* 这样会出错,结果为0 */</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">width: calc(100% - 8px); /* 当 + -  符号用空格隔开时,运算成功 */</code></pre></div><p>接下来我们来看一下 <em>calc</em> 函数的具体使用示例，如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"container\"&gt;\n  &lt;div class=\"item\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">* {\n  margin: 0;\n  padding: 0;\n}\n\n.container{\n  width: 500px;\n  height: 250px;\n  background-color: skyblue;\n  margin: 10px;\n  position: relative;\n}\n.item{\n  width: 100px;\n  height: 100px;\n  background-color: pink;\n  position: absolute;\n  left: calc(50% - 50px);\n  top: calc(50% - 50px);\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-14-094033.png\" alt=\"image-20210914174033014\" contenteditable=\"false\"><br></p><p><br></p><p>更多关于 <em>calc</em> 函数信息可以参阅：<em>https://developer.mozilla.org/zh-CN/docs/Web/CSS/calc()</em></p><h2>真题解答</h2><ul><li><p><em>CSS</em> 的计算属性知道吗？</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>即 <em>calc( )</em> 函数，主要用于指定元素的长度，支持所有 <em>CSS</em> 长度单位，运算符前后都需要保留一个空格。</p><p><br></p><p>比如： <em>width: calc(100% - 50px);</em></p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666075960908",
  "typeId": {
    "$oid": "634d7fc47797638ec96fe2ee"
  }
},
{
  "_id": {
    "$oid": "634e4d632fac4881713db307"
  },
  "interviewTitle": "是否了解过 CSS3 的媒体查询？",
  "interviewContent": "<h1><em>CSS3</em> 的媒介(<em>media</em>)查询</h1><h2>经典真题</h2><ul><li><p>如何使用媒体查询实现视口宽度大于 <em>320px</em> 小于 <em>640px</em> 时 <em>div</em> 元素宽度变成 <em>30%</em></p></li></ul><h2>媒体查询</h2><p>媒体查询英文全称 <em>Media Query</em>，顾名思义就是会查询用户所使用的媒体或者媒介。</p><p><br></p><p>在现在，网页的浏览终端是越来越多了。用户可以通过不同的终端来浏览网页，例如：<em>PC</em>，平板电脑，手机，电视等。尽管我们无法保证一个网站在不同屏幕尺寸和不同设备上看起来一模一样，但是至少要让我们的Web页面能适配用户的终端。</p><p><br></p><p>在 <em>CSS3</em> 中的 <em>Media Query</em> （媒体查询）模块就是用来让一个页面适应不同的终端的。</p><p><br></p><p>**<em>Media Type</em> 设备类型</p><p><br></p><p>首先我们来认识一下 <em>CSS</em> 中所支持的媒体类型。</p><p><br></p><p>在 <em>CSS2</em> 中常碰到的就是 <em>all</em>（全部）、<em>screen</em>（屏幕）和 <em>print</em>（页面打印或打印预览模式）。然而媒体的类型其实远不止这 <em>3</em> 种。</p><p><br></p><p>在 <em>W3C</em> 中共列出了 <em>10</em> 种媒体类型，如下表所示：</p><table><thead><tr><th><p>值</p></th><th><p>设备类型</p></th></tr></thead><tbody><tr><td><p>All</p></td><td><p>所有设备</p></td></tr><tr><td><p>Braille</p></td><td><p>盲人用点字法触觉回馈设备</p></td></tr><tr><td><p>Embossed</p></td><td><p>盲文打印机</p></td></tr><tr><td><p>Handheld</p></td><td><p>便携设备</p></td></tr><tr><td><p>Print</p></td><td><p>打印用纸或打印预览视图</p></td></tr><tr><td><p>Projection</p></td><td><p>各种投影设备</p></td></tr><tr><td><p>Screen</p></td><td><p>电脑显示器</p></td></tr><tr><td><p>Speech</p></td><td><p>语音或音频合成器</p></td></tr><tr><td><p>Tv</p></td><td><p>电视机类型设备</p></td></tr><tr><td><p>Tty</p></td><td><p>使用固定密度字母栅格的媒介，比如电传打字机和终端</p></td></tr></tbody></table><p>当然，虽然上面的表列出来了这么多，但是常用的也就是 <em>all</em>（全部）、<em>screen</em>（屏幕）和 <em>print</em>（页面打印或打印预览模式）这三种媒体类型。</p><p><br></p><p><strong>媒体类型引用方法</strong></p><p><br></p><p>引用媒体类型的方法有和很多，常见的媒体类型引用方法有：<em>link</em> 标签、<em>xml</em> 方式、<em>@import</em> 和 <em>CSS3</em> 新增的 <em>@media</em>。</p><ol><li><p><em>link</em> 方法</p></li></ol><p><em>link</em> 方法引入媒体类型其实就是在 <em>link</em> 标签引用样式的时候，通过 <em>link</em> 标签中的 <em>media</em> 属性来指定不同的媒体类型，如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;link rel=\"stylesheet\" href=\"index.css\" media=\"screen\" /&gt;\n&lt;link rel=\"stylesheet\" href=\"print.css\" media=\"print\" /&gt;</code></pre></div><ol start=\"2\"><li><p><em>xml</em> 方式</p></li></ol><p><em>xml</em> 方式和 <em>link</em> 方式比较相似，也是通过 <em>media</em> 属性来指定，如下：</p><div data-language=\"xml\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"xml\">&lt;? xml-stylesheet rel=\"stylesheet\" media=\"screen\" href=\"style.css\" ?&gt;</code></pre></div><ol start=\"3\"><li><p><em>@import</em></p></li></ol><p><em>@import</em> 引入媒体类型主要有两种方式，一种是在 CSS 样式表中通过 <em>@import</em> 调用另一个样式文件，另外一种是在 <em>style</em> 标签中引入。</p><blockquote><p>注意：<em>IE6</em> 和 <em>IE7</em> 中不支持该方式</p></blockquote><p>在样式文件中引入媒体类型：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">@import url('./index.css') screen</code></pre></div><p>在 <em>style</em> 标签中引入媒体类型：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;style&gt;\n  @import url('./index.css') screen\n&lt;/style&gt;</code></pre></div><ol start=\"4\"><li><p><em>@meida</em> 的方式</p></li></ol><p><em>@media</em> 是 <em>CSS3</em> 中新引进的一个特性，称为媒体查询。<em>@media</em> 引入媒体也有两种方式，如下：</p><p><br></p><p>在样式文件中引入媒体类型：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">@media screen{\n  /* 具体样式 */\n}</code></pre></div><p>在 <em>style</em> 标签中引入媒体类型：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;style&gt;\n  @media screen{\n    /* 具体样式 */\n  }\n&lt;/style&gt;</code></pre></div><p>虽然上面介绍了 <em>4</em> 种引入方式，但是最常见的就是第 <em>1</em> 种和第 <em>4</em> 种。</p><p><br></p><p><strong>媒体查询具体语法</strong></p><p><br></p><p>接下来我们来看一下媒体查询的具体语法。</p><p><br></p><p>这里我们可以将 <em>Media Query</em> 看成一个公式：</p><div data-language=\"markdown\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"markdown\">Media Type（判断条件）+ CSS（符合条件的样式规则）</code></pre></div><p>这里举例如下：</p><p><br></p><p><em>link</em> 的方式</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;link rel=\"stylesheet\" media=\"screen and (max-width:600px)\" href=\"style.css\" /&gt;</code></pre></div><p><em>@media</em> 的方式</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">@meida screen and (max-width:600px){\n  /* 具体样式 */\n}</code></pre></div><p>上面的两个例子中都是使用 <em>width</em> 来进行的样式判断，但是实际上还有很多特性都可以被用来当作样式判断的条件。</p><p><br></p><p>具体如下表：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-085040.png\" alt=\"image-20210916165039143\" contenteditable=\"false\"><br></p><p><br></p><p>有了 <em>Media Query</em>，我们能在不同的条件下使用不同的样式，使页面在不同的终端设备下达到不同的渲染效果。</p><p><br></p><p>这里有一个具体的公式如下：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">@media 媒体类型 and (媒体特性) {\n\t/* 具体样式 */\n}</code></pre></div><p>来看几个具体示例。</p><ol><li><p>最大宽度 <em>max-width</em></p></li></ol><p>该特性是指媒体类型小于或等于指定宽度时，样式生效，例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">@media screen and (max-width:480px) {\n\t/* 具体样式 */\n}</code></pre></div><p>当屏幕宽度小于或等于 <em>480px</em> 时，样式生效</p><ol start=\"2\"><li><p>最小宽度 <em>min-width</em></p></li></ol><p>该特性和上面相反，及媒体类型大于或等于指定宽度时，样式生效，例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">@media screen and (min-width:480px) {\n\t/* 具体样式 */\n}</code></pre></div><p>当屏幕宽度大于或等于 <em>480px</em> 时，样式生效</p><ol start=\"3\"><li><p>多个媒体特性混合使用</p></li></ol><p>当需要多个媒体特性时，使用 <em>and</em> 关键字将媒体特性结合在一起，例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">@media screen and (min-width:480px) and (max-width:900px){\n\t/* 具体样式 */\n}</code></pre></div><p>当屏幕大于等于 <em>480px</em> 并且小于等于 <em>900px</em> 时，样式生效。</p><ol start=\"4\"><li><p>设备屏幕的输出宽度 <em>Device Width</em></p></li></ol><p>在智能设备上，例如 <em>iphone、ipad</em> 等，可以通过 <em>min-device-width</em> 和 <em>max-device-width</em> 来设置媒体特性，例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">@media screen and (max-device-height:480px) {\n\t/* 具体样式 */\n}</code></pre></div><p>在智能设备上，当屏幕小于等于 <em>480px</em> 时样式生效</p><ol start=\"5\"><li><p><em>not</em> 关键字</p></li></ol><p><em>not</em> 关键词可以用来排除某种制定的媒体特性，示例如下：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">@media not print and (max-width:900px) {\n\t/* 具体样式 */\n}</code></pre></div><p>样式代码将被用于除了打印设备和屏幕宽度小于或等于 <em>900px</em> 的所有设备中。</p><ol start=\"6\"><li><p>未指明 <em>Media Type</em></p></li></ol><p>如果在媒体查询中没有明确的指定 <em>Media Type</em>，那么其默认值为 <em>all</em></p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">@media (max-width: 900px){\n  /* 具体样式 */\n}</code></pre></div><p>上面的样式适用于屏幕尺寸小于或等于 <em>900px</em> 的所有设备。</p><p><br></p><p>更多关于媒体查询的内容可以参阅 <em>MDN</em>：<em>https://developer.mozilla.org/zh-CN/docs/Web/CSS/Media_Queries/Using_media_queries</em></p><h2>真题解答</h2><ul><li><p>如何使用媒体查询实现视口宽度大于 <em>320px</em> 小于 <em>640px</em> 时 <em>div</em> 元素宽度变成 <em>30%</em></p></li></ul><blockquote><p>参考答案：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">@media screen and (min-width: 320px) and (max-width: 640px){\n\tdiv{\n   width: 30%;\n }\n}</code></pre></div></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666076003117",
  "typeId": {
    "$oid": "634d7fc47797638ec96fe2ee"
  }
},
{
  "_id": {
    "$oid": "634e4dc52fac4881713db315"
  },
  "interviewTitle": "CSS3 中 transition 和 animation 的作用？",
  "interviewContent": "<h1>过渡和动画事件</h1><h2>经典真题</h2><ul><li><p><em>CSS3</em> 中 <em>transition</em> 和 <em>animation</em> 的属性分别有哪些（哔哩哔哩）</p></li><li><p><em>CSS</em> 动画如何实现？</p></li></ul><h2><em>CSS3</em> 过渡</h2><p><em>CSS3</em> 新增了过渡属性，可以使用从一个状态变化到另一个状态时，变化更加的平滑。</p><p><br></p><p><em>CSS3</em> 的过渡功能像是一种黄油，<em>W3C</em> 标准中是这样描述 <em>transition</em> 的：</p><p><br></p><p><em>CSS3</em> 的 <em>transition</em> 允许 <em>CSS</em> 的属性值在一定的时间区间内平滑的过渡。这种效果可以在鼠标单击，获得焦点，对元素任何改变中触发，并平滑地以动画效果改变 <em>CSS</em> 的属性值。</p><p><br></p><p>先看一个快速入门示例，如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div&gt;&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div {\n  width: 100px;\n  height: 100px;\n  background-color: skyblue;\n}\ndiv:hover{\n  height: 300px;\n}</code></pre></div><p>在上面的代码中，我们让 <em>div</em> 被 <em>hover</em> 的时候，改变其高度，但是我们可以看到效果非常的生硬。</p><p><br></p><p>此时我们就可以添加一个 <em>CSS3</em> 新增的属性 <em>transition</em>，使其两个状态变化之间产生一个过渡效果。</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div {\n  width: 100px;\n  height: 100px;\n  background-color: skyblue;\n  transition: all .5s;\n  /* 添加过渡效果 */\n}\ndiv:hover{\n  height: 300px;\n}</code></pre></div><p>上面就是一个快速入门示例，接下来我们来看一下 <em>transition</em> 的具体语法。</p><p><br></p><p><em>transition</em> 属性是 <em>transition-property，transition-duration，transition-timing-function</em> 和 <em>transition-delay</em> 的一个简写属性。</p><ul><li><p><em>transition-property</em>：指定过渡的 <em>CSS</em> 属性</p></li><li><p><em>transition-duration</em>：指定过渡所需的完成时间</p></li><li><p><em>transition-timing-function</em>：指定过渡函数</p></li><li><p><em>transition-delay</em>：指定过渡的延迟时间</p></li></ul><p><strong><em>transition-property</em></strong></p><p><br></p><p>该属性用来指定过渡动画 <em>CSS</em> 属性名称，该属性的语法如下：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">transition-property: none | all ｜ property</code></pre></div><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-15-014159.png\" alt=\"image-20210915094158901\" contenteditable=\"false\"><br></p><p><br></p><p>需要特别说明的是，并不是所有的属性都可以进行过渡，只有属性是具有一个中点值的属性才能够进行过渡效果。因为这样才能通过不停的修改中间值从而实现过渡效果。例如 <em>display:none|block</em> 就没有中间值，所以无法应用过渡。</p><p><br></p><p>能够过渡的属性类型有颜色属性、具有长度值或百分比的属性、阴影、变形系列属性，具体支持过渡的属性可以参阅下表：</p><table><thead><tr><th><p>支持过渡的属性</p></th><th><p><br></p></th><th><p><br></p></th><th><p><br></p></th></tr></thead><tbody><tr><td><p>background-color</p></td><td><p>background-position</p></td><td><p>border-bottom-color</p></td><td><p>border-bottom-width</p></td></tr><tr><td><p>border-left-color</p></td><td><p>border-left-width</p></td><td><p>border-right-color</p></td><td><p>border-right-width</p></td></tr><tr><td><p>border-spacing</p></td><td><p>border-top-color</p></td><td><p>border-top-width</p></td><td><p>bottom</p></td></tr><tr><td><p>clip</p></td><td><p>color</p></td><td><p>font-size</p></td><td><p>font-weight</p></td></tr><tr><td><p>height</p></td><td><p>left</p></td><td><p>letter-spacing</p></td><td><p>line-height</p></td></tr><tr><td><p>margin-bottom</p></td><td><p>margin-left</p></td><td><p>margin-right</p></td><td><p>margin-top</p></td></tr><tr><td><p>max-height</p></td><td><p>max-width</p></td><td><p>min-height</p></td><td><p>min-width</p></td></tr><tr><td><p>opacity</p></td><td><p>outline-color</p></td><td><p>outline-width</p></td><td><p>padding-bottom</p></td></tr><tr><td><p>padding-left</p></td><td><p>padding-right</p></td><td><p>padding-top</p></td><td><p>right</p></td></tr><tr><td><p>text-indent</p></td><td><p>text-shadow</p></td><td><p>vertical-align</p></td><td><p>visibility</p></td></tr><tr><td><p>width</p></td><td><p>word-spacing</p></td><td><p>z-index</p></td><td><p><br></p></td></tr></tbody></table><p><strong><em>transition-duration</em></strong></p><p><br></p><p>该属性主要用于设置一个属性过渡到另一个属性所需要的时间，单位为秒(<em>s</em>)或者毫秒(<em>ms</em>)。默认值为 <em>0</em>，代表变换是即时的。</p><p><br></p><p><strong><em>transition-timing-function</em></strong></p><p><br></p><p>该属性用于设置过渡的速度，有如下的取值：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-15-014104.png\" alt=\"image-20210915094104556\" contenteditable=\"false\"><br></p><p><br></p><p><strong><em>transition-delay</em></strong></p><p><br></p><p>过渡延迟多久触发，单位为秒或者毫秒。但是值可以是正整数，负整数和 <em>0</em>。</p><p><br></p><p>正整数和 <em>0</em> 都比较好理解，这里主要说一下负整数。负整数的计算会从整体过渡时间中去做减法运算，举个例子：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div {\n  width: 100px;\n  height: 100px;\n  background-color: skyblue;\n  transition: all 5s -2s;\n  /* 设置为 -2s，相当于已经执行了 2s */\n}\ndiv:hover{\n  height: 300px;\n}</code></pre></div><p><strong>多个元素过渡</strong></p><p><br></p><p>如果要对多个 <em>CSS3</em> 属性应用过渡效果，直接用逗号分离开即可，这种主要是针对每个属性过渡的时间不同的情况下。</p><p><br></p><p>例如下面的例子：背景颜色过渡时间为 <em>2s</em>，而宽度的过渡时间为 <em>5s</em>：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div {\n  width: 100px;\n  height: 100px;\n  background-color: skyblue;\n  transition: background-color 2s, height 5s;\n}\ndiv:hover{\n  height: 300px;\n  background-color: pink;\n}</code></pre></div><p>当然，如果每个属性的过渡时间都一样的话，那么直接使用 <em>all</em> 会更简洁一些。</p><p><br></p><p>**<em>hover</em> 时期不同的过渡设置</p><p><br></p><p>我们可以在 <em>hover</em> 时对状态的变化设置一个过渡效果，鼠标移开元素恢复时设置另一个过渡效果。例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div {\n  width: 100px;\n  height: 100px;\n  background-color: skyblue;\n  transition: all 5s\n    /* 鼠标移走时的过渡 */\n}\ndiv:hover{\n  height: 300px;\n  background-color: pink;\n  transition: all 2s;\n  /* 鼠标 hover 时状态变化的过渡 */\n}</code></pre></div><p><strong>过渡事件</strong></p><p><br></p><p>有些时候，在 <em>JS</em> 中的某些操作需要过渡效果结束后再执行，此时事件类型中给我们提供了一个 <em>transitionend</em> 事件方便我们监听过渡效果是否结束，例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div id=\"oDiv\"&gt;&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div {\n  width: 100px;\n  height: 100px;\n  background-color: skyblue;\n  transition: all 3s\n}</code></pre></div><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var div = document.getElementById(\"oDiv\");\ndiv.onclick = function(){\n  div.style.height = \"400px\";\n}\ndiv.ontransitionend = function(){\n  console.log(\"过渡结束后触发\");\n}</code></pre></div><h2><em>CSS3</em> 动画</h2><p>在 <em>CSS3</em> 中新增了一个 <em>animation</em> 模块，可以制作出类似于 <em>flash</em> 一样的动画出来。</p><p><br></p><p>我们首先还是来看一个快速入门示例，如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div&gt;&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">*{\n  margin: 0;\n  padding: 0;\n}\ndiv {\n  width: 100px;\n  height: 100px;\n  background-color: skyblue;\n  position: absolute;\n  animation: test 5s;\n}\n@keyframes test{\n  0% {\n    left: 0;\n    top: 0;\n  }\n  25% {\n    left: 400px;\n    top: 0;\n  }\n  40% {\n    left: 400px;\n    top: 200px;\n  }\n  65% {\n    left: 0;\n    top: 200px;\n  }\n  100% {\n    left: 0;\n    top: 0;\n  }\n}</code></pre></div><p>在上面的代码示例中，我们声明了一个名为 <em>test</em> 的动画，然后在 <em>div</em> 中运用了这个动画，整个动画的播放时间为 <em>5s</em>。</p><p><br></p><p>接下来我们来看一下 <em>CSS3</em> 中动画的具体细节。</p><p><br></p><p>使用 <em>CSS3</em> 的 <em>animation</em> 制作动画包含两个部分：首先是用关键帧声明一个动画，其次是在 <em>animation</em> 调用关键帧声明的动画。</p><p><br></p><p><strong>声明动画</strong></p><p><br></p><p>在 <em>CSS3</em> 中，使用 <em>@keyframes</em> 来声明一个动画，语法为：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">@keyframes animationname {keyframes-selector {css-styles;}}</code></pre></div><p>属性对应的说明如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-15-021257.png\" alt=\"image-20210915101256811\" contenteditable=\"false\"><br></p><p><br></p><p>在上面的示例中，我们声明动画的代码为：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">@keyframes test{\n  0% {\n    left: 0;\n    top: 0;\n  }\n  25% {\n    left: 400px;\n    top: 0;\n  }\n  40% {\n    left: 400px;\n    top: 200px;\n  }\n  65% {\n    left: 0;\n    top: 200px;\n  }\n  100% {\n    left: 0;\n    top: 0;\n  }\n}</code></pre></div><p>这里我们就声明了一个名为 <em>test</em> 的动画，设置了 <em>5</em> 个时间段，分别是 <em>0%、25%、40%、65%</em> 和 <em>100%</em>，每个时间段都有对应的不同 <em>CSS</em> 样式，当动画执行时，从一个时间段到另一个时间段会自动运用过渡效果，所以我们可以看到整个流程是非常平滑的。</p><p><br></p><p><strong>使用动画</strong></p><p><br></p><p><em>@keyframes</em> 只是用来声明一个动画，如果一个声明的动画不被调用，那么这个动画是没有任何意义的。</p><p><br></p><p>在 <em>CSS3</em> 中通过 <em>animation</em> 属性来调用动画。</p><p><br></p><p>语法如下：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">animation: name duration timing-function delay iteration-count direction fill-mode play-state;</code></pre></div><ul><li><p><em>animation-name</em>：指定要绑定到选择器的关键帧的名称</p></li><li><p><em>animation-duration</em>：动画指定需要多少秒或毫秒完成</p></li><li><p><em>animation-timing-function</em>：设置动画将如何完成一个周期</p></li><li><p><em>animation-delay</em>：设置动画在启动前的延迟间隔</p></li><li><p><em>animation-iteration-count</em>：定义动画的播放次数</p></li><li><p><em>animation-direction</em>：指定是否应该轮流反向播放动画</p></li><li><p><em>animation-fill-mode</em>：规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式</p></li><li><p><em>animation-play-state</em>：指定动画是否正在运行或已暂停</p></li></ul><p>前面 <em>4</em> 个属性没什么好说，大体上和前面介绍的 transition 的属性很像，这里我们主要看一下后面几个属性。</p><p><br></p><p><strong><em>animation-iteration-count</em></strong></p><p><br></p><p><em>animation-iteration-count</em> 属性定义动画应该播放多少次，如果想要一直播放，那么次数就是无限次，所以属性值为 <em>infinite</em>。</p><p><br></p><p><strong><em>animation-direction</em></strong></p><p><br></p><p>正常情况下，动画播放完毕以后，会立刻回到起始的状态。例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">@keyframes test{\n  0% {\n    left: 0;\n    top: 0;\n  }\n  50% {\n    left: 400px;\n    top: 0;\n  }\n  100% {\n    left: 400px;\n    top: 200px;\n  }\n}</code></pre></div><p>对上面快速入门的示例稍作修改，我们就会发现，动画播放完毕后立马就回到起始状态了。</p><p><br></p><p>那么 <em>animation-direction</em> 就可以设置动画是否要反向播放回去。该属性对应的可设置值有：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">animation-direction: normal|reverse|alternate|alternate-reverse|initial|inherit;</code></pre></div><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-15-024829.png\" alt=\"image-20210915104829295\" contenteditable=\"false\"><br></p><p><br></p><p>需要注意的是，如果动画被设置为只播放一次，该属性将不起作用。</p><p><br></p><p>另外，无论动画正向播放还是反向播放，都会算一次次数，例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div {\n  width: 100px;\n  height: 100px;\n  background-color: skyblue;\n  position: absolute;\n  animation: test 5s 5 alternate;\n}\n@keyframes test{\n  0% {\n    left: 0;\n    top: 0;\n  }\n  50% {\n    left: 400px;\n    top: 0;\n  }\n  100% {\n    left: 400px;\n    top: 200px;\n  }\n}</code></pre></div><p>在上面的代码中，我们设置一共播放 <em>5</em> 次，那么整个动画就会正向播放 <em>3</em> 次，反向播放 <em>2</em> 次。</p><p><br></p><p><strong><em>animation-fill-mode</em></strong></p><p><br></p><p><em>animation-fill-mode</em> 属性规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。</p><p><br></p><p>一般主要用于设置动画播放完毕后的状态。</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">animation-fill-mode: none|forwards|backwards|both|initial|inherit;</code></pre></div><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-15-025723.png\" alt=\"image-20210915105722895\" contenteditable=\"false\"><br></p><p><br></p><p>用得最多的值就是 <em>forwards</em>，定义动画播放完后保持结束时候的样子。默认值为 <em>none</em>，表示动画将按预期进行和结束，在动画完成其最后一帧时，动画会反转到初始帧处。当取值为 <em>backwards</em> 时，会在动画结束时迅速应用动画的初始帧。</p><p><br></p><p><strong><em>animation-play-state</em></strong></p><p><br></p><p><em>animation-play-state</em> 属性规定动画正在运行还是暂停，语法为：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">animation-play-state: paused|running;</code></pre></div><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-15-030119.png\" alt=\"image-20210915110118784\" contenteditable=\"false\"><br></p><p><br></p><p>该属性一般配合着 <em>JS</em> 一起使用，从而达到对动画播放状态的一个控制。例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;button id=\"playAnimate\"&gt;播放动画&lt;/button&gt;\n&lt;button id=\"pauseAnimate\"&gt;暂停动画&lt;/button&gt;\n&lt;div id=\"oDiv\"&gt;&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">*{\n  margin: 0;\n  padding: 0;\n}\ndiv {\n  width: 100px;\n  height: 100px;\n  background-color: skyblue;\n  position: absolute;\n  animation: test 2s 5 alternate paused;\n}\n@keyframes test{\n  0% {\n    left: 0;\n    top: 30px;\n  }\n  50% {\n    left: 400px;\n    top: 30px;\n  }\n  100% {\n    left: 400px;\n    top: 200px;\n  }\n}</code></pre></div><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var oDiv = document.getElementById(\"oDiv\");\nvar playAnimate = document.getElementById(\"playAnimate\");\nvar pauseAnimate = document.getElementById(\"pauseAnimate\");\nplayAnimate.onclick = function(){\n  oDiv.style.animationPlayState = \"running\"\n}\npauseAnimate.onclick = function(){\n  oDiv.style.animationPlayState = \"paused\"\n}</code></pre></div><p>在上面的示例中，我们就通过 <em>JS</em> 来控制 <em>animation-play-state</em> 从而切换动画播放与暂停这两个状态。</p><p><br></p><p><strong>动画对应事件</strong></p><p><br></p><p>同样，动画也有对应的事件，与过渡只提供有 <em>transitionend</em> 事件不同的是，在 <em>CSS</em> 动画播放时，会发生以下三个事件：</p><ul><li><p><em>animationstart</em>：<em>CSS</em> 动画开始后触发</p></li><li><p><em>animationiteration</em>：<em>CSS</em> 动画重复播放时触发</p></li><li><p><em>animationend</em>：<em>CSS</em> 动画完成后触发</p></li></ul><h2>真题解答</h2><ul><li><p><em>CSS3</em> 中 <em>transition</em> 和 <em>animation</em> 的属性分别有哪些（哔哩哔哩）</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p><em>transition</em> 过渡动画：</p><ul><li><p><em>transition-property</em>：指定过渡的 <em>CSS</em> 属性</p></li><li><p><em>transition-duration</em>：指定过渡所需的完成时间</p></li><li><p><em>transition-timing-function</em>：指定过渡函数</p></li><li><p><em>transition-delay</em>：指定过渡的延迟时间</p></li></ul><p><em>animation</em> 关键帧动画：</p><ul><li><p><em>animation-name</em>：指定要绑定到选择器的关键帧的名称</p></li><li><p><em>animation-duration</em>：动画指定需要多少秒或毫秒完成</p></li><li><p><em>animation-timing-function</em>：设置动画将如何完成一个周期</p></li><li><p><em>animation-delay</em>：设置动画在启动前的延迟间隔</p></li><li><p><em>animation-iteration-count</em>：定义动画的播放次数</p></li><li><p><em>animation-direction</em>：指定是否应该轮流反向播放动画</p></li><li><p><em>animation-fill-mode</em>：规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式</p></li><li><p><em>animation-play-state</em>：指定动画是否正在运行或已暂停</p></li></ul></blockquote><ul><li><p><em>CSS</em> 动画如何实现？</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>即 <em>animation</em> 属性，对元素某个或多个属性的变化进行控制，可以设置多个关键帧。属性包含了动画的名称、完成时间（以毫秒计算）、周期、间隔、播放次数、是否反复播放、不播放时应用的样式、动画暂停或运行。</p><p><br></p><p>它不需要触发任何事件就可以随着时间变化来改变元素的样式。</p><p><br></p><p><strong>使用 <em>CSS</em> 做动画</strong>：</p><ul><li><p><em>@keyframes</em> 规定动画。</p></li><li><p><em>animation</em> 所有动画属性的简写属性。</p></li><li><p><em>animation-name</em> 规定 <em>@keyframes</em> 动画的名称。</p></li><li><p><em>animation-duration</em> 规定动画完成一个周期所花费的秒或毫秒。默认是 0。</p></li><li><p><em>animation-timing-function</em> 规定动画的速度曲线。默认是 <em>ease</em>。</p></li><li><p><em>animation-fill-mode</em> 规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。</p></li><li><p><em>animation-delay</em> 规定动画何时开始。默认是 <em>0</em>。</p></li><li><p><em>animation-iteration-count</em> 规定动画被播放的次数。默认是 <em>1</em>。</p></li><li><p><em>animation-direction</em> 规定动画是否在下一周期逆向地播放。默认是 <em>normal</em>。</p></li><li><p><em>animation-play-state</em> 规定动画是否正在运行或暂停。默认是 <em>running</em>。</p></li></ul></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666076101701",
  "typeId": {
    "$oid": "634d7fc47797638ec96fe2ee"
  }
},
{
  "_id": {
    "$oid": "634e4e802fac4881713db323"
  },
  "interviewTitle": "描述一下渐进增强和优雅降级之间的不同",
  "interviewContent": "<h1>渐进增强和优雅降级</h1><h2>经典真题</h2><ul><li><p>说说渐进增强和优雅降级?</p></li><li><p>你能描述一下渐进增强和优雅降级之间的不同吗?</p></li></ul><h2>渐进增强和优雅降级</h2><p>渐进增强，英语全称 <em>progressive enhancement</em>，指的是针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p><p><br></p><p>优雅降级，英语全称 <em>graceful degradation</em>，一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p><p><br></p><p>这两个概念其实并不是一个新的概念，就是以前提到的\"向上兼容\"和\"向下兼容\"。渐进增强相当于向上兼容，优雅降级相当于向下兼容。向下兼容指的是高版本支持低版本，或者说后期开发的版本能兼容早期开发的版本。</p><p><br></p><p>在确定用户群体的前提下，渐进增强：针对低版本浏览器进行页面构建，保证基本功能，再针对高级浏览器进行效果、交互等改进和追加功能，达到更好的用户体验。</p><p><br></p><p>优雅降级：一开始就构建完整的功能，再针对低版本浏览器进行兼容。</p><p><br></p><p>区别：优雅降级是从复杂的现状开始并试图减少用户体验的供给，而渐进增强则是从一个基础的、能够起到作用的版本开始再不断扩充，以适应未来环境的需要。</p><p><br></p><p>例如看下面这两段代码的书写顺序，看上去只是书写顺序的不同，实则表示了我们开发的着重点：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.transition { /*渐进增强写法*/\n  -webkit-transition: all .5s;\n     -moz-transition: all .5s;\n       -o-transition: all .5s;\n          transition: all .5s;\n}\n.transition { /*优雅降级写法*/\n          transition: all .5s;\n       -o-transition: all .5s;\n     -moz-transition: all .5s;\n  -webkit-transition: all .5s;\n}</code></pre></div><p>前缀 <em>CSS3</em>（-webkit-、-moz-、-o-）和正常 <em>CSS3</em> 在浏览器中的支持情况是这样的：</p><ol><li><p><strong>很久以前</strong>：浏览器前缀 <em>CSS3</em> 和正常 <em>CSS3</em> 都不支持</p></li><li><p><strong>不久之前</strong>：浏览器<strong>只支持</strong>前缀 <em>CSS3</em>，<strong>不支持</strong>正常 <em>CSS3</em></p></li><li><p><strong>现在</strong>：浏览器<strong>既支持</strong>前缀 <em>CSS3</em>，<strong>又支持</strong>正常 <em>CSS3</em></p></li><li><p><strong>未来</strong>：浏览器<strong>不支持</strong>前缀 <em>CSS3</em>，<strong>仅支持</strong>正常 <em>CSS3</em></p></li></ol><p>渐进增强的写法，优先考虑老版本浏览器的可用性，最后才考虑新版本的可用性。在时期 <em>3</em> 前缀 <em>CSS3</em> 和正常 <em>CSS3</em> 都可用的情况下，正常 <em>CSS3</em> 会覆盖前缀 <em>CSS3</em>。</p><p><br></p><p>优雅降级的写法，优先考虑新版本浏览器的可用性，最后才考虑老版本的可用性。在时期 <em>3</em> 前缀 <em>CSS3</em> 和正常 <em>CSS3</em> 都可用的情况下，前缀 <em>CSS3</em> 会覆盖正常的 <em>CSS3</em>。</p><p><br></p><p>绝大多少的大公司都是采用渐进增强的方式，因为业务优先，提升用户体验永远不会排在最前面。</p><ul><li><p>例如新浪微博网站这样亿级用户的网站，前端的更新绝不可能追求某个特效而不考虑低版本用户是否可用。一定是确保低版本到高版本的可访问性再渐进增强。</p></li><li><p>如果开发的是一面面向青少面的软件或网站，你明确这个群体的人总是喜欢尝试新鲜事物，喜欢炫酷的特效，喜欢把软件更新至最新版本，这种情况再考虑优雅降级。</p></li></ul><h2>真题解答</h2><ul><li><p>说说渐进增强和优雅降级?</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>渐进增强，英语全称 <em>progressive enhancement</em>，指的是针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p><p><br></p><p>优雅降级，英语全称 <em>graceful degradation</em>，一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666076288659",
  "typeId": {
    "$oid": "634d7fc47797638ec96fe2ee"
  }
},
{
  "_id": {
    "$oid": "634e4eba2fac4881713db327"
  },
  "interviewTitle": "请简述一下 CSS3 中新增的变形如何使用？",
  "interviewContent": "<h1><em>CSS3</em> 变形</h1><h2>经典真题</h2><ul><li><p>请简述一下 <em>CSS3</em> 中新增的变形如何使用？</p></li></ul><h2><em>CSS3</em> 变形相关知识</h2><h3>变形介绍</h3><p><em>CSS2.1</em> 中的页面都是静态的，多年来，<em>Web</em> 设计师依赖于图片、<em>Flash</em> 或者 <em>JavaScript</em> 才能完成修改页面的外观。<em>CSS3</em> 改变了设计师这种思维，借助 <em>CSS3</em> 可以轻松的倾斜、缩放、移动以及翻转元素。</p><p><br></p><p><em>2012</em> 年 <em>9</em> 月，<em>W3C</em> 组织发布了 <em>CSS3</em> 变形工作草案。允许 <em>CSS</em> 把元素变成 <em>2D</em> 或者 <em>3D</em> 空间，这其实就是 <em>CSS3</em> 的 <em>2D</em> 变形和 <em>3D</em> 变形。</p><p><br></p><p><em>CSS3</em> 变形是一些效果的集合，比如平移、旋转、缩放和倾斜效果，每个效果通过变形函数（<em>transform function</em>）来实现。在此之前，要想实现这些效果，必须依赖图片、<em>Flash</em> 或者 <em>JavaScript</em> 才能完成，而现在仅仅使用纯 <em>CSS</em> 就能够实现，大大的提高了开发效率以及页面的执行效率。</p><p><br></p><p>变形效果要通过变形函数来实现，语法如下：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">transform: none|transform-functions;</code></pre></div><p>那么 <em>CSS3</em> 中为我们提供了哪些变形函数呢？</p><p><br></p><p>这里我们整体可以划分出 <em>3</em> 大类：</p><ul><li><p>具有 <em>X/Y</em> 的函数：<em>translateX、translateY、sclaeX、scaleY、skewX、skewY</em></p></li><li><p><em>2D</em> 变形函数：<em>translate、sclae、rotate、skew、matrix</em></p></li><li><p><em>3D</em> 变形函数：<em>rotateX、rotateY、rotate3d、translateZ、translate3d、scaleZ、scale3d、matrix3d</em></p></li></ul><p>此时，你可能已经做好了逐一击破每个变形函数的思想准备了。</p><p><br></p><p>别急，在介绍每个变形函数之前，我们先来了解一下变形相关的属性。</p><h3>变形属性</h3><ol><li><p><strong><em>transform</em> 属性</strong></p></li></ol><p>第一个首当其冲的就是 <em>transform</em> 属性，该属性所对应的属性值就是一系列的变形函数，例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">transform: scale(1.5)</code></pre></div><p>上面的代码中，我们设置了 <em>transform</em> 属性，属性值为 <em>scale</em> 变形函数。</p><ol start=\"2\"><li><p><strong><em>transform-origin</em> 属性</strong></p></li></ol><p>接下来第二个是 <em>transform-origin</em> 属性，该属性用于设置元素的中心点位置。该属性语法如下：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">transform-origin: x-axis y-axis z-axis;</code></pre></div><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-080037.png\" alt=\"image-20210919160036555\" contenteditable=\"false\"><br></p><p><br></p><p>为了演示此属性的作用，我们先透支一点后面的知识。</p><p><br></p><p>这里我们以 <em>rotate</em> 为例。<em>rotate</em> 是变形函数中的一个，作用是旋转元素，其语法如下：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">rotate(angle)</code></pre></div><p>定义 <em>2D</em> 旋转，在参数中规定角度。</p><p><br></p><p>来看一个例子：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div&gt;&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div{\n  width: 150px;\n  height: 150px;\n  background-color: red;\n  margin: 200px;\n  transition: all 1s;\n}\ndiv:hover{\n  transform: rotate(45deg);\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-080641.gif\" alt=\"2021-09-19 16.06.26\" contenteditable=\"false\"><br></p><p><br></p><p>在上面的示例中，我们设置 <em>div</em> 鼠标 <em>hover</em> 的时候进行变形，旋转 <em>45</em> 度，为了更加平滑，我们加入了 <em>transition</em> 过渡效果。</p><p><br></p><p>我们观察整个元素的旋转中心点，是在元素的最中央。</p><p><br></p><p>接下来我们可以使用 <em>transform-origin</em> 来修改这个中心点的位置。例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div{\n  width: 150px;\n  height: 150px;\n  background-color: red;\n  margin: 200px;\n  transition: all 1s;\n  transform-origin: bottom left;\n  /* 修改元素的中心点位置 */\n}\ndiv:hover{\n  transform: rotate(45deg);\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-081002.gif\" alt=\"2021-09-19 16.09.46\" contenteditable=\"false\"><br></p><p><br></p><p>在上面的代码中，我们修改了元素的中心点位置为 <em>bottom、left</em>，也就是左下角。可以看到因为元素的中心点位置发生了变化，旋转的方式也随之发生了改变。</p><p><br></p><p><em>transform-origin</em> 的属性值除了像上面一样设置关键词以外，也可以是百分比、<em>em、px</em> 等具体的值。</p><p><br></p><p><em>transform-origin</em> 的第三个参数是定义 <em>Z</em> 轴的距离，这在后面介绍 <em>3D</em> 变形时再来介绍。</p><ol start=\"3\"><li><p><strong><em>transform-style</em> 属性</strong></p></li></ol><p><em>transform-style</em> 属性是 <em>3D</em> 空间一个重要属性，指定了嵌套元素如何在 <em>3D</em> 空间中呈现。语法如下：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">transform-style: flat | preserve-3d;</code></pre></div><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-091723.png\" alt=\"image-20210919171722656\" contenteditable=\"false\"><br></p><p><br></p><p>其中 <em>flat</em> 为默认值。</p><p><br></p><p>需要注意的是该属性需要设置在父元素上面，使其变成一个真正的 <em>3D</em> 图形。</p><p><br></p><p>当然光看属性说明是非常模糊的，一点都不直观，我们直接来看一个例子。</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"box\"&gt;\n  &lt;div class=\"up\"&gt;上&lt;/div&gt;\n  &lt;div class=\"down\"&gt;下&lt;/div&gt;\n  &lt;div class=\"left\"&gt;左&lt;/div&gt;\n  &lt;div class=\"right\"&gt;右&lt;/div&gt;\n  &lt;div class=\"forword\"&gt;前&lt;/div&gt;\n  &lt;div class=\"back\"&gt;后&lt;/div&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.box {\n  width: 250px;\n  height: 250px;\n  border: 1px dashed red;\n  margin: 100px auto;\n  position: relative;\n  border-radius: 50%;\n  transform-style: preserve-3d;\n  animation: gun 8s linear infinite;\n}\n\n.box&gt;div {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  text-align: center;\n  line-height: 250px;\n  font-size: 60px;\n  color: #daa520;\n}\n\n.left {\n  background-color: rgba(255, 0, 0, 0.3);\n  transform-origin: left;\n  transform: rotateY(90deg) translateX(-125px);\n}\n\n.right {\n  background: rgba(0, 0, 255, 0.3);\n  transform-origin: right;\n  /* 变换*/\n  transform: rotateY(90deg) translateX(125px);\n}\n.forward {\n  background: rgba(255, 255, 0, 0.3);\n  transform: translateZ(125px);\n}\n.back {\n  background: rgba(0, 255, 255, 0.3);\n  transform: translateZ(-125px);\n}\n.up {\n  background: rgba(255, 0, 255, 0.3);\n  transform: rotateX(90deg) translateZ(125px);\n}\n.down {\n  background: rgba(99, 66, 33, 0.3);\n  transform: rotateX(-90deg) translateZ(125px);\n}\n@keyframes gun {\n  0% {\n    transform: rotateX(0deg) rotateY(0deg);\n  }\n\n  100% {\n    transform: rotateX(360deg) rotateY(360deg);\n  }\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-092030.gif\" alt=\"2021-09-19 17.20.08\" contenteditable=\"false\"><br></p><p><br></p><p>上面的 <em>CSS</em> 代码不用具体去关心，我们只看在 <em>box</em> 元素上面添加了一句 <em>transform-style: preserve-3d</em>，表示 <em>box</em> 里面的子元素都以 <em>3D</em> 的形式呈现。如果我们把这行代码去除掉或者值修改为 <em>flat</em>，效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-092331.gif\" alt=\"2021-09-19 17.23.06\" contenteditable=\"false\"><br></p><p><br></p><p>怎么样？是不是非常直观，一下子就知道 <em>transform-style</em> 属性的作用是什么了。该属性就是指定子元素是在 <em>3D</em> 空间还是 <em>2D</em> 平面中显示。</p><ol start=\"4\"><li><p><strong><em>perspective</em> 属性</strong></p></li></ol><p><em>perspective</em> 属性用于设置查看者的位置，可以将可视内容映射到一个视锥上，继而投到一个 <em>2D</em> 视平面上。如果不指定该属性，则 <em>Z</em> 轴空间中所有点将平铺到同一个 <em>2D</em> 视平面中，并且在变换结果中将不存在景深概念。</p><p><br></p><p>简单理解，就是视距，用来设置用户和元素 <em>3D</em> 空间 <em>Z</em> 平面之间的距离。而其效应由他的值来决定，值越小，用户与 <em>3D</em> 空间 <em>Z</em> 平面距离越近，视觉效果更令人印象深刻；反之，值越大，用户与 <em>3D</em> 空间 <em>Z</em> 平面距离越远，视觉效果就很小。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-094151.png\" alt=\"image-20210919174151244\" contenteditable=\"false\"><br></p><p><br></p><p>注意当为元素定义 <em>perspective</em> 属性时，其子元素会获得透视效果，而不是元素本身。</p><p><br></p><p>我们还是来看一个直观的例子来了解这个属性的作用。例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"container\"&gt;\n  &lt;div class=\"item\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.container{\n  width: 500px;\n  height: 500px;\n  border: 1px solid;\n  margin: 100px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.item{\n  width: 150px;\n  height: 150px;\n  background-color: red;\n  animation: rotateAnimation 5s infinite;\n}\n@keyframes rotateAnimation {\n  0%{\n    transform: rotateY(0deg);\n  }\n  100%{\n    transform: rotateY(360deg);\n  }\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-095136.gif\" alt=\"2021-09-19 17.51.16\" contenteditable=\"false\"><br></p><p><br></p><p>在上面的代码中，我们虽然设置了 <em>div.item</em> 沿着 <em>Y</em> 轴进行旋转，但是由于没有设置 <em>perspective</em> 视距，所以看上去就像是 <em>div</em> 盒子在宽度伸缩一样，<em>3D</em> 效果并不明显。</p><p><br></p><p>此时我们可以给父元素 <em>div.container</em> 设置 <em>perspective</em> 视距，例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.container{\n  ...\n  perspective: 1200px;\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-095428.gif\" alt=\"2021-09-19 17.54.08\" contenteditable=\"false\"><br></p><p><br></p><p>很明显，加入  <em>perspective</em> 视距后，<em>3D</em> 旋转效果更佳的真实。</p><p><br></p><p>关于 <em>perspective</em> 的取值，接受一个长度单位大于 <em>0</em>，其单位不能为百分比的值。大致能够分为如下 <em>3</em> 种情况：</p><ul><li><p><em>none</em> 或者不设置：没有 <em>3D</em> 空间。</p></li><li><p>取值越小：<em>3D</em> 效果越明显，也就是眼睛越靠近真 <em>3D</em>。</p></li><li><p>取值无穷大或者为 <em>0</em>：与取值为 <em>none</em> 的效果一样。</p></li></ul><ol start=\"5\"><li><p><strong><em>perspective-origin</em> 属性</strong></p></li></ol><p>如果理解了上面的 <em>perspective</em> 属性，那么这个 <em>perspective-origin</em> 就非常好理解了，该属性用来决定 <em>perspective</em> 属性的源点角度。</p><p><br></p><p>其语法如下：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">perspective-origin: x-axis y-axis;</code></pre></div><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-124302.png\" alt=\"image-20210919204301259\" contenteditable=\"false\"><br></p><p><br></p><p>举个例子：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.container{\n  ...\n  perspective: 600px;\n  perspective-origin: top;\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-124520.gif\" alt=\"2021-09-19 20.45.00\" contenteditable=\"false\"><br></p><p><br></p><p>由于我们设置的 <em>perspective-origin</em> 的值为 <em>top</em>，所以会呈现一种俯视的效果。如果将其值修改为 <em>bottom</em>，则会是仰视的即视感，如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-124646.gif\" alt=\"2021-09-19 20.46.34\" contenteditable=\"false\"><br></p><ol start=\"6\"><li><p><strong><em>backface-visibility</em> 属性</strong></p></li></ol><p><em>backface-visibility</em> 属性决定元素旋转背面是否可见。对于未旋转的元素，该元素的正面面向观看者。当其旋转 <em>180</em> 度时会导致元素的背面面向观众。</p><p><br></p><p>该属性是设置在旋转的元素上面，语法如下：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">backface-visibility: visible|hidden;</code></pre></div><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-125232.png\" alt=\"image-20210919205231265\" contenteditable=\"false\"><br></p><p><br></p><p>来看一个具体的例子：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.item{\n  ...\n  backface-visibility: hidden;\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-133845.gif\" alt=\"2021-09-19 21.38.25\" contenteditable=\"false\"><br></p><p><br></p><p>在上面的代码中，我们在子元素 <em>div.item</em> 上设置了 <em>backface-visibility: hidden</em>，当此元素旋转 <em>180</em> 度到背面时，我们可以发现此时是无法看到背面的。</p><h3><em>2D</em> 变形</h3><p>介绍完 <em>CSS3</em> 中变形的相关属性后，接下来我们就该来看一下具体的变形函数了。</p><p><br></p><p>整个 CSS3 为我们提供了相当丰富的变形函数，有 <em>2D</em> 的，有 <em>3D</em> 的。这里我们先来看 <em>2D</em> 的变形函数。</p><h4><em>2D</em> 位移</h4><p><em>2D</em> 位移对应有 <em>3</em> 个变形函数，分别是 <em>translate、translateX、translateY</em></p><p><br></p><p>用法也非常简单，<em>translate</em> 方法从其当前位置移动元素（根据为 <em>X</em> 轴和 <em>Y</em> 轴指定的参数）。</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div {\n  transform: translate(50px, 100px);\n}</code></pre></div><p>上面的例子把 <em>div</em> 元素从其当前位置向右移动 <em>50</em> 个像素，并向下移动 <em>100</em> 个像素：效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-134634.png\" alt=\"Translate\" contenteditable=\"false\"><br></p><h4><em>2D</em> 缩放</h4><p><em>2D</em> 缩放对应的也有 <em>3</em> 个变形函数，分别是 <em>sclae、sclaeX、sclaeY</em></p><p><br></p><p>该方法能够按照倍数放大或缩小元素的大小（根据给定的宽度和高度参数）。默认值为 <em>1</em>，小于这个值就是缩小，大于这个值就是放大。</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div {\n  transform: scale(2, 3);\n}</code></pre></div><p>上面的例子把 <em>div</em> 元素增大为其原始宽度的两倍和其原始高度的三倍，效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-135001.png\" alt=\"Scale\" contenteditable=\"false\"><br></p><h4><em>2D</em> 旋转</h4><p><em>2D</em> 旋转对应的只有 <em>1</em> 个变形函数 <em>rotate</em>，这个我们在前面也已经用过了。</p><p><br></p><p>该变形函数只接受一个值代表旋转的角度值，取值可正可负，正值代表顺时针旋转，负值代表逆时针旋转。</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div {\n  transform: rotate(20deg);\n}</code></pre></div><p>上面的例子把 <em>div</em> 元素顺时针旋转 <em>20</em> 度，效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-135300.png\" alt=\"Rotate\" contenteditable=\"false\"><br></p><h4><em>2D</em> 倾斜</h4><p><em>2D</em> 倾斜对应的变形函数也是 <em>3</em> 个，分别是 <em>skew、skewX、skewY</em></p><p><br></p><p>语法如下：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">skew(ax, ay)</code></pre></div><ul><li><p><em>ax</em>：指定元素水平方向（<em>X</em> 轴方向）倾斜角度</p></li><li><p><em>ay</em>：指定元素垂直方向（<em>Y</em> 轴方向）倾斜角度</p></li></ul><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div&gt;&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div{\n  width: 150px;\n  height: 150px;\n  background-color: red;\n  margin: 150px;\n  transition: all 1s;\n}\ndiv:hover{\n  transform: skew(20deg);\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-140231.gif\" alt=\"2021-09-19 22.02.15\" contenteditable=\"false\"><br></p><h3><em>2D</em> 矩阵</h3><p>虽然 <em>CSS3</em> 为我们提供了上述的变形函数方便我们进行元素的变形操作，但是毕竟函数个数有限，有些效果是没有提供的，例如镜像翻转的效果。此时就轮到 <em>2D</em> 矩阵函数 <em>matrix</em> 登场了。</p><p><br></p><p><em>matrix</em> 有六个参数：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">matrix(a,b,c,d,e,f)</code></pre></div><p>六个参数对应的矩阵：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-141132.png\" alt=\"image-20210919221131755\" contenteditable=\"false\"><br></p><p><br></p><p>这六个参数组成的矩阵与原坐标矩阵相乘计算坐标。计算方式如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-19-141105.png\" alt=\"image-20210919221104828\" contenteditable=\"false\"><br></p><p><br></p><p>什么意思呢 ？<em>x</em> 和 <em>y</em> 是元素中每一个像素的初始原点的坐标，而 <em>x'</em> 和 <em>y'</em> 是通过矩阵变化后得到的新原点坐标。通过中间 <em>3 x 3</em> 变换矩阵，对原先的坐标施加变换，从而得到新的坐标。</p><p><br></p><p><em>x' = ax+cy+e</em>，表示变换后的<strong>水平</strong>坐标</p><p><br></p><p><em>y' = bx+dy+f</em>，表示变换后的<strong>垂直</strong>位置</p><p><br></p><p>在 <em>CSS3</em> 中，上面我们所介绍的所有 <em>2D</em> 变形函数都能够通过这个 <em>matrix</em> 矩阵函数来替代。</p><p><br></p><p><strong>矩阵实现偏移</strong></p><p><br></p><p>我们首先来看通过矩阵实现偏移效果。</p><p><br></p><p>偏移效果前后 <em>x、y</em> 与 <em>x'、y'</em> 所对应的坐标公式为：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>x' = x + 偏移量\ny' = y + 偏移量</code></pre></div><p>套用上面的公式那么各个参数的取值就应该是：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>a = 1; b = 0;\nc = 0; d = 1;\ne = x 偏移量; f = y 偏移量\nx' = ax+cy+e = 1x + 0y + x 偏移量 = x + x 偏移量\ny' = bx+dy+f = 0x + 1y + y 偏移量 = y + y 偏移量</code></pre></div><p>所以换成 <em>matrix</em> 函数就应该是：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>matrix(1, 0, 0, 1, x 偏移量, y 偏移量)</code></pre></div><p>下面来做一个测试：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div&gt;&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div{\n  width: 150px;\n  height: 150px;\n  background-color: red;\n  margin: 150px;\n  transition: all 1s;\n}\ndiv:hover{\n  /* transform: translate(100px, 200px); */\n  transform: matrix(1, 0, 0, 1, 100, 200);\n}</code></pre></div><p>在上面的示例中，使用 <em>translate</em> 和 <em>matrix</em> 两个变形函数的效果一致。</p><p><br></p><p><strong>矩阵实现缩放</strong></p><p><br></p><p>缩放之后  <em>x、y</em> 与 <em>x'、y'</em> 所对应的坐标公式为：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>x' = x * x 缩放倍数\ny’ = y * y 缩放倍数</code></pre></div><p>套用上面的公式那就是：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>a = x缩放倍数; b = 0;\nc = 0; d = y 缩放倍数;\ne = 0; f = 0;\nx' = ax+cy+e = x缩放倍数 * x + 0y + 0 = x缩放倍数 * x\ny' = bx+dy+f = 0x + y 缩放倍数 * y + 0 = y 缩放倍数 * y</code></pre></div><p>所以换成 <em>matrix</em> 函数就应该是：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">matrix(x 缩放倍数, 0, 0, y 缩放倍数, 0, 0);</code></pre></div><p>例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div&gt;&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div{\n  width: 150px;\n  height: 150px;\n  background-color: red;\n  margin: 150px;\n  transition: all 1s;\n}\ndiv:hover{\n  /* transform: scale(2, 2); */\n  transform: matrix(2, 0, 0, 2, 0, 0);\n}</code></pre></div><p>上面的代码我们分别使用 <em>scale</em> 和矩阵实现了相同的缩放效果。</p><p><br></p><p><strong>矩阵实现旋转</strong></p><p><br></p><p>旋转需要实现</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>水平倾斜角度 =  - 垂直倾斜角度</code></pre></div><p>旋转我们用到的变形函数是 <em>rotate(θ)</em>，其中 <em>θ</em> 为旋转的角度。套用上面的公式：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>x' = xcosθ - ysinθ + 0 = xcosθ - ysinθ;\ny' = xsinθ + ycosθ + 0 = xsinθ + ycosθ</code></pre></div><p>转换为 <em>matrix</em> 的代码为：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">matrix(cos(θ), sin(θ), -sin(θ), cos(θ), 0, 0)</code></pre></div><p>例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div&gt;&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div{\n  width: 150px;\n  height: 150px;\n  background-color: red;\n  margin: 150px;\n  transition: all 1s;\n}\ndiv:hover{\n  /* transform: rotate(45deg); */\n  transform: matrix(0.7, 0.7, -0.7, 0.7, 0, 0);\n}</code></pre></div><p>上面的代码使用了 <em>rotate</em> 和 <em>matrix</em> 来实现旋转 <em>45</em> 度的效果。其中 <em>sin45</em> 和 <em>cos45</em> 的值都为 <em>0.7</em>。</p><p><br></p><p><strong>矩阵实现倾斜</strong></p><p><br></p><p><em>skew(θx, θy)</em> 将一个元素按指定的角度在 <em>X</em> 轴和 <em>Y</em> 轴上倾斜。</p><p><br></p><p>倾斜对应的公式为：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>x' = x + ytan(θx) + 0 = x + ytan(θx)\ny' = xtan(θy) + y + 0 = xtan(θy) + y</code></pre></div><p>转换为 <em>matrix</em> 的代码为：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">matrix(1,tan(θy),tan(θx),1,0,0)</code></pre></div><p>例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div&gt;&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div {\n  width: 150px;\n  height: 150px;\n  background-color: red;\n  margin: 150px;\n  transition: all 1s;\n}\n\ndiv:hover {\n  /* transform: skew(20deg); */\n  transform: matrix(1, 0, 0.4, 1, 0, 0);\n}</code></pre></div><p>上面的示例中分别使用 <em>skew</em> 和矩阵 <em>matrix</em> 实现了一致的倾斜效果。</p><p><br></p><p><strong>矩阵实现镜像变形</strong></p><p><br></p><p>前面介绍的效果，<em>CSS3</em> 中都提供了对应的变形函数，但是矩阵真正发挥威力是在没有对应的变形函数时，例如这里要讲的镜像变形。</p><p><br></p><p>我们先来看一下各种镜像变化 <em>x、y</em> 与 <em>x'、y'</em> 所对应的关系：</p><p><br></p><p>水平镜像，就是 <em>y</em> 坐标不变，<em>x</em> 坐标变负</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>x' = -x;\ny' = y;</code></pre></div><p>所以：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>a = -1; b = 0; \nc = 0; d = 1; \ne = 0; f = 0;</code></pre></div><p>具体示例如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div&gt;&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div {\n  width: 300px;\n  height: 200px;\n  margin: 150px;\n  transition: all 1s;\n  background: url('./ok.png') no-repeat;\n  background-position: center;\n  background-size: contain;\n}\n\ndiv:hover {\n  transform: matrix(-1, 0, 0, 1, 0, 0);\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-20-011654.gif\" alt=\"2021-09-20 09.16.38\" contenteditable=\"false\"><br></p><p><br></p><p>垂直镜像，就是 <em>x</em> 坐标不变，<em>y</em> 坐标变负</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>x' = x;\ny' = -y;</code></pre></div><p>所以：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>a = 1; b = 0; \nc = 0; d = -1; \ne = 0; f = 0;</code></pre></div><p>例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">...\ndiv:hover {\n  transform: matrix(1, 0, 0, -1, 0, 0);\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-20-011934.gif\" alt=\"2021-09-20 09.19.11\" contenteditable=\"false\"><br></p><p><br></p><p>水平镜像 + 倒立就是 y 坐标变负，x 坐标变负</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>x' = -x;\ny' = -y;</code></pre></div><p>所以：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>a = -1; b = 0; \nc = 0; d = -1; \ne = 0; f = 0;</code></pre></div><p>例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">...\ndiv:hover {\n  transform: matrix(-1, 0, 0, -1, 0, 0);\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-20-013005.gif\" alt=\"2021-09-20 09.29.45\" contenteditable=\"false\"><br></p><p><br></p><p><em>90</em> 度旋转 + 镜像就是：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>x' = y;\ny' = x;</code></pre></div><p>所以：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>a = 0; b = 1; \nc = 1; d = 0; \ne = 0; f = 0;</code></pre></div><p>例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">...\ndiv:hover {\n  transform: matrix(0, 1, 1, 0, 0, 0);\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-20-013140.gif\" alt=\"2021-09-20 09.31.24\" contenteditable=\"false\"><br></p><p><br></p><p><em>-90</em> 度旋转 + 镜像就是：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>x' = -y;\ny' = -x;</code></pre></div><p>所以：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>a = 0; b = -1; \nc = -1; d = -0; \ne = 0; f = 0;</code></pre></div><p>例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">...\ndiv:hover {\n  transform: matrix(0, -1, -1, 0, 0, 0);\n}</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-20-013304.gif\" alt=\"2021-09-20 09.32.47\" contenteditable=\"false\"><br></p><p><br></p><p>通过上面一系列的示例，我们可以发现，使用矩阵 <em>matrix</em> 函数确实更佳灵活，能够写出各种变形效果。</p><h3><em>3D</em> 变形</h3><p>使用二维变形能够改变元素在水平和垂直轴线，然而还有一个轴沿着它，可以改变元素。使用三维变形，可以改变元素在 <em>Z</em> 轴位置。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-20-024408.png\" alt=\"image-20210920104407743\" contenteditable=\"false\"><br></p><p><br></p><p>三维变换使用基于二维变换的相同属性，如果熟悉二维变换就会发现，<em>3D</em> 变形的功能和 <em>2D</em> 变换的功能类似。CSS3 中的 3D 变换只要包含以下几类：</p><ul><li><p><strong><em>3D</em> 位移</strong>：包括 <em>translateZ</em> 和 <em>translate3d</em> 两个变形函数。</p></li><li><p><strong><em>3D</em> 旋转</strong>：包括 <em>rotateX、rotateY、rotateZ</em> 和 <em>rotate3d</em> 这四个变形函数。</p></li><li><p><strong><em>3D</em> 缩放</strong>：包括 <em>scaleZ</em> 和 <em>sclae3d</em> 两个变形函数。</p></li><li><p><strong><em>3D</em> 矩阵</strong>：和 <em>2D</em> 变形一样，也有一个 <em>3D</em> 矩阵功能函数 <em>matrix3d</em></p></li></ul><h4><em>3D</em> 位移</h4><p>我们直接来看合成变形函数 <em>translate3d</em>，其语法如下：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">translate3d(tx, ty, tz)</code></pre></div><ul><li><p><em>tx</em>：在 <em>X</em> 轴的位移距离。</p></li><li><p><em>ty</em>：在 <em>Y</em> 轴的位移距离。</p></li><li><p><em>tz</em>：在 <em>Z</em> 轴的位移距离。值越大，元素离观察者越近，值越小，元素离观察者越远</p></li></ul><p>来看一个具体的示例：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"container\"&gt;\n  &lt;div class=\"item\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.container{\n  width: 400px;\n  height: 400px;\n  border: 1px solid;\n  margin: 150px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  perspective: 1000px;\n}\n.item {\n  width: 300px;\n  height: 200px;\n  transition: all 1s;\n  background: url('./ok.png') no-repeat;\n  background-position: center;\n  background-size: contain;\n}\n\n.item:hover {\n  transform: translate3d(100px, 100px, -500px)\n}</code></pre></div><p>在上面的代码中，我们设置 <em>div.item</em> 被 <em>hover</em> 的时候进行 <em>3D</em> 位移，也就是 <em>X、Y、Z</em> 轴同时进行移动。注意这里要设置父元素的透视效果，也就是设置 <em>perspective</em> 值，否则看不出 <em>Z</em> 轴的移动效果。效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-20-024039.gif\" alt=\"2021-09-20 10.40.24\" contenteditable=\"false\"><br></p><h4><em>3D</em> 旋转</h4><p>在三维变形中，可以让元素在任何轴旋转，对应的变形函数有 <em>rotateX、rotateY、rotateZ</em> 以及 <em>rotate3d</em>。</p><p><br></p><p>其中 <em>rotate3d</em> 就是前面 <em>3</em> 个变形函数的复合函数。不过出了 <em>x、y、z</em> 这三条轴的参数以外，还接受第四个参数 <em>a</em>，表示旋转角度。</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">rotate3d(x, y, z, a)</code></pre></div><ul><li><p><em>x</em>：可以是 <em>0</em> 到 <em>1</em> 之间的数值，表示旋转轴 <em>X</em> 坐标方向的矢量。</p></li><li><p><em>y</em>：可以是 <em>0</em> 到 <em>1</em> 之间的数值，表示旋转轴 <em>Y</em> 坐标方向的矢量。</p></li><li><p><em>z</em>：可以是 <em>0</em> 到 <em>1</em> 之间的数值，表示旋转轴 <em>Z</em> 坐标方向的矢量。</p></li><li><p><em>a</em>：表示旋转角度。正的角度值表示顺时针旋转，负值表示逆时针旋转。</p></li></ul><p>下面我们以 <em>rotateX</em> 变形函数为例：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"container\"&gt;\n  &lt;div class=\"item\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.container{\n  width: 400px;\n  height: 400px;\n  border: 1px solid;\n  margin: 150px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  perspective: 1000px;\n}\n.item {\n  width: 150px;\n  height: 150px;\n  background-color: red;\n  transition: all 1s;\n}\n\n.item:hover {\n  transform: rotateX(45deg)\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-21-132328.gif\" alt=\"2021-09-21 21.23.14\" contenteditable=\"false\"><br></p><h4><em>3D</em> 缩放</h4><p><em>3D</em> 缩放主要有 <em>sclaeZ</em> 和 <em>scale3d</em>，其中 <em>scale3d</em> 就是 <em>scaleX</em>、<em>scaleY</em> 以及 <em>scaleZ</em> 的复合变形函数。其语法如下：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">scale(sx, sy, sz)</code></pre></div><ul><li><p><em>sx</em>：<em>X</em> 轴上的缩放比例</p></li><li><p><em>sy</em>：<em>Y</em> 轴上的缩放比例</p></li><li><p><em>sz</em>：<em>Z</em> 轴上的缩放比例</p></li></ul><p>但是 <em>scaleX</em> 和 <em>scaleY</em> 变形效果很明显，但是 <em>scaleZ</em>  却基本看不出有什么效果。原因很简单，<em>scaleZ</em> 是 <em>Z</em> 轴上面的缩放，也就是厚度上面的变化，所以如果不是立方体结构，基本上是看不出来 <em>Z</em> 轴上面的缩放效果的。</p><p><br></p><p>一般来讲，我们不会将 <em>scaleZ</em> 和 <em>scale3d</em> 单独使用，因为 <em>scaleZ</em> 和 <em>scale3d</em> 这两个变形函数在单独使用时没有任何效果，需要配合其他的变形函数一起使用时才会有效果。</p><p><br></p><p>这里我们以前面那个立方体为例，如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"box\"&gt;\n  &lt;div class=\"up\"&gt;上&lt;/div&gt;\n  &lt;div class=\"down\"&gt;下&lt;/div&gt;\n  &lt;div class=\"left\"&gt;左&lt;/div&gt;\n  &lt;div class=\"right\"&gt;右&lt;/div&gt;\n  &lt;div class=\"forword\"&gt;前&lt;/div&gt;\n  &lt;div class=\"back\"&gt;后&lt;/div&gt;\n&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.box {\n  width: 250px;\n  height: 250px;\n  border: 1px dashed red;\n  margin: 100px auto;\n  position: relative;\n  border-radius: 50%;\n  transform-style: preserve-3d;\n  transition: all 1s;\n  transform: rotateX(45deg) rotateY(45deg);\n}\n\n.box:hover{\n  transform: rotateX(45deg) rotateY(45deg) scaleZ(.5);\n}\n\n.box&gt;div {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  text-align: center;\n  line-height: 250px;\n  font-size: 60px;\n  color: #daa520;\n}\n\n.left {\n  background-color: rgba(255, 0, 0, 0.3);\n  transform-origin: left;\n  transform: rotateY(90deg) translateX(-125px);\n}\n\n.right {\n  background: rgba(0, 0, 255, 0.3);\n  transform-origin: right;\n  /* 变换*/\n  transform: rotateY(90deg) translateX(125px);\n}\n\n.forward {\n  background: rgba(255, 255, 0, 0.3);\n  transform: translateZ(125px);\n}\n\n.back {\n  background: rgba(0, 255, 255, 0.3);\n  transform: translateZ(-125px);\n}\n\n.up {\n  background: rgba(255, 0, 255, 0.3);\n  transform: rotateX(90deg) translateZ(125px);\n}\n\n.down {\n  background: rgba(99, 66, 33, 0.3);\n  transform: rotateX(-90deg) translateZ(125px);\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-21-143413.gif\" alt=\"2021-09-21 22.33.57\" contenteditable=\"false\"><br></p><h3><em>3D</em> 矩阵</h3><p><em>CSS3</em> 中的 <em>3D</em> 矩阵比 <em>2D</em> 矩阵复杂，从二维到三维，在矩阵里 3*3 变成 4*4，即 <em>9</em> 到 <em>16</em>。</p><p><br></p><p>对于 <em>3D</em> 矩阵而言，本质上很多东西与 <em>2D</em> 是一致的，只是复杂程度不一样而已。</p><p><br></p><p>对于 <em>3D</em> 缩放效果，其矩阵如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-21-145039.png\" alt=\"image-20210921225039133\" contenteditable=\"false\"><br></p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">matrix3d(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1)</code></pre></div><p>倾斜是二维变形，不能在三维空间变形。元素可能会在 <em>X</em> 轴和 <em>Y</em> 轴倾斜，然后转化为三维，但它们不能在 <em>Z</em> 轴倾斜。</p><p><br></p><p>这里举几个 <em>3D</em> 矩阵的例子：</p><p><br></p><p><em>translate3d(tx,ty,tz)</em> 等价于 <em>matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,tx,ty,tz,1)</em></p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-21-145544.png\" alt=\"image-20210921225544059\" contenteditable=\"false\"><br></p><p><br></p><p><em>scale3d(sx,sy,sz)</em> 等价于 <em>matrix3d(sx,0,0,0,0,sy,0,0,0,0,sz,0,0,0,0,1)</em></p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-21-145618.png\" alt=\"image-20210921225617731\" contenteditable=\"false\"><br></p><p><br></p><p><em>rotate3d(x,y,z,a)</em> 真是得搬出高中数学书好好复习一下了，第四个参数 <em>alpha</em> 用于 <em>sc</em> 和 <em>sq</em> 中</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-21-145731.png\" alt=\"image-20210921225731310\" contenteditable=\"false\"><br></p><p><br></p><p>等价于...你自己从上到下，从左到右依次将参数搬入 <em>matrix3d</em> 中吧。</p><p><br></p><p>当然除非是库函数需要，否则我严重怀疑是否会有人放着 <em>rotate3d</em> 不用，偏要去挑战用 <em>matrix3d</em> 模拟 <em>rotate3d</em>。</p><h2>真题解答</h2><ul><li><p>请简述一下 <em>CSS3</em> 中新增的变形如何使用？</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>在 <em>CSS3</em> 中的变形分为 <em>2D</em> 变形和 <em>3D</em> 变形。</p><p><br></p><p>整体可以划分出 <em>3</em> 大类：</p><ul><li><p>具有 <em>X/Y</em> 的函数：<em>translateX、translateY、sclaeX、scaleY、skewX、skewY</em></p></li><li><p><em>2D</em> 变形函数：<em>translate、sclae、rotate、skew、matrix</em></p></li><li><p><em>3D</em> 变形函数：<em>rotateX、rotateY、rotate3d、translateZ、translate3d、scaleZ、scale3d、matrix3d</em></p></li></ul><p>另外，还有一些重要的变形属性，例如：</p><ul><li><p><strong><em>transform</em> 属性</strong></p></li><li><p><strong><em>transform-origin</em> 属性</strong></p></li><li><p><strong><em>transform-style</em> 属性</strong></p></li><li><p><strong><em>perspective</em> 属性</strong></p></li><li><p><strong><em>perspective-origin</em> 属性</strong></p></li><li><p><strong><em>backface-visibility</em> 属性</strong></p></li></ul></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666076346351",
  "typeId": {
    "$oid": "634d7fc47797638ec96fe2ee"
  }
},
{
  "_id": {
    "$oid": "634e4eef2fac4881713db32c"
  },
  "interviewTitle": "什么是渐进式渲染 ？",
  "interviewContent": "<h1>渐进式渲染</h1><h2>经典真题</h2><ul><li><p>什么是渐进式渲染 ？</p></li></ul><h2>渐进式渲染</h2><p>渐进式渲染，英文全称 <em>progressive rendering</em>，也被称之为惰性渲染，指的是为了提高用户感知的加载速度，以尽快的速度来呈现页面的技术。</p><p><br></p><p>在以前互联网带宽较小的时期，这种技术更为普遍。如今，移动终端的盛行，而移动网络往往不稳定，渐进式渲染在现代前端开发中仍然有用武之地。</p><p><br></p><p>有一点需要弄明白的是，这不是指的某一项技术，而是各种技术的一种集合。</p><p><br></p><p>例如：</p><p><br></p><p><strong>骨架屏</strong></p><p><br></p><p>在加载网络数据时，为了提升用户体验，通常会使用一个转圈圈的 <em>loading</em> 动画，或者使用 <em>Skeleton Screen</em> 占位。相比与 <em>loading</em> 动画，<em>Skeleton Screen</em> 的效果要更生动</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-13-081721.png\" alt=\"image-20210913161720022\" contenteditable=\"false\"><br></p><p><br></p><p><strong>图片懒加载</strong></p><p><br></p><p>所谓图片懒加载，顾名思义，就是先加载部分图片，剩余的图片等到需要的时候再加载。这在电商网站中尤其常见。</p><p><br></p><p>比如一个电商网站，首屏通常会有很多的数据，清晰度较高的 <em>banner</em> 或轮播。页面非首屏部分会员很多商品夹杂着大量的图片。这是时候选择懒加载以保证首屏的流畅十分重要。</p><p><br></p><p><strong>图片占位符</strong></p><p><br></p><p>在网页加载的时候，某些图片还在请求中或者还未请求，这个时候就先找一个临时代替的图像，放在最终图像的位置上，但是这只是临时替代的图形，当图片数据准备好以后，会重新渲染真正的图形数据。</p><p><br></p><p><strong>拆分网页资源</strong></p><p><br></p><p>大部分用户不会用到一个网站的所有页面，但我们通常的做法却是把所有的功能都打包进一个很大的文件里面。一个 <em>bundle.js</em> 文件的大小可能会有几  <em>M</em>，一个打包后的  <em>style.css</em>  会包含网站的一切样式，从  <em>CSS</em>  结构定义到网站在各个版本的样式：移动端、平板、桌面、打印版等等。</p><p><br></p><p>但用户并不是一开始就需要所有的资源，所有我们可以对资源进行拆分，首先加载那些关键的资源，其他的资源等到需要的时候再去加载它。</p><p><br></p><p>更多的关于渐进式渲染的内容，可以参阅 <em>MDN</em>：<em>https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps/Loading</em></p><h2>真题解答</h2><ul><li><p>什么是渐进式渲染 ？</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>渐进式渲染，英文全称 <em>progressive rendering</em>，也被称之为惰性渲染，指的是为了提高用户感知的加载速度，以尽快的速度来呈现页面的技术。但是这并不是某一项技术的特指，而是一系列技术的集合。</p><p><br></p><p>例如：</p><ul><li><p>骨架屏</p></li><li><p>图片懒加载</p></li><li><p>图片占位符</p></li><li><p>资源拆分</p></li></ul></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666076399623",
  "typeId": {
    "$oid": "634d7fc47797638ec96fe2ee"
  }
},
{
  "_id": {
    "$oid": "634e4f152fac4881713db330"
  },
  "interviewTitle": "总结一下如何提升或者优化 CSS 的渲染性能",
  "interviewContent": "<h1><em>CSS</em> 渲染性能优化</h1><h2>经典真题</h2><ul><li><p>总结一下如何提升或者优化 <em>CSS</em> 的渲染性能</p></li></ul><h2><em>CSS</em> 渲染性能优化</h2><p>很多人往往不重视性能优化这一块，觉得功能做出来就行了。</p><p><br></p><p>诚然，在软件开发过程中，功能确实是优先要考虑的，但是当功能完善后，接下来就需要考虑性能问题了。</p><p><br></p><p>我们可以从两个方面来看性能优化的意义：</p><ol><li><p>用户角度</p><p>网站优化能够让页面加载得更快，响应更加及时，极大提升用户体验。</p></li><li><p>服务商角度</p><p>优化会减少页面资源请求数，减小请求资源所占带宽大小，从而节省可观的带宽资源。</p></li></ol><p>网站优化的目标就是减少网站加载时间，提高响应速度。</p><p><br></p><p>那么网站加载速度和用户体验又有着怎样的关系呢？我们来看下面这张图：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-041118.png\" alt=\"image-20210916121117684\" contenteditable=\"false\"><br></p><p><br></p><p><em>Google</em> 和亚马逊的研究表明，<em>Google</em> 页面加载的时间从 <em>0.4</em> 秒提升到 <em>0.9</em> 秒导致丢失了 <em>20%</em> 流量和广告收入，对于亚马逊，页面加载时间每增加 <em>100ms</em> 就意味着 <em>1%</em> 的销售额损失。</p><p><br></p><p>可见，页面的加载速度对于用户有着至关重要的影响。</p><p><br></p><p>一个好的交互效果可能是这样的：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-041314.png\" alt=\"image-20210916121313325\" contenteditable=\"false\"><br></p><p><br></p><p>当然，性能优化是来自方方面面的。</p><p><br></p><p>这里我们主要来看 <em>CSS</em> 方面能够进行哪些性能优化。</p><p><br></p><p>1.使用 <code data-backticks=\"1\">id selector</code> 非常的高效。在使用 <code data-backticks=\"1\">id selector</code> 的时候需要注意一点：因为 <code data-backticks=\"1\">id</code> 是唯一的，所以不需要既指定 <code data-backticks=\"1\">id</code> 又指定 <code data-backticks=\"1\">tagName</code>：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">/* Bad  */\np#id1 {color:red;}  \n\n/* Good  */\n#id1 {color:red;}</code></pre></div><p>2.避免深层次的 <code data-backticks=\"1\">node</code> ，譬如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">/* Bad  */\ndiv &gt; div &gt; div &gt; p {color:red;} \n/* Good  */\np-class{color:red;}</code></pre></div><p>3.不要使用 <code data-backticks=\"1\">attribute selector</code>，如：p[att1=”val1”]。这样的匹配非常慢。更不要这样写：<code data-backticks=\"1\">p[id=\"id1\"]</code>。这样将 <code data-backticks=\"1\">id selector</code> 退化成 <code data-backticks=\"1\">attribute selector</code>。</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">/* Bad  */\np[id=\"jartto\"]{color:red;}  \np[class=\"blog\"]{color:red;}  \n/* Good  */\n#jartto{color:red;}  \n.blog{color:red;}</code></pre></div><p>4.通常将浏览器前缀置于前面，将标准样式属性置于最后，类似：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.foo {\n  -moz-border-radius: 5px;\n  border-radius: 5px;\n}</code></pre></div><p>这里推荐参阅 <em>CSS</em> 规范-优化方案：<em>http://nec.netease.com/standard/css-optimize.html</em></p><p><br></p><p>5.遵守 <em>CSSLint</em> 规则</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">font-faces        　　　　  　　　不能使用超过5个web字体\nimport        　　　　　　　 　　  禁止使用@import\nregex-selectors        　　　　  禁止使用属性选择器中的正则表达式选择器\nuniversal-selector    　　 　　  禁止使用通用选择器*\nunqualified-attributes    　　　禁止使用不规范的属性选择器\nzero-units            　　 　　　0后面不要加单位\noverqualified-elements    　　　使用相邻选择器时，不要使用不必要的选择器\nshorthand        　　　　　　　　 简写样式属性\nduplicate-background-images    相同的url在样式表中不超过一次</code></pre></div><p>更多的 <em>CSSLint</em> 规则可以参阅：<em>https://github.com/CSSLint/csslint</em></p><p><br></p><p>6.不要使用 <code data-backticks=\"1\">@import</code></p><p><br></p><p>使用 <code data-backticks=\"1\">@import</code> 引入 <code data-backticks=\"1\">CSS</code> 会影响浏览器的并行下载。使用 <code data-backticks=\"1\">@import</code> 引用的 <code data-backticks=\"1\">CSS</code> 文件只有在引用它的那个 <code data-backticks=\"1\">CSS</code> 文件被下载、解析之后，浏览器才会知道还有另外一个 <code data-backticks=\"1\">CSS</code> 需要下载，这时才去下载，然后下载后开始解析、构建 <code data-backticks=\"1\">Render Tree</code> 等一系列操作。</p><p><br></p><p>多个 <code data-backticks=\"1\">@import</code> 会导致下载顺序紊乱。在 <code data-backticks=\"1\">IE</code> 中，<code data-backticks=\"1\">@import</code> 会引发资源文件的下载顺序被打乱，即排列在 <code data-backticks=\"1\">@import</code> 后面的 <code data-backticks=\"1\">JS</code> 文件先于 <code data-backticks=\"1\">@import</code> 下载，并且打乱甚至破坏 <code data-backticks=\"1\">@import</code> 自身的并行下载。</p><p><br></p><p>7.避免过分重排（<em>Reflow</em>）</p><p>所谓重排就是浏览器重新计算布局位置与大小。常见的重排元素：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">width \nheight \npadding \nmargin \ndisplay \nborder-width \nborder \ntop \nposition \nfont-size \nfloat \ntext-align \noverflow-y \nfont-weight \noverflow \nleft \nfont-family \nline-height \nvertical-align \nright \nclear \nwhite-space \nbottom \nmin-height</code></pre></div><p>8.依赖继承。如果某些属性可以继承，那么自然没有必要在写一遍。</p><h2>真题解答</h2><ul><li><p>总结一下如何提升或者优化 <em>CSS</em> 的渲染性能</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p><em>CSS</em> 渲染性能的优化来自方方面面，这里列举一些常见的方式：</p><ol><li><p>使用 <em>id</em> 选择器非常高效，因为 <em>id</em> 是唯一的</p></li><li><p>避免深层次的选择器嵌套</p></li><li><p>尽量避免使用属性选择器，因为匹配速度慢</p></li><li><p>使用渐进增强的方案</p></li><li><p>遵守 <em>CSSLint</em> 规则</p></li><li><p>不要使用 <code data-backticks=\"1\">@import</code></p></li><li><p>避免过分重排（<em>Reflow</em>）</p></li><li><p>依赖继承</p></li><li><p>值缩写</p></li><li><p>避免耗性能的属性</p></li><li><p>背景图优化合并</p></li><li><p>文件压缩</p></li></ol></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666076437700",
  "typeId": {
    "$oid": "634d7fc47797638ec96fe2ee"
  }
},
{
  "_id": {
    "$oid": "634e4f782fac4881713db334"
  },
  "interviewTitle": "是否了解过 CSS3 中的遮罩",
  "interviewContent": "<h1><em>CSS3</em> 遮罩</h1><p>本文主要包含以下内容：</p><ul><li><p><em>CSS3</em> 遮罩介绍</p></li><li><p>遮罩各属性介绍</p></li></ul><h2><em>CSS3</em> 遮罩介绍</h2><p><em>CSS mask</em> 遮罩属性的历史非常久远了，远到比 <em>CSS3 border-radius</em> 等属性还要久远，最早是出现在 <em>Safari</em> 浏览器上的，差不多可以追溯到 <em>2009</em> 年。</p><p><br></p><p>不过那个时候，遮罩只能作为实验性的属性，做一些特效使用。毕竟那个年代还是 <em>IE</em> 浏览器的时代，属性虽好，但价值有限。</p><p><br></p><p>但是如今情况却大有变化，除了 <em>IE</em> 浏览器不支持，<em>Firefox、Chrome、Edge</em> 以及移动端等都已经全线支持，其实际应用价值已不可同日而语。</p><p><br></p><p>尤其 <em>Firefox</em> 浏览器，从版本 <em>53</em> 开始，已经全面支持了 <em>CSS3 mask</em> 属性。并且 <em>mask</em> 属性规范已经进入候选推荐规范之列，会说以后进入既定规范标准已经是板上钉钉的事情，大家可以放心学习，将来必有用处。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-25-145725.png\" alt=\"image-20211025225724975\" contenteditable=\"false\"><br></p><p><br></p><p>（图为 <em>caniuse</em> 上各浏览器对 <em>CSS mask</em> 的支持情况）</p><h2>快速入门示例</h2><p>下面，我们来看一个 <em>CSS mask</em> 的快速入门示例。</p><p><br></p><p>首先需要准备两张图片，图片素材如下：</p><p><br></p><p>一张 <em>jpg</em> 图片：<em>zelda.jpg</em></p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-25-151154.png\" alt=\"image-20211025231154694\" contenteditable=\"false\"><br></p><p><br></p><p>一张 <em>png</em> 图片：<em>mask.png</em>，该 <em>png</em> 图片背景为透明（这里划重点）</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-25-151236.png\" alt=\"image-20211025231236440\" contenteditable=\"false\"><br></p><p><br></p><p>接下来准备我们的测试目录：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-25-151518.png\" alt=\"image-20211025231518012\" contenteditable=\"false\"><br></p><p><br></p><p><em>index.html</em> 代码如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div class=\"mask\"&gt;&lt;/div&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">* {\n  margin: 0;\n  padding: 0;\n}\n\ndiv {\n  width: 1200px;\n  height: 600px;\n  outline: 1px solid;\n  margin: 50px auto;\n  background: url('./zelda.jpg') no-repeat center/cover;\n}\n\n/*  \n  虽然 .mask 和 div 都是选择中的相同的元素\n  这里为了单独观察 mask 相关设置，\n  和 mask 不相关的属性设置放入到了 div 选择器中 \n*/\n.mask {\n  -webkit-mask-image: url('./mask.png');\n}</code></pre></div><p>在上面的代码中，我们为 <em>div</em> 设置了一个铺满整个盒子的背景图，然后为该盒子设置了遮罩效果。由于 <em>mask.png</em> 无法占满整个盒子，所以出现了重复的效果，<strong><em>mask.png</em> 遮罩图片透明的部分不会显示底部图片的信息，而非透明部分则会显示底层图片信息</strong>。</p><p><br></p><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-25-151805.png\" alt=\"image-20211025231804573\" contenteditable=\"false\"><br></p><p><br></p><p>除了设置透明的 <em>png</em> 图片，还可以设置透明的渐变。例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.mask {\n  -webkit-mask-image: linear-gradient(transparent 10%, white);\n}</code></pre></div><p>在上面的代码中，我们设置了一个从上到下的线性透明渐变，效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-26-013708.png\" alt=\"image-20211026093708467\" contenteditable=\"false\"><br></p><p><br></p><p>可以看到，无论是设置图片还是渐变，一定要有透明的部分，否则无法起到遮罩的效果，例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.mask {\n  -webkit-mask-image: linear-gradient(red,blue);\n}</code></pre></div><p>上面的代码中，我们设置的是一个红到蓝的渐变，没有任何的透明部分，所以遮罩层不会起作用，底图会原封不动的显示出来。</p><h2>遮罩各属性介绍</h2><p>在上面的快速入门示例中，我们用到的是 <em>mask-image</em> 属性，但是除了该属性外，<em>CSS mask</em> 还有很多其他的属性，如下：</p><ul><li><p><em>mask-image</em></p></li><li><p><em>mask-mode</em></p></li><li><p><em>mask-repeat</em></p></li><li><p><em>mask-position</em></p></li><li><p><em>mask-clip</em></p></li><li><p><em>mask-origin</em></p></li><li><p><em>mask-size</em></p></li><li><p><em>mask-type</em></p></li><li><p><em>mask-composite</em></p></li></ul><p>下面我们来针对每个属性进行介绍。</p><h4><em>mask-image</em></h4><p>该属性在上面的快速入门示例中我们已经体验过了，默认值为 <em>none</em>，表示没有遮罩图片。</p><p><br></p><p>可以设置的值为透明图片，或透明渐变。</p><h4><em>mask-repeat</em></h4><p>表示遮罩层是否允许重复，默认值为 <em>repeat</em> 允许重复，可选值与 <em>background-repeat</em> 相同。</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.mask {\n  -webkit-mask-image: url('./mask.png');\n  -webkit-mask-repeat: no-repeat;\n}</code></pre></div><p>上面的代码中，我们设置遮罩层的重复行为是 <em>x、y</em> 轴都不重复，效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-26-015113.png\" alt=\"image-20211026095112536\" contenteditable=\"false\"><br></p><p><br></p><p>（红框是为了表示整张图片的大小，并非浏览器实际显示情况）</p><h4><em>mask-position</em></h4><p>该属性用于设置遮罩层的位置，默认值为<em>0 0</em> 在最左上角，可选值与 <em>background-position</em> 相同。</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.mask {\n  -webkit-mask-image: url('./mask.png');\n  -webkit-mask-repeat: no-repeat;\n  -webkit-mask-position: center;\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-26-015730.png\" alt=\"image-20211026095730053\" contenteditable=\"false\"><br></p><p><br></p><p>（红框是为了表示整张图片的大小，并非浏览器实际显示情况）</p><h4><em>mask-size</em></h4><p>该属性用于设置遮罩层的大小，默认值为 <em>auto</em>，可选值与 <em>background-size</em> 相同，如下表：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-26-021622.png\" alt=\"image-20211026101622232\" contenteditable=\"false\"><br></p><p><br></p><p>例如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.mask {\n  -webkit-mask-image: url('./mask.png');\n  -webkit-mask-repeat: no-repeat;\n  -webkit-mask-position: center;\n  -webkit-mask-size: contain;\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-26-021901.png\" alt=\"image-20211026101900926\" contenteditable=\"false\"><br></p><p><br></p><p>（红框是为了表示整张图片的大小，并非浏览器实际显示情况）</p><h4><em>mask-origin</em></h4><p>默认值为 <em>border-box</em>，可选值与 <em>background-origin</em> 相同，可以设置如下的属性值：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-26-020115.png\" alt=\"image-20211026100114147\" contenteditable=\"false\"><br></p><p><br></p><p>下面为了显示其效果，我们需要稍微对其他样式做一些改变，如下：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">div {\n  width: 1200px;\n  height: 600px;\n  border: 100px solid;\n  margin: 50px auto;\n  background: url('./zelda.jpg') no-repeat center/cover;\n}\n\n/*  \n虽然 .mask 和 div 都是选择中的相同的元素\n这里为了单独观察 mask 相关设置，\n和 mask 不相关的属性设置放入到了 div 选择器中 \n*/\n.mask {\n  -webkit-mask-image: url('./mask.png');\n  -webkit-mask-repeat: no-repeat;\n}</code></pre></div><p>在上面的代码中，我们为该 <em>div</em> 设置了一个宽度为 <em>100px</em> 的 <em>border</em>，由于 <em>mask-origin</em> 的默认值为 <em>border-box</em>，所以我们可以看到如下的效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-26-020928.png\" alt=\"image-20211026100927087\" contenteditable=\"false\"><br></p><p><br></p><p>（红框是为了表示整张图片的大小，并非浏览器实际显示情况）</p><p><br></p><p>此时如果设置 <em>mask-origin</em> 的值为 <em>centent-box</em>，遮罩层图像就会相对于内容框来定位。</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.mask {\n  -webkit-mask-image: url('./mask.png');\n  -webkit-mask-repeat: no-repeat;\n  -webkit-mask-origin: content-box;\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-26-021239.png\" alt=\"image-20211026101238881\" contenteditable=\"false\"><br></p><p><br></p><p>（外层的黑框表示该 <em>div</em> 的 <em>border</em>，红框表示该 <em>div</em> 的内容区域，并非浏览器实际显示情况）</p><h4><em>mask-clip</em></h4><p>默认值为 <em>border-box</em>，可选值与 <em>background-clip</em> 相同，可以设置如下属性值：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-26-025300.png\" alt=\"image-20211026105259969\" contenteditable=\"false\"><br></p><p><br></p><p>我们同样为 <em>div</em> 设置一个宽度为 <em>100px</em> 的 <em>border</em>，由于默认值为 <em>border-box</em>，所以我们看到的效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-26-025412.png\" alt=\"image-20211026100927087\" contenteditable=\"false\"><br></p><p><br></p><p>（红框是为了表示整张图片的大小，并非浏览器实际显示情况）</p><p><br></p><p>接下来设置 <em>mask-clip</em> 为 <em>content-box</em></p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.mask {\n  -webkit-mask-image: url('./mask.png');\n  -webkit-mask-repeat: no-repeat;\n  -webkit-mask-clip: content-box;\n}</code></pre></div><p>由于 <em>mask-origin</em> 默认值为 <em>border-box</em>，所以遮罩层以边框盒来定位，之后我们设置了 <em>mask-clip</em> 为 <em>content-box</em>，表示以内容框来进行裁剪。效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-26-025533.png\" alt=\"image-20211026105532851\" contenteditable=\"false\"><br></p><p><br></p><p>（外层的黑框表示该 <em>div</em> 的 <em>border</em>，红框表示该 <em>div</em> 的内容区域，并非浏览器实际显示情况）</p><h4><em>mask-mode</em></h4><p><em>mask-mode</em> 属性默认值为 <em>match-source</em>，作用是根据资源的类型自动采用合适的遮罩模式。</p><p><br></p><p>例如，如果遮罩效果使用的是 <em>SVG</em> 中的 &lt;<em>mask</em>&gt; 元素，则此时的 <em>mask-mode</em> 属性的值为 <em>luminance</em>，表示基于亮度来判断是否要进行遮罩。</p><p><br></p><p>如果是其他场景，则计算值是 <em>alpha</em>，表示基于透明度判断是否要进行遮罩。</p><p><br></p><p>因此 <em>mask-mode</em> 可选值为 <em>alpha、luminance、match-source</em>。</p><p><br></p><p>使用搜索引擎搜索遮罩素材的时候，往往搜索的结果都是白底的 <em>JPG</em> 图片，因此使用默认的遮罩模式是没有预期的遮罩效果的。此时就非常适合设置遮罩模式为 <em>luminance</em>。</p><p><br></p><p>另外，目前仅 <em>Firefox</em> 浏览器支持 <em>mask-mode</em> 属性，<em>Chrome</em> 浏览器并不提供支持，但是可以使用非标准的 <em>mask-source-type</em> 属性来进行替代（没有私有前缀）。</p><p><br></p><p>下面来看一个简单的示例。首先我们需要扩充我们的遮罩素材，准备了一张 <em>mask2.jpg</em> 的遮罩图片，该素材首先是 <em>jpg</em> 格式的，其次并没有透明区域，仅有一些白底区域。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-26-032617.png\" alt=\"image-20211026112617175\" contenteditable=\"false\"><br></p><p><br></p><p>接下来设置如下的代码：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.mask {\n  -webkit-mask-image: url('./mask2.jpg');\n  -webkit-mask-repeat: no-repeat;\n  -webkit-mask-position: center;\n  mask-mode: luminance;\n}</code></pre></div><p>在上面的代码中，我们设置 <em>mask-mode</em> 的值为 <em>luminance</em>，表示基于亮度来判断是否进行遮罩。</p><p><br></p><p>在 <em>Firefox</em> 浏览器中的效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-26-032916.png\" alt=\"image-20211026112915034\" contenteditable=\"false\"><br></p><p><br></p><p>（红框是为了表示整张图片的大小，并非浏览器实际显示情况）</p><h4><em>mask-type</em></h4><p><em>mask-type</em> 属性的功能和 <em>mask-mode</em> 属性类似，都是设置不同的遮罩模式，但还是有一个很大的区别，就是 <em>mask-type</em> 属性只能作用于 <em>SVG</em> 元素上，因为其本质上是由 <em>SVG</em> 属性演变而来的，<em>Chrome</em> 等浏览器也都支持该属性。而 <em>mask-mode</em> 是一个针对所有元素类型的 <em>CSS</em> 属性，<em>Chrome</em> 等浏览器并不支持该属性，目前仅只有 <em>Firefox</em> 浏览器对其提供支持。</p><p><br></p><p>由于 <em>mask-type</em> 属性只能作用于 <em>SVG</em> 元素上，因此默认值表现为 <em>SVG</em> 元素默认遮罩模式，也就是默认值是 <em>luminance</em> 亮度遮罩模式。如果需要支持透明度遮罩模式，可以这么设置：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">mask-type: alpha;</code></pre></div><h4><em>mask-composite</em></h4><p><em>mask-composite</em> 属性表示同时使用多张图片进行遮罩时的合成方式。默认值为 <em>add</em>，可选值为 <em>add、subtract、intersect、exclude</em>。</p><ul><li><p><em>mask-composite: add</em>：表示遮罩累加，这是默认值</p></li><li><p><em>mask-composite: subtract</em>：表示遮罩相减，也就是遮罩图片重合的区域不显示，这就意味着，遮罩层图片越多，遮罩区域越小。</p></li><li><p><em>mask-composite: intersect</em>：表示遮罩相交，也就是遮罩图片重合的区域才显示遮罩。</p></li><li><p><em>mask-composite: exclude</em>：表示遮罩排除，也就是遮罩图片重合的区域会被当作透明。</p></li></ul><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666076536138",
  "typeId": {
    "$oid": "634d7fc47797638ec96fe2ee"
  }
},
{
  "_id": {
    "$oid": "634e4fb82fac4881713db33b"
  },
  "interviewTitle": "什么是 CSS 中的包含块？",
  "interviewContent": "<h1>你不知道的 CSS 之包含块</h1><p>一说到 CSS 盒模型，这是很多小伙伴耳熟能详的知识，甚至有的小伙伴还能说出 border-box 和 content-box 这两种盒模型的区别。</p><p><br></p><p>但是一说到 CSS 包含块，有的小伙伴就懵圈了，什么是包含块？好像从来没有听说过这玩意儿。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-142005.png\" alt=\"image-20220814222004395\" contenteditable=\"false\"><br></p><p><br></p><p>好吧，如果你对包含块的知识一无所知，那么系好安全带，咱们准备出发了。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-060434.png\" alt=\"image-20220813140434032\" contenteditable=\"false\"><br></p><p><br></p><p>包含块英语全称为<strong>containing block</strong>，实际上平时你在书写 CSS 时，大多数情况下你是感受不到它的存在，因此你不知道这个知识点也是一件很正常的事情。但是这玩意儿是确确实实存在的，在 CSS 规范中也是明确书写了的：</p><p><br></p><p><em>https://drafts.csswg.org/css2/#containing-block-details</em></p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-142459.png\" alt=\"image-20220814222458695\" contenteditable=\"false\"><br></p><p><br></p><p>并且，如果你不了解它的运作机制，有时就会出现一些你认为的莫名其妙的现象。</p><p><br></p><p>那么，这个包含块究竟说了什么内容呢？</p><p><br></p><p>说起来也简单，<strong>就是元素的尺寸和位置，会受它的包含块所影响。对于一些属性，例如 width, height, padding, margin，绝对定位元素的偏移值（比如 position 被设置为 absolute 或 fixed），当我们对其赋予百分比值时，这些值的计算值，就是通过元素的包含块计算得来。</strong></p><p><br></p><p>来吧，少年，让我们从最简单的 case 开始看。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-143153.png\" alt=\"image-20220814223152726\" contenteditable=\"false\"><br></p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;body&gt;\n  &lt;div class=\"container\"&gt;\n    &lt;div class=\"item\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/body&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.container{\n  width: 500px;\n  height: 300px;\n  background-color: skyblue;\n}\n.item{\n  width: 50%;\n  height: 50%;\n  background-color: red;\n}</code></pre></div><p>请仔细阅读上面的代码，然后你认为 div.item 这个盒子的宽高是多少？</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-143451.png\" alt=\"image-20220814223451349\" contenteditable=\"false\"><br></p><p><br></p><p>相信你能够很自信的回答这个简单的问题，div.item 盒子的 width 为 250px，height 为 150px。</p><p><br></p><p>这个答案确实是没有问题的，但是如果我追问你是怎么得到这个答案的，我猜不了解包含块的你大概率会说，因为它的父元素 div.container 的 width 为 500px，50% 就是 250px，height 为 300px，因此 50% 就是 150px。</p><p><br></p><p>这个答案实际上是不准确的。正确的答案应该是，<strong>div.item 的宽高是根据它的包含块来计算的</strong>，而这里包含块的大小，正是这个元素最近的祖先块元素的内容区。</p><p><br></p><p>因此正如我前面所说，<strong>很多时候你都感受不到包含块的存在。</strong></p><p><br></p><p>包含块分为两种，一种是根元素（HTML 元素）所在的包含块，被称之为初始包含块（<strong>initial containing block</strong>）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。</p><p><br></p><p>另外一种是对于非根元素，对于非根元素的包含块判定就有几种不同的情况了。大致可以分为如下几种：</p><ul><li><p>如果元素的 positiion 是 relative 或 static ，那么包含块由离它最近的块容器（block container）的内容区域（content area）的边缘建立。</p></li><li><p>如果 position 属性是 fixed，那么包含块由视口建立。</p></li><li><p>如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。</p></li></ul><p>前面两条实际上都还比较好理解，第三条往往是初学者容易比较忽视的，我们来看一个示例：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;body&gt;\n    &lt;div class=\"container\"&gt;\n      &lt;div class=\"item\"&gt;\n        &lt;div class=\"item2\"&gt;&lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.container {\n  width: 500px;\n  height: 300px;\n  background-color: skyblue;\n  position: relative;\n}\n.item {\n  width: 300px;\n  height: 150px;\n  border: 5px solid;\n  margin-left: 100px;\n}\n.item2 {\n  width: 100px;\n  height: 100px;\n  background-color: red;\n  position: absolute;\n  left: 10px;\n  top: 10px;\n}</code></pre></div><p>首先阅读上面的代码，然后你能在脑海里面想出其大致的样子么？或者用笔和纸画一下也行。</p><p><br></p><p>公布正确答案：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-153548.png\" alt=\"image-20220814233548188\" contenteditable=\"false\"><br></p><p><br></p><p>怎么样？有没有和你所想象的对上？</p><p><br></p><p>其实原因也非常简单，根据上面的第三条规则，对于 div.item2 来讲，它的包含块应该是 div.container，而非 div.item。</p><p><br></p><p>如果你能把上面非根元素的包含块判定规则掌握，那么关于包含块的知识你就已经掌握 80% 了。</p><p><br></p><p>实际上对于非根元素来讲，包含块还有一种可能，那就是如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：</p><ul><li><p>transform 或 perspective 的值不是 none</p></li><li><p>will-change 的值是 transform 或 perspective</p></li><li><p>filter 的值不是 none 或 will-change 的值是 filter(只在 Firefox 下生效).</p></li><li><p>contain 的值是 paint (例如: contain: paint;)</p></li></ul><p>我们还是来看一个示例：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;body&gt;\n  &lt;div class=\"container\"&gt;\n    &lt;div class=\"item\"&gt;\n      &lt;div class=\"item2\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/body&gt;</code></pre></div><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.container {\n  width: 500px;\n  height: 300px;\n  background-color: skyblue;\n  position: relative;\n}\n.item {\n  width: 300px;\n  height: 150px;\n  border: 5px solid;\n  margin-left: 100px;\n  transform: rotate(0deg); /* 新增代码 */\n}\n.item2 {\n  width: 100px;\n  height: 100px;\n  background-color: red;\n  position: absolute;\n  left: 10px;\n  top: 10px;\n}</code></pre></div><p>我们对于上面的代码只新增了一条声明，那就是 transform: rotate(0deg)，此时的渲染效果却发生了改变，如下图所示：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154347.png\" alt=\"image-20220814234347149\" contenteditable=\"false\"><br></p><p><br></p><p>可以看到，此时对于 div.item2 来讲，包含块就变成了 div.item。</p><p><br></p><p>好了，到这里，关于包含块的知识就基本讲完了。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154655.png\" alt=\"image-20220814234654914\" contenteditable=\"false\"><br></p><p><br></p><p>我们再把 CSS 规范中所举的例子来看一下。</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Illustration of containing blocks&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body id=\"body\"&gt;\n    &lt;div id=\"div1\"&gt;\n      &lt;p id=\"p1\"&gt;This is text in the first paragraph...&lt;/p&gt;\n      &lt;p id=\"p2\"&gt;\n        This is text\n        &lt;em id=\"em1\"&gt;\n          in the\n          &lt;strong id=\"strong1\"&gt;second&lt;/strong&gt;\n          paragraph.\n        &lt;/em&gt;\n      &lt;/p&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre></div><p>上面是一段简单的 HTML 代码，在没有添加任何 CSS 代码的情况下，你能说出各自的包含块么？</p><p><br></p><p>对应的结果如下：</p><table><thead><tr><th><p>元素</p></th><th><p>包含块</p></th></tr></thead><tbody><tr><td><p>html</p></td><td><p>initial C.B. (UA-dependent)</p></td></tr><tr><td><p>body</p></td><td><p>html</p></td></tr><tr><td><p>div1</p></td><td><p>body</p></td></tr><tr><td><p>p1</p></td><td><p>div1</p></td></tr><tr><td><p>p2</p></td><td><p>div1</p></td></tr><tr><td><p>em1</p></td><td><p>p2</p></td></tr><tr><td><p>strong1</p></td><td><p>p2</p></td></tr></tbody></table><p>首先 HTML 作为根元素，对应的包含块就是前面我们所说的初始包含块，而对于 body 而言，这是一个 static 定位的元素，因此该元素的包含块参照第一条为 html，以此类推 div1、p1、p2 以及 em1 的包含块也都是它们的父元素。</p><p><br></p><p>不过 strong1 比较例外，它的包含块确实 p2，而非 em1。为什么会这样？建议你再把非根元素的第一条规则读一下：</p><ul><li><p>如果元素的 positiion 是 relative 或 static ，那么包含块由离它最近的**块容器（block container）**的内容区域（content area）的边缘建立。</p></li></ul><p>没错，因为 em1 不是块容器，而包含块是<strong>离它最近的块容器</strong>的内容区域，所以是 p2。</p><p><br></p><p>接下来添加如下的 CSS：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">#div1 { \n  position: absolute; \n  left: 50px; top: 50px \n}</code></pre></div><p>上面的代码我们对 div1 进行了定位，那么此时的包含块会发生变化么？你可以先在自己思考一下。</p><p><br></p><p>答案如下：</p><table><thead><tr><th><p>元素</p></th><th><p>包含块</p></th></tr></thead><tbody><tr><td><p>html</p></td><td><p>initial C.B. (UA-dependent)</p></td></tr><tr><td><p>body</p></td><td><p>html</p></td></tr><tr><td><p>div1</p></td><td><p>initial C.B. (UA-dependent)</p></td></tr><tr><td><p>p1</p></td><td><p>div1</p></td></tr><tr><td><p>p2</p></td><td><p>div1</p></td></tr><tr><td><p>em1</p></td><td><p>p2</p></td></tr><tr><td><p>strong1</p></td><td><p>p2</p></td></tr></tbody></table><p>可以看到，这里 div1 的包含块就发生了变化，变为了初始包含块。这里你可以参考前文中的这两句话：</p><ul><li><p>初始包含块（<strong>initial containing block</strong>）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。</p></li><li><p>如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。</p></li></ul><p>是不是一下子就理解了。没错，因为我们对 div1 进行了定位，因此它会应用非根元素包含块计算规则的第三条规则，寻找离它最近的 position 的值不是 static 的祖先元素，不过显然 body 的定位方式为 static，因此 div1 的包含块最终就变成了初始包含块。</p><p><br></p><p>接下来我们继续修改我们的 CSS：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">#div1 { \n  position: absolute; \n  left: 50px; \n  top: 50px \n}\n#em1  { \n  position: absolute; \n  left: 100px; \n  top: 100px \n}</code></pre></div><p>这里我们对 em1 同样进行了 absolute 绝对定位，你想一想会有什么样的变化？</p><p><br></p><p>没错，聪明的你大概应该知道，em1 的包含块不再是 p2，而变成了 div1，而 strong1 的包含块也不再是 p2 了，而是变成了 em1。</p><p><br></p><p>如下表所示：</p><table><thead><tr><th><p>元素</p></th><th><p>包含块</p></th></tr></thead><tbody><tr><td><p>html</p></td><td><p>initial C.B. (UA-dependent)</p></td></tr><tr><td><p>body</p></td><td><p>html</p></td></tr><tr><td><p>div1</p></td><td><p>initial C.B. (UA-dependent)</p></td></tr><tr><td><p>p1</p></td><td><p>div1</p></td></tr><tr><td><p>p2</p></td><td><p>div1</p></td></tr><tr><td><p>em1</p></td><td><p>div1（因为定位了，参阅非根元素包含块确定规则的第三条）</p></td></tr><tr><td><p>strong1</p></td><td><p>em1（因为 em1 变为了块容器，参阅非根元素包含块确定规则的第一条）</p></td></tr></tbody></table><p>好了，这就是 CSS 规范中所举的例子。如果你全都能看明白，以后你还能跟别人说你是看过这一块知识对应的 CSS 规范的人。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-15-013519.png\" alt=\"image-20220815093518833\" contenteditable=\"false\"><br></p><p><br></p><p>另外，关于包含块的知识，在 MDN 上除了解说了什么是包含块以外，也举出了很多简单易懂的示例。</p><p><br></p><p>具体你可以移步到：<em>https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block</em></p><p><br></p><p>好了，这就是有关包含块的所有内容了，你学会了么？-）</p><div contenteditable=\"false\"><hr></div><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666076600871",
  "typeId": {
    "$oid": "634d7fc47797638ec96fe2ee"
  }
},
{
  "_id": {
    "$oid": "634e500b2fac4881713db346"
  },
  "interviewTitle": "let const var 的区别是什么？",
  "interviewContent": "<h1><em>let、var、const</em> 的区别</h1><h2>经典真题</h2><ul><li><p><em>let const var</em> 的区别？什么是块级作用域？如何用？</p></li></ul><h2>声明变量关键字汇总</h2><p>在 <em>JavaScript</em> 中，一共存在 <em>3</em> 种声明变量的方式：</p><ul><li><p><em>var</em></p></li><li><p><em>let</em></p></li><li><p><em>const</em></p></li></ul><p>之所以有 <em>3</em> 种方式，这是由于历史原因造成的。最初声明变量的关键字就是 <em>var</em>，但是为了解决作用域的问题，所以后面新增了 <em>let</em> 和 <em>const</em> 的方式。</p><h3>作用域</h3><p>首先我们来了解一下作用域。</p><p><br></p><p><em>ES5</em> 中的作用域有：全局作用域、函数作用域，<em>ES6</em> 中新增了块级作用域。块作用域由 { } 包括，<em>if</em>  语句和  <em>for</em>  语句里面的 { } 也属于块作用域。</p><p><br></p><p>关于作用域的更多内容，可以参阅《作用域和作用域链》章节。</p><h3><em>var</em> 关键字</h3><ol><li><p>没有块级作用域的概念</p></li></ol><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">//Global Scope\n{\n  var a = 10;\n}\nconsole.log(a);  //10</code></pre></div><p>上面代码中，在 <em>Global Scope</em>（全局作用域）中，且在 <em>Block Scope</em>（块级作用域） { } 中，<em>a</em> 输出结果为 <em>10</em>，由此可以看出 <em>var</em> 声明的变量不存在 <em>Block Scope</em> 的概念</p><ol start=\"2\"><li><p>有全局作用域、函数作用域的概念</p></li></ol><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">//Global Scope\nvar a = 10;\nfunction checkscope(){\n    //Local Scope\n    var b = 20;\n    console.log(a);  //10\n    console.log(b);  //20\n}\ncheckscope();\nconsole.log(b);  //ReferenceError: b is not defined</code></pre></div><p>上面代码中，在 <em>Global Scope</em> 中用 <em>var</em> 声明了 <em>a</em>，在 <em>checkscope</em> 函数中的 <em>Local Scope</em>（本地作用域、函数作用域）中打印出了 <em>10</em>，但是在 <em>Global Scope</em> 中打印的变量 <em>b</em> 报错了。</p><ol start=\"3\"><li><p>不初始化值默认为 <em>undefined</em></p></li></ol><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">//Global Scope\nvar a;\nconsole.log(a);  //undefined</code></pre></div><p>上面代码中，在 <em>Global Scope</em> 中用 <em>var</em> 声明了 <em>a</em>，但没有初始化值，它的值默认为 <em>undefined</em>，这里是 <em>undefined</em> 是 <em>undefined</em> 类型，而不是字符串。</p><ol start=\"4\"><li><p>存在变量提升</p></li></ol><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">//Global Scope\nconsole.log(a);  //undefined\nvar a = 10;\n\ncheckscope();\nfunction checkscope(){\n    //Local Scope\n    console.log(a);  //undefined\n    var a;\n}</code></pre></div><p>上面代码中，先打印了 <em>a</em>，然后用 <em>var</em> 声明变量 <em>a</em>。变量提升是因为 <em>js</em> 需要经历编译和执行阶段。而 <em>js</em> 在编译阶段的时候，会搜集所有的变量声明并且提前声明变量。</p><p><br></p><p>可以将这个过程形象地想象成所有的声明（变量）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。</p><p><br></p><p>至于 <em>checkscope</em> 函数中的变量 <em>a</em> 为什么输出 <em>undefined</em>，可以参阅《作用域和作用域链》章节。</p><ol start=\"5\"><li><p>全局作用域用 <em>var</em> 声明的变量会挂载到 <em>window</em> 对象下</p></li></ol><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">//Global Scope\nvar a = 10;\nconsole.log(a);  //10\nconsole.log(window.a);  //10\nconsole.log(this.a);  //10</code></pre></div><p>上面代码中，打印出了 <em>3</em> 个 <em>10</em>，访问 <em>a</em> 和 <em>window.a</em> 或是 <em>this.a</em> 都是等价的。</p><p><br></p><p>举个例子：比如我要访问 <em>location</em> 对象，使用 <em>location</em> 可以访问，使用 <em>window.location</em> 也可以访问，只不过 <em>window</em> 对象可以省略不写，就像 <em>new Array( )</em> 和 <em>new window.Array( )</em> 是等价的。</p><ol start=\"6\"><li><p>同一作用域中允许重复声明</p></li></ol><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">//Global Scope\nvar a = 10;\nvar a = 20;\nconsole.log(a);  //20\n\ncheckscope();\nfunction checkscope(){\n    //Local Scope\n    var b = 10;\n    var b = 20;\n    console.log(b);  //20\n}</code></pre></div><p>上面代码中，在 <em>Global Scope</em> 中声明了 <em>2</em> 次 <em>a</em>，以最后一次声明有效，打印为 <em>20</em>。同理，在 <em>Local Scope</em> 也是一样的。</p><h3><em>let</em> 关键字</h3><ol><li><p>有块级作用域的概念</p></li></ol><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">{\n   //Block Scope\n   let a = 10;\n}\nconsole.log(a);  //ReferenceError: a is not defined</code></pre></div><p>上面代码中，打印 <em>a</em> 报错，说明存在 <em>Block Scope</em> 的概念。</p><ol start=\"2\"><li><p>不存在变量提升</p></li></ol><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">{\n  //Block Scope\n  console.log(a);  //ReferenceError: Cannot access 'a' before initialization\n  let a = 10;\n}</code></pre></div><p>上面代码中，打印 <em>a</em> 报错：无法在初始化之前访问。说明不存在变量提升。</p><ol start=\"3\"><li><p>暂时性死区</p></li></ol><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">{\n  //Block Scope\n  console.log(a);  //ReferenceError: Cannot access 'a' before initialization\n  let a = 20;\n}\n\nif (true) {\n  //TDZ开始\n  console.log(a);  //ReferenceError: Cannot access 'a' before initialization\n\n  let a; //TDZ结束\n  console.log(a);  //undefined\n\n  a = 123;\n  console.log(a);  //123\n}</code></pre></div><p>上面代码中，使用 <em>let</em> 声明的变量 <em>a</em>，导致绑定这个块级作用域，所以在 <em>let</em> 声明变量前，打印的变量 <em>a</em> 报错。</p><p><br></p><p>这是因为使用 <em>let/const</em> 所声明的变量会存在暂时性死区。</p><p><br></p><p>什么叫做暂时性死区域呢？</p><p><br></p><p><em>ES6</em> 标准中对 <em>let/const</em> 声明中的解释 <a href=\"https://link.segmentfault.com/?enc=K6pZVwgVNQb0IBQ9LTOuJg%3D%3D.p07UoPCGl5RslJ9ZnW9Nr36NFqs2pU%2FnSfWZUPIH3S1TUXzWdj22pH0lUMFVGVUwJkDpSHrYe8uKlYek%2FK4HBDYkJhc%2Fe2xiWo5V6teR%2BXY%3D\">第13章</a>，有如下一段文字：</p><blockquote><p><em>The variables are created when their containing Lexical Environment is instantiated but may not be accessed inany way until the variable’s LexicalBinding is evaluated.</em></p></blockquote><p>翻译成人话就是：</p><blockquote><p>当程序的控制流程在新的作用域（<em>module、function</em> 或 <em>block</em> 作用域）进行实例化时，在此作用域中用 <em>let/const</em> 声明的变量会先在作用域中被创建出来，但因此时还未进行词法绑定，所以是不能被访问的，如果访问就会抛出错误。因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时死区。</p></blockquote><p>再简单理解就是：</p><blockquote><p><em>ES6</em> 规定，<em>let/const</em> 命令会使区块形成封闭的作用域。若在声明之前使用变量，就会报错。</p><p>总之，在代码块内，使用 <em>let/const</em> 命令声明变量之前，该变量都是不可用的。</p><p>这在语法上，称为 <strong>“暂时性死区”</strong>（ <em>temporal dead zone</em>，简称 <strong><em>TDZ</em></strong>）。</p></blockquote><p>其实上面不存在变量提升的例子中，其实也是暂时性死区，因为它有暂时性死区的概念，所以它压根就不存在变量提升了。</p><ol start=\"4\"><li><p>同一块作用域中不允许重复声明</p></li></ol><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">{\n  //Block Scope\n  let A;\n  var A;  //SyntaxError: Identifier 'A' has already been declared\n}\n{\n  //Block Scope\n  var A;\n  let A;  //SyntaxError: Identifier 'A' has already been declared\n}\n{\n  //Block Scope\n  let A;\n  let A;  //SyntaxError: Identifier 'A' has already been declared\n}</code></pre></div><h3><em>const</em> 关键字</h3><ol><li><p>必须立即初始化，不能留到以后赋值</p></li></ol><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// Block Scope \nconst a; // SyntaxError: Missing initializer in const declaration } </code></pre></div><p>上面代码中，用 <em>const</em> 声明的变量 <em>a</em> 没有进行初始化，所以报错。</p><ol start=\"2\"><li><p>常量的值不能改变</p></li></ol><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">//Block Scope \n{\n  const a = 10; \n\ta = 20; // TypeError: Assignment to constant variable\n}</code></pre></div><p>上面代码中，用 <em>const</em> 声明了变量 <em>a</em> 且初始化为 <em>10</em>，然后试图修改 <em>a</em> 的值，报错。</p><p><br></p><p><em>const</em> 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</p><h3>特点总结</h3><ul><li><p><em>var</em> 关键字</p></li></ul><ol><li><p>没有块级作用域的概念</p></li><li><p>有全局作用域、函数作用域的概念</p></li><li><p>不初始化值默认为 <em>undefined</em></p></li><li><p>存在变量提升</p></li><li><p>全局作用域用 <em>var</em> 声明的变量会挂载到 <em>window</em> 对象下</p></li><li><p>同一作用域中允许重复声明</p></li></ol><ul><li><p><em>let</em> 关键字</p></li></ul><ol><li><p>有块级作用域的概念</p></li><li><p>不存在变量提升</p></li><li><p>暂时性死区</p></li><li><p>同一块作用域中不允许重复声明</p></li></ol><ul><li><p><em>const</em> 关键字</p></li></ul><ol><li><p>与 <em>let</em> 特性一样，仅有 <em>2</em> 个差别</p></li><li><p>区别 1：必须立即初始化，不能留到以后赋值</p></li><li><p>区别 2：常量的值不能改变</p></li></ol><h2>真题解答</h2><ul><li><p><em>let const var</em> 的区别？什么是块级作用域？如何用？</p></li></ul><blockquote><p>参考答案：</p><ol><li><p><em>var</em> 定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问，有变量提升。</p></li><li><p><em>let</em> 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问，无变量提升，不可以重复声明。</p></li><li><p><em>const</em> 用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改，无变量提升，不可以重复声明。</p></li></ol><p>最初在 <em>JS</em> 中作用域有：全局作用域、函数作用域。没有块作用域的概念。</p><p><br></p><p><em>ES6</em> 中新增了块级作用域。块作用域由 { } 包括，<em>if</em> 语句和 <em>for</em> 语句里面的 { } 也属于块作用域。</p><p><br></p><p>在以前没有块作用域的时候，在 <em>if</em> 或者 <em>for</em> 循环中声明的变量会泄露成全局变量，其次就是 { } 中的内层变量可能会覆盖外层变量。块级作用域的出现解决了这些问题。</p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666076683659",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e504b2fac4881713db352"
  },
  "interviewTitle": "JS 的基本数据类型有哪些？",
  "interviewContent": "<h1>值和引用</h1><h2>经典真题</h2><ul><li><p><em>JS</em> 的基本数据类型有哪些？基本数据类型和引用数据类型的区别</p></li></ul><h2>值和引用相关内容</h2><p>在 <em>JavaScript</em> 中，数据类型整体上来讲可以分为两大类：<strong>基本类型</strong>和<strong>引用数据类型</strong></p><p><br></p><p>基本数据类型，一共有 <em>6</em> 种：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"text\">string，symbol，number，boolean，undefined，null</code></pre></div><p>其中 <em>symbol</em> 类型是在 <em>ES6</em> 里面新添加的基本数据类型。</p><p><br></p><p>引用数据类型，就只有 <em>1</em> 种：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">object</code></pre></div><p>基本数据类型的值又被称之为原始值或简单值，而引用数据类型的值又被称之为复杂值或引用值。</p><p><br></p><p>那么两者之间具体有什么区别呢？我们一点一点来看：</p><h4>1. 简单值（原始值）</h4><p><strong>简单值是表示 <em>JavaScript</em> 中可用的数据或信息的最底层形式或最简单形式。简单类型的值被称为简单值，是因为它们是</strong>不可细化的。</p><p><br></p><p>也就是说，数字是数字，字符串是字符串，布尔值是 <em>true</em> 或 <em>false</em>，<em>null</em> 和 <em>undefined</em> 就是 <em>null</em> 和 <em>undefined</em>。这些值本身很简单，不能够再进行拆分。</p><p><br></p><p>由于简单值的数据大小是固定的，所以<strong>简单值的数据是存储于内存中的栈区里面的。</strong></p><p><br></p><p>要简单理解栈的存取方式，我们可以通过类比乒乓球盒子来分析。如下图：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-30-025405.png\" alt=\"img\" contenteditable=\"false\"><br></p><p><br></p><p>下面是具体的代码示例：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var str = \"Hello World\";\nvar num = 10;\nvar bol = true;\nvar myNull = null;\nvar undef = undefined;\nconsole.log(typeof str); // string\nconsole.log(typeof num); // number\nconsole.log(typeof bol); // boolean\nconsole.log(typeof myNull); // object\nconsole.log(typeof undef); // undefined</code></pre></div><p>这里面 <em>null</em> 比较特殊，打印出来是 <em>object</em>，这是由于历史原因所遗留下来的问题。</p><p><br></p><p>是来源于 <em>JavaScript</em> 从第一个版本开始时的一个 <em>bug</em>，并且这个 <em>bug</em> 无法被修复。因为修复会破坏现有的代码。</p><p><br></p><p>具体原因是因为不同的对象在底层都表现为二进制，在 <em>JavaScript</em> 中二进制前三位都为 <em>0</em> 的话会被判断为 <em>object</em> 类型，<em>null</em> 的二进制全部为 <em>0</em>，自然前三位也是 <em>0</em>，所以执行 <em>typeof</em> 值会返回 <em>object</em>。</p><p><br></p><p>例外，当我们打印 <em>null == undefined</em> 的时候，返回的是 <em>true</em>，这也是面试时经常会被问到的一个问题。</p><p><br></p><p>这两个值都表示“无”的意思。</p><p><br></p><p>通常情况下， 当我们试图访问某个不存在的或者没有赋值的变量时，就会得到一个 <em>undefined</em> 值。<em>Javascript</em> 会自动将声明是没有进行初始化的变量设为 <em>undifined</em>。</p><p><br></p><p>而 <em>null</em> 值表示空，<em>null</em> 不能通过 <em>Javascript</em> 来自动赋值，也就是说必须要我们自己手动来给某个变量赋值为 <em>null</em>。</p><p><br></p><p>那么为什么 <em>JavaScript</em> 要设置两个表示\"无\"的值呢？</p><p><br></p><p>这其实也是因为历史原因。</p><p><br></p><p><em>1995</em> 年 <em>JavaScript</em> 诞生时，最初像 <em>Java</em> 一样，只设置了 <em>null</em> 作为表示\"无\"的值。根据 <em>C</em> 语言的传统，<em>null</em> 被设计成可以自动转为 <em>0</em>。</p><p><br></p><p>但是，<em>JavaScript</em> 的设计者，觉得这样做还不够，主要有以下两个原因。</p><ol><li><p><em>null</em> 像在 <em>Java</em> 里一样，被当成一个对象。但是，<em>JavaScript</em> 的数据类型分成原始类型（<em>primitive</em>）和复合类型（<em>complex</em>）两大类，作者觉得表示“无”的值最好不是对象。</p></li><li><p><em>JavaScript</em> 的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。作者觉得，如果 <em>null</em> 自动转为 <em>0</em>，很不容易发现错误。</p></li></ol><p>因此，作者又设计了一个 <em>undefined</em>。<strong>这里注意：先有 <em>null</em> 后有 <em>undefined</em> 出来，<em>undefined</em> 是为了填补之前的坑。</strong></p><p><br></p><p><em>JavaScript</em> 的最初版本是这样区分的：</p><p><br></p><p><em>null</em> 是一个表示“无”的对象（空对象指针），转为数值时为 <em>0</em>；</p><p><br></p><p>典型用法是：</p><ul><li><p>作为函数的参数，表示该函数的参数不是对象。</p></li><li><p>作为对象原型链的终点。</p></li></ul><p><em>undefined</em> 是一个表示\"无\"的原始值，转为数值时为 <em>NaN</em>。</p><p><br></p><p>典型用法是：</p><ul><li><p>变量被声明了，但没有赋值时，就等于 <em>undefined</em>。</p></li><li><p>调用函数时，应该提供的参数没有提供，该参数等于 <em>undefined</em>。</p></li><li><p>对象没有赋值的属性，该属性的值为 <em>undefined</em>。</p></li><li><p>函数没有返回值时，默认返回 <em>undefined</em>。</p></li></ul><h4>2. 复杂值（引用值）</h4><p>在 <em>JavaScript</em> 中，对象就是一个复杂值。因为对象可以向下拆分，拆分成多个简单值或者复杂值。</p><p><br></p><p><strong>复杂值在内存中的大小是未知的，因为复杂值可以包含任何值，而不是一个特定的已知值，所以复杂值的数据都是存储于堆区里面。</strong></p><p><br></p><p>如下图所示：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-30-025509.png\" alt=\"img\" contenteditable=\"false\"><br></p><p><br></p><p>下面是具体的代码示例：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// 简单值\nvar a1 = 0;\nvar a2 = \"this is str\";\nvar a3 = null\n\n// 复杂值\nvar c = [1, 2, 3];\nvar d = {m: 20};</code></pre></div><h4>3. 访问方式</h4><p><strong>按值访问</strong></p><p><br></p><p>简单值是作为不可细化的值进行存储和使用的，引用它们会转移其值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var str = \"Hello\";\nvar str2 = str;\nstr = null;\nconsole.log(str,str2); // null \"Hello\"</code></pre></div><p><strong>引用访问</strong></p><p><br></p><p>复杂值是通过引用进行存储和操作的，而不是实际的值。创建一个包含复杂对象的变量时，其值是内存中的一个引用地址。引用一个复杂对象时，使用它的名称（即变量或对象属性）通过内存中的引用地址获取该对象值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = {};\nvar obj2 = obj;\nobj.name = \"zhangsan\";\nconsole.log(obj.name); // zhangsan\nconsole.log(obj2.name); // zhangsan</code></pre></div><h4>4. 比较方式</h4><p>简单值采用值比较，而复杂值采用引用比较。复杂值只有在引用相同的对象（即有相同的地址）时才相等。即使是包含相同对象的两个变量也彼此不相等，因为它们并不指向同一个对象。</p><p><br></p><p>示例 1:</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var a = 10;\nvar b = 10;\nvar c = new Number(10);\nvar d = c;\nconsole.log(a === b); // true\nconsole.log(a === c); // false\nconsole.log(a === c); // false\nconsole.log(a == c); // true\nd = 10;\nconsole.log(d == c); // true\nconsole.log(d === c); // false</code></pre></div><p>示例 2:</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = {name : 'zhangsan'};\nvar obj2 = {name : 'zhangsan'};\nconsole.log(obj == obj2); // false\nconsole.log(obj === obj2); // false\nvar obj3 = {name : 'zhangsan'};\nvar obj4 = obj3;\nconsole.log(obj3 == obj4); // true\nconsole.log(obj3 === obj4); // ture</code></pre></div><h4>5. 动态属性</h4><p>对于复杂值，可以为其添加属性和方法，也可以改变和删除其属性和方法。但简单值不可以：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var str = 'test';\nstr.abc = true;\nconsole.log(str.abc); // undefined\nvar obj = {};\nobj.abc = true;\nconsole.log(obj.abc); // true</code></pre></div><p>复杂值支持动态对象属性，因为我们可以定义对象，然后创建引用，再更新对象，并且所有指向该对象的变量都会获得更新。</p><p><br></p><p>一个新变量指向现有的复杂对象，并没有复制该对象。这就是复杂值有时被称为引用值的原因。复杂值可以根据需求有任意多个引用，即使对象改变，它们也总是指向同一个对象</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = {name : 'zhangsan'};\nvar obj2 = obj;\nvar obj3 = obj2;\nobj.name = 'abc';\nconsole.log(obj.name, obj2.name, obj3.name);\n// abc abc abc</code></pre></div><h4>6. 变量赋值</h4><p>最后说一下关于变量的赋值，其实是可以分为直接赋值和引用赋值的。直接赋值，就是指将简单值赋值给变量，而引用赋值是指将一个复杂值的引用赋值给变量，这个引用指向堆区实际存在的数据。</p><p><br></p><p><strong>直接赋值</strong></p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var a = 3;\nvar b = a;\nb = 5;\nconsole.log(a); // 3</code></pre></div><p><strong>引用赋值</strong></p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var a = {value : 1};\nvar b = a;\nb.value = 10;\nconsole.log(a.value); // 10</code></pre></div><h2>真题解答</h2><ul><li><p><em>JS</em> 的基本数据类型有哪些？基本数据类型和引用数据类型的区别</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>在 <em>JavaScript</em> 中，数据类型整体上来讲可以分为两大类：<strong>基本类型</strong>和<strong>引用数据类型</strong></p><p><br></p><p>基本数据类型，一共有 <em>6</em> 种：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"text\">string，symbol，number，boolean，undefined，null</code></pre></div><p>其中 <em>symbol</em> 类型是在 <em>ES6</em> 里面新添加的基本数据类型。</p><p><br></p><p>引用数据类型，就只有 <em>1</em> 种：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">object</code></pre></div><p>基本数据类型的值又被称之为原始值或简单值，而引用数据类型的值又被称之为复杂值或引用值。</p><p><br></p><p>两者的区别在于：</p><p><br></p><p><strong>原始值是表示 <em>JavaScript</em> 中可用的数据或信息的最底层形式或最简单形式。简单类型的值被称为原始值，是因为它们是</strong>不可细化的。</p><p><br></p><p>也就是说，数字是数字，字符是字符，布尔值是 <em>true</em> 或 <em>false</em>，<em>null</em> 和 <em>undefined</em> 就是 <em>null</em> 和 <em>undefined</em>。这些值本身很简单，不能够再进行拆分。由于原始值的数据大小是固定的，所以<strong>原始值的数据是存储于内存中的栈区里面的。</strong></p><p><br></p><p>在 <em>JavaScript</em> 中，对象就是一个引用值。因为对象可以向下拆分，拆分成多个简单值或者复杂值。<strong>引用值在内存中的大小是未知的，因为引用值可以包含任何值，而不是一个特定的已知值，所以引用值的数据都是存储于堆区里面。</strong></p><p><br></p><p>最后总结一下两者的区别：</p><ol><li><p>访问方式</p><ul><li><p>原始值：访问到的是值</p></li><li><p>引用值：访问到的是引用地址</p></li></ul></li><li><p>比较方式</p><ul><li><p>原始值：比较的是值</p></li><li><p>引用值：比较的是地址</p></li></ul></li><li><p>动态属性</p><ul><li><p>原始值：无法添加动态属性</p></li><li><p>引用值：可以添加动态属性</p></li></ul></li><li><p>变量赋值</p><ul><li><p>原始值：赋值的是值</p></li><li><p>引用值：赋值的是地址</p></li></ul></li></ol></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666076747778",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e50802fac4881713db356"
  },
  "interviewTitle": "是否了解 JS 中的包装类型？",
  "interviewContent": "<h1>包装类型</h1><h2>经典真题</h2><ul><li><p>是否了解 <em>JavaScript</em> 中的包装类型？</p></li></ul><h2>包装类型</h2><p>在 <em>ES</em> 中，数据的分类分为<strong>基本数据类型</strong>和<strong>引用类型</strong>。</p><p><br></p><p>按照最新 <em>ES</em> 标准定义，基本数据类型（<em>primitive value</em>）包括 <em>undefined、null、boolean、number、symbol、string</em>。</p><p><br></p><p>引用类型包括 <em>Object、Array、Date、RegExp</em> 等。</p><p><br></p><p>基本数据类型和引用类型这两个类型其中一个很明显的区别是，引用类型有自己内置的方法，也可以自定义其他方法用来操作数据，而基本数据类型不能像引用类型那样有自己的内置方法对数据进行更多的操作。</p><p><br></p><p>但基本数据类型真的就不能使用方法吗？对于部分基本类型来说确实是这样的。</p><p><br></p><p>但是有 <em>3</em> 个是 <em>ES</em> 提供了对应的特殊引用类型（包装类型）<em>Boolean、Number、String</em>。</p><p><br></p><p>基本包装类型，和其他引用类型一样，拥有内置的方法可以对数据进行额外操作。如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var str = 'hello'; // string 基本类型\nvar s2 = str.charAt(0);\nconsole.log(s2); // h</code></pre></div><p>上面的 <em>string</em> 是一个基本类型，但是它却能调用 <em>charAt( )</em> 的方法。</p><p><br></p><p>其主要是因为在执行第二行代码时，后台会自动进行下面的步骤：</p><ol><li><p>自动创建 <em>String</em> 类型的一个实例（和基本类型的值不同，这个实例就是一个基本包装类型的对象）</p></li><li><p>调用实例（对象）上指定的方法</p></li><li><p>销毁这个实例</p></li></ol><p>用代码的方式解释就是如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">//我们平常写程序的过程：\nvar str = 'hello'; // string 基本类型\nvar s2 = str.charAt(0); // 在执行到这一句的时候 后台会自动完成以下动作 ：\n(\n    var _str = new String('hello'); // 1 找到对应的包装对象类型，然后通过包装对象创建出一个和基本类型值相同的对象\n    var s2 = _str.charAt(0); // 2 然后这个对象就可以调用包装对象下的方法，并且返回结给 s2.\n    _str = null;  //    3 之后这个临时创建的对象就被销毁了， str =null; \n)\nconsole.log(s2); // h \nconsole.log(str); // hello</code></pre></div><p>基本类型的值虽然没有方法可以调用，但是后台临时创建的包装对象上有内置方法可以让我们调用方法，因此这样我们就可以对字符串、数值、布尔值这三种基本数据类型的数据进行更多操作。</p><p><br></p><p>而什么时候后台会自动创建一个对应的基本包装类型的对象，取决于当前执行的代码是否是为了获取他的值。</p><p><br></p><p>每当读取一个基本类型的值，也就是当我们需要从内存中获取到他的值时（这个访问过程称为读取模式），这时后台就会自动创建一个基本包装类型的对象。例如：</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">var test = 'hhh'\nconsole.log(test) // 读取模式，后台自动创建基本包装类型对象\nvar test2 = test // 赋值给变量 test2，也需要读取 test 的值，同上</code></pre></div><p>基本包装类型的对象和引用类型的对象最大的一个区别是，对象的生存期不同，导致的一个结果就是，基本包装类型无法自定义自己的方法。</p><p><br></p><p>对于引用类型的数据，在执行流离开当前作用域之前都会保存在内存中，而对于自动创建的基本包装类型的对象，只存在于一行代码的执行瞬间，执行完毕就会立即被销毁。</p><p>如下：</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">var str = 'test'\nstr.test = 'hhh'\nconsole.log(str.test) //undefined</code></pre></div><p>上面第二行代码给自动创建的 <em>String</em> 实例对象添加了 <em>test</em> 属性，虽然此刻代码执行时他是生效的，但是在这行代码执行完毕后该 <em>String</em> 实例就会立刻被销毁，<em>String</em> 实例的 <em>test</em> 属性也就不存在了。</p><p><br></p><p>当执行第三行代码时，由于是读取模式，又重新创建了新的 <em>String</em> 实例，而这个新创建的 <em>String</em> 实例没有 <em>test</em> 属性，结果也就是 <em>undefined</em>。</p><p><br></p><p>用代码的方式解释就是如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var str = 'hello';\nstr.number = 10; //假设我们想给字符串添加一个属性 number ，后台会有如下步骤\n(\n    var _str = new String('hello'); // 1 找到对应的包装对象类型，然后通过包装对象创建出一个和基本类型值相同的对象\n    _str.number = 10; // 2 通过这个对象调用包装对象下的方法 但结果并没有被任何东西保存\n    _str =null; // 3 这个对象又被销毁\n)\nconsole.log(str.number); // undefined  当执行到这一句的时候，因为基本类型本来没有属性，后台又会重新重复上面的步骤\n(\n   var str = new String('hello');// 1 找到基本包装对象，然后又新开辟一个内存，创建一个值为 hello 对象\n   str.number = undefined;// 2 因为包装对象下面没有 number 这个属性，所以又会重新添加，因为没有值，所以值是未定义;然后弹出结果\n   str =null; // 3 这个对象又被销毁\n)</code></pre></div><p>那么我们怎么才能给基本类型添加方法或者属性呢？</p><p><br></p><p>答案是在基本包装对象的原型下面添加，每个对象都有原型。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">//给字符串添加方法  要写到对应的包装对象的原型下才行\nvar str = 'hello';\nString.prototype.last= fuction(){ \n    return this.charAt(this.length);\n}; \nstr.last(); // 5 执行到这一句，后台依然会偷偷的干这些事\n(\n    var _str = new String('hello');// 找到基本包装对象，new一个和字符串值相同的对象，\n    _str.last();  // 通过这个对象找到了包装对象下的方法并调用 \n    _str =null; //  这个对象被销毁\n)</code></pre></div><h2>真题解答</h2><ul><li><p>是否了解 <em>JavaScript</em> 中的包装类型？</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>包装对象，就是当基本类型以对象的方式去使用时，<em>JavaScript</em> 会转换成对应的包装类型，相当于 <em>new</em> 一个对象，内容和基本类型的内容一样，然后当操作完成再去访问的时候，这个临时对象会被销毁，然后再访问时候就是 <em>undefined</em>。</p><p><br></p><p><em>number、string、boolean</em> 都有对应的包装类型。</p><p><br></p><p>因为有了基本包装类型，所以 <em>JavaScript</em>  中的基本类型值可以被当作对象来访问。</p><p><br></p><p>基本类型特征：</p><ol><li><p>每个包装类型都映射到同名的基本类型</p></li><li><p>在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作</p></li><li><p>操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象</p></li></ol></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666076800550",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e50ef2fac4881713db362"
  },
  "interviewTitle": "JS 中如何进行数据类型的转换？",
  "interviewContent": "<h1>数据类型的转换</h1><h2>经典真题</h2><ul><li><p><em>JavaScript</em> 中如何进行数据类型的转换？</p></li></ul><h2>数据类型转换介绍</h2><p><em>JavaScript</em> 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var x = y ? 1 : 'a';</code></pre></div><p>上面代码中，变量<code data-backticks=\"1\">x</code>到底是数值还是字符串，取决于另一个变量<code data-backticks=\"1\">y</code>的值。<code data-backticks=\"1\">y</code>为<code data-backticks=\"1\">true</code>时，<code data-backticks=\"1\">x</code>是一个数值；<code data-backticks=\"1\">y</code>为<code data-backticks=\"1\">false</code>时，<code data-backticks=\"1\">x</code>是一个字符串。这意味着，<code data-backticks=\"1\">x</code>的类型没法在编译阶段就知道，必须等到运行时才能知道。</p><p><br></p><p>虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。比如，减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">'4' - '3' // 1</code></pre></div><p>上面代码中，虽然是两个字符串相减，但是依然得到数值 <code data-backticks=\"1\">1</code>，原因就在于 <em>JavaScript</em> 将运算子自动转为了数值。</p><p><br></p><p>所以接下来我们就来看一下 <em>JavaScript</em> 中如何进行数据类型转换。</p><h2>强制转换（显式转换）</h2><p>强制转换主要指使用<code data-backticks=\"1\">Number()</code>、<code data-backticks=\"1\">String()</code>和<code data-backticks=\"1\">Boolean()</code>三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。</p><h4><em>Number( )</em></h4><p>使用<code data-backticks=\"1\">Number</code>函数，可以将任意类型的值转化成数值。</p><p><br></p><p>下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象。</p><p><br></p><p><strong>（1）原始类型值</strong></p><p><br></p><p>原始类型值的转换规则如下。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// 数值：转换后还是原来的值\nNumber(324) // 324\n\n// 字符串：如果可以被解析为数值，则转换为相应的数值\nNumber('324') // 324\n\n// 字符串：如果不可以被解析为数值，返回 NaN\nNumber('324abc') // NaN\n\n// 空字符串转为0\nNumber('') // 0\n\n// 布尔值：true 转成 1，false 转成 0\nNumber(true) // 1\nNumber(false) // 0\n\n// undefined：转成 NaN\nNumber(undefined) // NaN\n\n// null：转成0\nNumber(null) // 0</code></pre></div><p><code data-backticks=\"1\">Number</code>函数将字符串转为数值，要比<code data-backticks=\"1\">parseInt</code>函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为<code data-backticks=\"1\">NaN</code>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">parseInt('42 cats') // 42\nNumber('42 cats') // NaN</code></pre></div><p>上面代码中，<code data-backticks=\"1\">parseInt</code>逐个解析字符，而<code data-backticks=\"1\">Number</code>函数整体转换字符串的类型。</p><p><br></p><p>另外，<code data-backticks=\"1\">parseInt</code>和<code data-backticks=\"1\">Number</code>函数都会自动过滤一个字符串前导和后缀的空格。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">parseInt('\\t\\v\\r12.34\\n') // 12\nNumber('\\t\\v\\r12.34\\n') // 12.34</code></pre></div><p><strong>（2）对象</strong></p><p><br></p><p>简单的规则是，<code data-backticks=\"1\">Number</code>方法的参数是对象时，将返回<code data-backticks=\"1\">NaN</code>，除非是包含单个数值的数组。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">Number({a: 1}) // NaN\nNumber([1, 2, 3]) // NaN\nNumber([5]) // 5</code></pre></div><p>之所以会这样，是因为<code data-backticks=\"1\">Number</code>背后的转换规则比较复杂。</p><p><br></p><p>第一步，调用对象自身的<code data-backticks=\"1\">valueOf</code>方法。如果返回原始类型的值，则直接对该值使用<code data-backticks=\"1\">Number</code>函数，不再进行后续步骤。</p><p><br></p><p>第二步，如果<code data-backticks=\"1\">valueOf</code>方法返回的还是对象，则改为调用对象自身的<code data-backticks=\"1\">toString</code>方法。如果<code data-backticks=\"1\">toString</code>方法返回原始类型的值，则对该值使用<code data-backticks=\"1\">Number</code>函数，不再进行后续步骤。</p><p><br></p><p>第三步，如果<code data-backticks=\"1\">toString</code>方法返回的是对象，就报错。</p><p><br></p><p>请看下面的例子。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = {x: 1};\nNumber(obj) // NaN\n\n// 等同于\nif (typeof obj.valueOf() === 'object') {\n  Number(obj.toString());\n} else {\n  Number(obj.valueOf());\n}</code></pre></div><p>上面代码中，<code data-backticks=\"1\">Number</code>函数将<code data-backticks=\"1\">obj</code>对象转为数值。背后发生了一连串的操作，首先调用<code data-backticks=\"1\">obj.valueOf</code>方法, 结果返回对象本身；于是，继续调用<code data-backticks=\"1\">obj.toString</code>方法，这时返回字符串<code data-backticks=\"1\">[object Object]</code>，对这个字符串使用<code data-backticks=\"1\">Number</code>函数，得到<code data-backticks=\"1\">NaN</code>。</p><p><br></p><p>默认情况下，对象的<code data-backticks=\"1\">valueOf</code>方法返回对象本身，所以一般总是会调用<code data-backticks=\"1\">toString</code>方法，而<code data-backticks=\"1\">toString</code>方法返回对象的类型字符串（比如<code data-backticks=\"1\">[object Object]</code>）。所以，会有下面的结果。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">Number({}) // NaN</code></pre></div><p>如果<code data-backticks=\"1\">toString</code>方法返回的不是原始类型的值，结果就会报错。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = {\n  valueOf: function () {\n    return {};\n  },\n  toString: function () {\n    return {};\n  }\n};\n\nNumber(obj)\n// TypeError: Cannot convert object to primitive value</code></pre></div><p>上面代码的<code data-backticks=\"1\">valueOf</code>和<code data-backticks=\"1\">toString</code>方法，返回的都是对象，所以转成数值时会报错。</p><p><br></p><p>从上例还可以看到，<code data-backticks=\"1\">valueOf</code>和<code data-backticks=\"1\">toString</code>方法，都是可以自定义的。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">Number({\n  valueOf: function () {\n    return 2;\n  }\n})\n// 2\n\nNumber({\n  toString: function () {\n    return 3;\n  }\n})\n// 3\n\nNumber({\n  valueOf: function () {\n    return 2;\n  },\n  toString: function () {\n    return 3;\n  }\n})\n// 2</code></pre></div><p>上面代码对三个对象使用<code data-backticks=\"1\">Number</code>函数。第一个对象返回<code data-backticks=\"1\">valueOf</code>方法的值，第二个对象返回<code data-backticks=\"1\">toString</code>方法的值，第三个对象表示<code data-backticks=\"1\">valueOf</code>方法先于<code data-backticks=\"1\">toString</code>方法执行。</p><h4><em>String( )</em></h4><p><code data-backticks=\"1\">String</code>函数可以将任意类型的值转化成字符串，转换规则如下。</p><p><br></p><p><strong>（1）原始类型值</strong></p><ul><li><p><strong>数值</strong>：转为相应的字符串。</p></li><li><p><strong>字符串</strong>：转换后还是原来的值。</p></li><li><p><strong>布尔值</strong>：<code data-backticks=\"1\">true</code>转为字符串<code data-backticks=\"1\">\"true\"</code>，<code data-backticks=\"1\">false</code>转为字符串<code data-backticks=\"1\">\"false\"</code>。</p></li><li><p><strong>undefined</strong>：转为字符串<code data-backticks=\"1\">\"undefined\"</code>。</p></li><li><p><strong>null</strong>：转为字符串<code data-backticks=\"1\">\"null\"</code>。</p></li></ul><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">String(123) // \"123\"\nString('abc') // \"abc\"\nString(true) // \"true\"\nString(undefined) // \"undefined\"\nString(null) // \"null\"</code></pre></div><p><strong>（2）对象</strong></p><p><br></p><p><code data-backticks=\"1\">String</code>方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">String({a: 1}) // \"[object Object]\"\nString([1, 2, 3]) // \"1,2,3\"</code></pre></div><p><code data-backticks=\"1\">String</code>方法背后的转换规则，与<code data-backticks=\"1\">Number</code>方法基本相同，只是互换了<code data-backticks=\"1\">valueOf</code>方法和<code data-backticks=\"1\">toString</code>方法的执行顺序。</p><ol><li><p>先调用对象自身的<code data-backticks=\"1\">toString</code>方法。如果返回原始类型的值，则对该值使用<code data-backticks=\"1\">String</code>函数，不再进行以下步骤。</p></li><li><p>如果<code data-backticks=\"1\">toString</code>方法返回的是对象，再调用原对象的<code data-backticks=\"1\">valueOf</code>方法。如果<code data-backticks=\"1\">valueOf</code>方法返回原始类型的值，则对该值使用<code data-backticks=\"1\">String</code>函数，不再进行以下步骤。</p></li><li><p>如果<code data-backticks=\"1\">valueOf</code>方法返回的是对象，就报错。</p></li></ol><p>下面是一个例子。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">String({a: 1})\n// \"[object Object]\"\n\n// 等同于\nString({a: 1}.toString())\n// \"[object Object]\"</code></pre></div><p>上面代码先调用对象的<code data-backticks=\"1\">toString</code>方法，发现返回的是字符串<code data-backticks=\"1\">[object Object]</code>，就不再调用<code data-backticks=\"1\">valueOf</code>方法了。</p><p><br></p><p>如果<code data-backticks=\"1\">toString</code>法和<code data-backticks=\"1\">valueOf</code>方法，返回的都是对象，就会报错。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = {\n  valueOf: function () {\n    return {};\n  },\n  toString: function () {\n    return {};\n  }\n};\n\nString(obj)\n// TypeError: Cannot convert object to primitive value</code></pre></div><p>下面是通过自定义<code data-backticks=\"1\">toString</code>方法，改变返回值的例子。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">String({\n  toString: function () {\n    return 3;\n  }\n})\n// \"3\"\n\nString({\n  valueOf: function () {\n    return 2;\n  }\n})\n// \"[object Object]\"\n\nString({\n  valueOf: function () {\n    return 2;\n  },\n  toString: function () {\n    return 3;\n  }\n})\n// \"3\"</code></pre></div><p>上面代码对三个对象使用<code data-backticks=\"1\">String</code>函数。第一个对象返回<code data-backticks=\"1\">toString</code>方法的值（数值3），第二个对象返回的还是<code data-backticks=\"1\">toString</code>方法的值（<code data-backticks=\"1\">[object Object]</code>），第三个对象表示<code data-backticks=\"1\">toString</code>方法先于<code data-backticks=\"1\">valueOf</code>方法执行。</p><h4><em>Boolean( )</em></h4><p><code data-backticks=\"1\">Boolean()</code>函数可以将任意类型的值转为布尔值。</p><p><br></p><p>它的转换规则相对简单：除了以下五个值的转换结果为<code data-backticks=\"1\">false</code>，其他的值全部为<code data-backticks=\"1\">true</code>。</p><ul><li><p><code data-backticks=\"1\">undefined</code></p></li><li><p><code data-backticks=\"1\">null</code></p></li><li><p><code data-backticks=\"1\">0</code>（包含<code data-backticks=\"1\">-0</code>和<code data-backticks=\"1\">+0</code>）</p></li><li><p><code data-backticks=\"1\">NaN</code></p></li><li><p><code data-backticks=\"1\">''</code>（空字符串）</p></li></ul><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">Boolean(undefined) // false\nBoolean(null) // false\nBoolean(0) // false\nBoolean(NaN) // false\nBoolean('') // false</code></pre></div><p>当然，<code data-backticks=\"1\">true</code>和<code data-backticks=\"1\">false</code>这两个布尔值不会发生变化。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">Boolean(true) // true\nBoolean(false) // false</code></pre></div><p>注意，所有对象（包括空对象）的转换结果都是<code data-backticks=\"1\">true</code>，甚至连<code data-backticks=\"1\">false</code>对应的布尔对象<code data-backticks=\"1\">new Boolean(false)</code>也是<code data-backticks=\"1\">true</code>（详见《原始类型值的包装对象》一章）。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">Boolean({}) // true\nBoolean([]) // true\nBoolean(new Boolean(false)) // true</code></pre></div><p>所有对象的布尔值都是<code data-backticks=\"1\">true</code>，这是因为 JavaScript 语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于<code data-backticks=\"1\">obj1 &amp;&amp; obj2</code>这样的场景，可能会需要较多的计算。为了保证性能，就统一规定，对象的布尔值为<code data-backticks=\"1\">true</code>。</p><h2>自动转换（隐式转换）</h2><p>下面介绍自动转换，它是以强制转换为基础的。</p><p><br></p><p>遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。</p><p><br></p><p>第一种情况，不同类型的数据互相运算。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">123 + 'abc' // \"123abc\"</code></pre></div><p>第二种情况，对非布尔值类型的数据求布尔值。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">if ('abc') {\n  console.log('hello')\n}  // \"hello\"</code></pre></div><p>第三种情况，对非数值类型的值使用一元运算符（即<code data-backticks=\"1\">+</code>和<code data-backticks=\"1\">-</code>）。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">+ {foo: 'bar'} // NaN\n- [1, 2, 3] // NaN</code></pre></div><p>自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用<code data-backticks=\"1\">String()</code>函数进行转换。如果该位置既可以是字符串，也可能是数值，那么默认转为数值。</p><p><br></p><p>由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用<code data-backticks=\"1\">Boolean()</code>、<code data-backticks=\"1\">Number()</code>和<code data-backticks=\"1\">String()</code>函数进行显式转换。</p><h4>自动转换为布尔值</h4><p>JavaScript 遇到预期为布尔值的地方（比如<code data-backticks=\"1\">if</code>语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用<code data-backticks=\"1\">Boolean()</code>函数。</p><p><br></p><p>因此除了以下五个值，其他都是自动转为<code data-backticks=\"1\">true</code>。</p><ul><li><p><code data-backticks=\"1\">undefined</code></p></li><li><p><code data-backticks=\"1\">null</code></p></li><li><p><code data-backticks=\"1\">+0</code>或<code data-backticks=\"1\">-0</code></p></li><li><p><code data-backticks=\"1\">NaN</code></p></li><li><p><code data-backticks=\"1\">''</code>（空字符串）</p></li></ul><p>下面这个例子中，条件部分的每个值都相当于<code data-backticks=\"1\">false</code>，使用否定运算符后，就变成了<code data-backticks=\"1\">true</code>。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">if ( !undefined\n  &amp;&amp; !null\n  &amp;&amp; !0\n  &amp;&amp; !NaN\n  &amp;&amp; !''\n) {\n  console.log('true');\n} // true</code></pre></div><p>下面两种写法，有时也用于将一个表达式转为布尔值。它们内部调用的也是<code data-backticks=\"1\">Boolean()</code>函数。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">// 写法一\nexpression ? true : false\n\n// 写法二\n!! expression</code></pre></div><h4>自动转换为字符串</h4><p>JavaScript 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串。具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串。</p><p><br></p><p>字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">'5' + 1 // '51'\n'5' + true // \"5true\"\n'5' + false // \"5false\"\n'5' + {} // \"5[object Object]\"\n'5' + [] // \"5\"\n'5' + function (){} // \"5function (){}\"\n'5' + undefined // \"5undefined\"\n'5' + null // \"5null\"</code></pre></div><p>这种自动转换很容易出错。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">var obj = {\n  width: '100'\n};\n\nobj.width + 20 // \"10020\"</code></pre></div><p>上面代码中，开发者可能期望返回<code data-backticks=\"1\">120</code>，但是由于自动转换，实际上返回了一个字符<code data-backticks=\"1\">10020</code>。</p><h4>自动转换为数值</h4><p>JavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用<code data-backticks=\"1\">Number()</code>函数。</p><p><br></p><p>除了加法运算符（<code data-backticks=\"1\">+</code>）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">'5' - '2' // 3\n'5' * '2' // 10\ntrue - 1  // 0\nfalse - 1 // -1\n'1' - 1   // 0\n'5' * []    // 0\nfalse / '5' // 0\n'abc' - 1   // NaN\nnull + 1 // 1\nundefined + 1 // NaN</code></pre></div><p>上面代码中，运算符两侧的运算子，都被转成了数值。</p><blockquote><p>注意：<code data-backticks=\"1\">null</code>转为数值时为<code data-backticks=\"1\">0</code>，而<code data-backticks=\"1\">undefined</code>转为数值时为<code data-backticks=\"1\">NaN</code>。</p></blockquote><p>一元运算符也会把运算子转成数值。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">+'abc' // NaN\n-'abc' // NaN\n+true // 1\n-false // 0</code></pre></div><h2>真题解答</h2><ul><li><p><em>JavaScript</em> 中如何进行数据类型的转换？</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>类型转换可以分为两种，<strong>隐性转换</strong>和<strong>显性转换</strong>。</p><p><br></p><p><strong>1. 隐性转换</strong></p><p><br></p><p>当不同数据类型之间进行相互运算，或者当对非布尔类型的数据求布尔值的时候，会发生隐性转换。</p><p><br></p><p>预期为数字的时候：算术运算的时候，我们的结果和运算的数都是数字，数据会转换为数字来进行计算。</p><table><thead><tr><th><p>类型</p></th><th><p>转换前</p></th><th><p>转换后</p></th></tr></thead><tbody><tr><td><p>number</p></td><td><p>4</p></td><td><p>4</p></td></tr><tr><td><p>string</p></td><td><p>\"1\"</p></td><td><p>1</p></td></tr><tr><td><p>string</p></td><td><p>\"abc\"</p></td><td><p>NaN</p></td></tr><tr><td><p>string</p></td><td><p>\"\"</p></td><td><p>0</p></td></tr><tr><td><p>boolean</p></td><td><p>true</p></td><td><p>1</p></td></tr><tr><td><p>boolean</p></td><td><p>false</p></td><td><p>0</p></td></tr><tr><td><p>undefined</p></td><td><p>undefined</p></td><td><p>NaN</p></td></tr><tr><td><p>null</p></td><td><p>null</p></td><td><p>0</p></td></tr></tbody></table><p>预期为字符串的时候：如果有一个操作数为字符串时，使用<code data-backticks=\"1\">+</code>符号做相加运算时，会自动转换为字符串。</p><p><br></p><p>预期为布尔的时候：前面在介绍布尔类型时所提到的 9 个值会转为 false，其余转为 true</p><p><br></p><p><strong>2. 显性转换</strong></p><p><br></p><p>所谓显性转换，就是只程序员强制将一种类型转换为另外一种类型。显性转换往往会使用到一些转换方法。常见的转换方法如下：</p><ul><li><p>转换为数值类型：<code data-backticks=\"1\">Number()</code>，<code data-backticks=\"1\">parseInt()</code>，<code data-backticks=\"1\">parseFloat()</code></p></li><li><p>转换为布尔类型：<code data-backticks=\"1\">Boolean()</code></p></li><li><p>转换为字符串类型：<code data-backticks=\"1\">toString()</code>，<code data-backticks=\"1\">String()</code></p></li></ul><p>当然，除了使用上面的转换方法，我们也可以通过一些快捷方式来进行数据类型的显性转换，如下：</p><ul><li><p>转换字符串：直接和一个空字符串拼接，例如：<code data-backticks=\"1\">a = \"\" + 数据</code></p></li><li><p>转换布尔：!!数据类型，例如：<code data-backticks=\"1\">!!\"Hello\"</code></p></li><li><p>转换数值：数据*1 或 /1，例如：<code data-backticks=\"1\">\"Hello * 1\"</code></p></li></ul></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666076911315",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e51332fac4881713db369"
  },
  "interviewTitle": "JS 中支持哪些运算符？",
  "interviewContent": "<h1>运算符</h1><h2>经典真题</h2><ul><li><p>下面代码中，<em>a</em> 在什么情况下会执行输出语句打印 <em>1</em> ？</p></li></ul><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var a = ?;\nif(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3){\n \tconsole.log(1);\n}</code></pre></div><h2>1. 算术运算符</h2><p><em>JavaScript</em> 共提供 <em>10</em> 个算术运算符，用来完成基本的算术运算。</p><ul><li><p><strong>加法运算符</strong>：<code data-backticks=\"1\">x + y</code></p></li><li><p><strong>减法运算符</strong>： <code data-backticks=\"1\">x - y</code></p></li><li><p><strong>乘法运算符</strong>： <code data-backticks=\"1\">x * y</code></p></li><li><p><strong>除法运算符</strong>：<code data-backticks=\"1\">x / y</code></p></li><li><p><strong>指数运算符</strong>：<code data-backticks=\"1\">x ** y</code></p></li><li><p><strong>余数运算符</strong>：<code data-backticks=\"1\">x % y</code></p></li><li><p><strong>自增运算符</strong>：<code data-backticks=\"1\">++x</code> 或者 <code data-backticks=\"1\">x++</code></p></li><li><p><strong>自减运算符</strong>：<code data-backticks=\"1\">--x</code> 或者 <code data-backticks=\"1\">x--</code></p></li><li><p><strong>数值运算符</strong>： <code data-backticks=\"1\">+x</code></p></li><li><p><strong>负数值运算符</strong>：<code data-backticks=\"1\">-x</code></p></li></ul><p>减法、乘法、除法运算法比较单纯，就是执行相应的数学运算。</p><p><br></p><p>下面介绍其他几个算术运算符，重点是加法运算符。</p><h4>加法运算符</h4><p><strong>（1）基本规则</strong></p><p><br></p><p>加法运算符（<code data-backticks=\"1\">+</code>）是最常见的运算符，用来求两个数值的和。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">1 + 1 // 2</code></pre></div><p>JavaScript 允许非数值的相加。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">true + true // 2\n1 + true // 2</code></pre></div><p>上面代码中，第一行是两个布尔值相加，第二行是数值与布尔值相加。这两种情况，布尔值都会自动转成数值，然后再相加。</p><p><br></p><p>比较特殊的是，如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">'a' + 'bc' // \"abc\"</code></pre></div><p>如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">1 + 'a' // \"1a\"\nfalse + 'a' // \"falsea\"</code></pre></div><p>加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">'3' + 4 + 5 // \"345\"\n3 + 4 + '5' // \"75\"</code></pre></div><p>上面代码中，由于从左到右的运算次序，字符串的位置不同会导致不同的结果。</p><p><br></p><p>除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">1 - '2' // -1\n1 * '2' // 2\n1 / '2' // 0.5</code></pre></div><p>上面代码中，减法、除法和乘法运算符，都是将字符串自动转为数值，然后再运算。</p><p><br></p><p><strong>（2）对象相加</strong></p><p><br></p><p>如果运算子是对象，必须先转成原始类型的值，然后再相加。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">var obj = { p: 1 };\nobj + 2 // \"[object Object]2\"</code></pre></div><p>上面代码中，对象<code data-backticks=\"1\">obj</code>转成原始类型的值是<code data-backticks=\"1\">[object Object]</code>，再加<code data-backticks=\"1\">2</code>就得到了上面的结果。</p><p><br></p><p>对象转成原始类型的值，规则如下。</p><p><br></p><p>首先，自动调用对象的<code data-backticks=\"1\">valueOf</code>方法。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">var obj = { p: 1 };\nobj.valueOf() // { p: 1 }</code></pre></div><p>一般来说，对象的<code data-backticks=\"1\">valueOf</code>方法总是返回对象自身，这时再自动调用对象的<code data-backticks=\"1\">toString</code>方法，将其转为字符串。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">var obj = { p: 1 };\nobj.valueOf().toString() // \"[object Object]\"</code></pre></div><p>对象的<code data-backticks=\"1\">toString</code>方法默认返回<code data-backticks=\"1\">[object Object]</code>，所以就得到了最前面那个例子的结果。</p><p><br></p><p>知道了这个规则以后，就可以自己定义<code data-backticks=\"1\">valueOf</code>方法或<code data-backticks=\"1\">toString</code>方法，得到想要的结果。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">var obj = {\n  valueOf: function () {\n    return 1;\n  }\n};\n\nobj + 2 // 3</code></pre></div><p>上面代码中，我们定义<code data-backticks=\"1\">obj</code>对象的<code data-backticks=\"1\">valueOf</code>方法返回<code data-backticks=\"1\">1</code>，于是<code data-backticks=\"1\">obj + 2</code>就得到了<code data-backticks=\"1\">3</code>。这个例子中，由于<code data-backticks=\"1\">valueOf</code>方法直接返回一个原始类型的值，所以不再调用<code data-backticks=\"1\">toString</code>方法。</p><p><br></p><p>下面是自定义<code data-backticks=\"1\">toString</code>方法的例子。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">var obj = {\n  toString: function () {\n    return 'hello';\n  }\n};\n\nobj + 2 // \"hello2\"</code></pre></div><p>上面代码中，对象<code data-backticks=\"1\">obj</code>的<code data-backticks=\"1\">toString</code>方法返回字符串<code data-backticks=\"1\">hello</code>。前面说过，只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串。</p><p><br></p><p>这里有一个特例，如果运算子是一个<code data-backticks=\"1\">Date</code>对象的实例，那么会优先执行<code data-backticks=\"1\">toString</code>方法。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">var obj = new Date();\nobj.valueOf = function () { return 1 };\nobj.toString = function () { return 'hello' };\n\nobj + 2 // \"hello2\"</code></pre></div><p>上面代码中，对象<code data-backticks=\"1\">obj</code>是一个<code data-backticks=\"1\">Date</code>对象的实例，并且自定义了<code data-backticks=\"1\">valueOf</code>方法和<code data-backticks=\"1\">toString</code>方法，结果<code data-backticks=\"1\">toString</code>方法优先执行。</p><h4>余数运算符</h4><p>余数运算符（<code data-backticks=\"1\">%</code>）返回前一个运算子被后一个运算子除，所得的余数。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">12 % 5 // 2</code></pre></div><p>需要注意的是，运算结果的正负号由第一个运算子的正负号决定。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">-1 % 2 // -1\n1 % -2 // 1</code></pre></div><p>所以，为了得到负数的正确余数值，可以先使用绝对值函数。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">// 错误的写法\nfunction isOdd(n) {\n  return n % 2 === 1;\n}\nisOdd(-5) // false\nisOdd(-4) // false\n\n// 正确的写法\nfunction isOdd(n) {\n  return Math.abs(n % 2) === 1;\n}\nisOdd(-5) // true\nisOdd(-4) // false</code></pre></div><p>余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">6.5 % 2.1\n// 0.19999999999999973</code></pre></div><h4>自增和自减运算符</h4><p>自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">var x = 1;\n++x // 2\nx // 2\n\n--x // 1\nx // 1</code></pre></div><p>上面代码的变量<code data-backticks=\"1\">x</code>自增后，返回<code data-backticks=\"1\">2</code>，再进行自减，返回<code data-backticks=\"1\">1</code>。这两种情况都会使得，原始变量<code data-backticks=\"1\">x</code>的值发生改变。</p><p><br></p><p>运算之后，变量的值发生变化，这种效应叫做运算的副作用（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。</p><p><br></p><p>自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">var x = 1;\nvar y = 1;\n\nx++ // 1\n++y // 2</code></pre></div><p>上面代码中，<code data-backticks=\"1\">x</code>是先返回当前值，然后自增，所以得到<code data-backticks=\"1\">1</code>；<code data-backticks=\"1\">y</code>是先自增，然后返回新的值，所以得到<code data-backticks=\"1\">2</code>。</p><h4>数值运算符，负数值运算符</h4><p>数值运算符（<code data-backticks=\"1\">+</code>）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）。</p><p><br></p><p>数值运算符的作用在于可以将任何值转为数值（与<code data-backticks=\"1\">Number</code>函数的作用相同）。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">+true // 1\n+[] // 0\n+{} // NaN</code></pre></div><p>上面代码表示，非数值经过数值运算符以后，都变成了数值（最后一行<code data-backticks=\"1\">NaN</code>也是数值）。具体的类型转换规则，参见《数据类型转换》一章。</p><p><br></p><p>负数值运算符（<code data-backticks=\"1\">-</code>），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">var x = 1;\n-x // -1\n-(-x) // 1</code></pre></div><p>上面代码最后一行的圆括号不可少，否则会变成自减运算符。</p><p><br></p><p>数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值。</p><h4>指数运算符</h4><p>指数运算符（<code data-backticks=\"1\">**</code>）完成指数运算，前一个运算子是底数，后一个运算子是指数。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">2 ** 4 // 16</code></pre></div><p>注意，指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">// 相当于 2 ** (3 ** 2)\n2 ** 3 ** 2\n// 512</code></pre></div><p>上面代码中，由于指数运算符是右结合，所以先计算第二个指数运算符，而不是第一个。</p><h4>赋值运算符</h4><p>赋值运算符（Assignment Operators）用于给变量赋值。</p><p><br></p><p>最常见的赋值运算符，当然就是等号（<code data-backticks=\"1\">=</code>）。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">// 将 1 赋值给变量 x\nvar x = 1;\n\n// 将变量 y 的值赋值给变量 x\nvar x = y;</code></pre></div><p>赋值运算符还可以与其他运算符结合，形成变体。下面是与算术运算符的结合。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">// 等同于 x = x + y\nx += y\n\n// 等同于 x = x - y\nx -= y\n\n// 等同于 x = x * y\nx *= y\n\n// 等同于 x = x / y\nx /= y\n\n// 等同于 x = x % y\nx %= y\n\n// 等同于 x = x ** y\nx **= y</code></pre></div><p>下面是与位运算符的结合（关于位运算符，请见后文的介绍）。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">// 等同于 x = x &gt;&gt; y\nx &gt;&gt;= y\n\n// 等同于 x = x &lt;&lt; y\nx &lt;&lt;= y\n\n// 等同于 x = x &gt;&gt;&gt; y\nx &gt;&gt;&gt;= y\n\n// 等同于 x = x &amp; y\nx &amp;= y\n\n// 等同于 x = x | y\nx |= y\n\n// 等同于 x = x ^ y\nx ^= y</code></pre></div><p>这些复合的赋值运算符，都是先进行指定运算，然后将得到值返回给左边的变量。</p><h2>2. 比较运算符</h2><p>比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件。</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>2 &gt; 1 // true</code></pre></div><p>上面代码比较<code data-backticks=\"1\">2</code>是否大于<code data-backticks=\"1\">1</code>，返回<code data-backticks=\"1\">true</code>。</p><blockquote><p>注意，比较运算符可以比较各种类型的值，不仅仅是数值。</p></blockquote><p>JavaScript 一共提供了8个比较运算符。</p><ul><li><p><code data-backticks=\"1\">&gt;</code> 大于运算符</p></li><li><p><code data-backticks=\"1\">&lt;</code> 小于运算符</p></li><li><p><code data-backticks=\"1\">&lt;=</code> 小于或等于运算符</p></li><li><p><code data-backticks=\"1\">&gt;=</code> 大于或等于运算符</p></li><li><p><code data-backticks=\"1\">==</code> 相等运算符</p></li><li><p><code data-backticks=\"1\">===</code> 严格相等运算符</p></li><li><p><code data-backticks=\"1\">!=</code> 不相等运算符</p></li><li><p><code data-backticks=\"1\">!==</code> 严格不相等运算符</p></li></ul><p>这八个比较运算符分成两类：相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。</p><h4>非相等运算符：字符串的比较</h4><p>字符串按照字典顺序进行比较。</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>'cat' &gt; 'dog' // false\n'cat' &gt; 'catalog' // false</code></pre></div><p>JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>'cat' &gt; 'Cat' // true'</code></pre></div><p>上面代码中，小写的<code data-backticks=\"1\">c</code>的 Unicode 码点（<code data-backticks=\"1\">99</code>）大于大写的<code data-backticks=\"1\">C</code>的 Unicode 码点（<code data-backticks=\"1\">67</code>），所以返回<code data-backticks=\"1\">true</code>。</p><p><br></p><p>由于所有字符都有 Unicode 码点，因此汉字也可以比较。</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>'大' &gt; '小' // false</code></pre></div><p>上面代码中，“大”的 Unicode 码点是22823，“小”是23567，因此返回<code data-backticks=\"1\">false</code>。</p><h4>非相等运算符：非字符串的比较</h4><p>如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况。</p><p><br></p><p><strong>（1）原始类型值</strong></p><p><br></p><p>如果两个运算子都是原始类型的值，则是先转成数值再比较。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">5 &gt; '4' // true\n// 等同于 5 &gt; Number('4')\n// 即 5 &gt; 4\n\ntrue &gt; false // true\n// 等同于 Number(true) &gt; Number(false)\n// 即 1 &gt; 0\n\n2 &gt; true // true\n// 等同于 2 &gt; Number(true)\n// 即 2 &gt; 1</code></pre></div><p>上面代码中，字符串和布尔值都会先转成数值，再进行比较。</p><p><br></p><p>这里需要注意与<code data-backticks=\"1\">NaN</code>的比较。任何值（包括<code data-backticks=\"1\">NaN</code>本身）与<code data-backticks=\"1\">NaN</code>使用非相等运算符进行比较，返回的都是<code data-backticks=\"1\">false</code>。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">1 &gt; NaN // false\n1 &lt;= NaN // false\n'1' &gt; NaN // false\n'1' &lt;= NaN // false\nNaN &gt; NaN // false\nNaN &lt;= NaN // false</code></pre></div><p><strong>（2）对象</strong></p><p><br></p><p>如果运算子是对象，会转为原始类型的值，再进行比较。</p><p><br></p><p>对象转换成原始类型的值，算法是先调用<code data-backticks=\"1\">valueOf</code>方法；如果返回的还是对象，再接着调用<code data-backticks=\"1\">toString</code>方法，详细解释参见《数据类型的转换》一章。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">var x = [2];\nx &gt; '11' // true\n// 等同于 [2].valueOf().toString() &gt; '11'\n// 即 '2' &gt; '11'\n\nx.valueOf = function () { return '1' };\nx &gt; '11' // false\n// 等同于 [2].valueOf() &gt; '11'\n// 即 '1' &gt; '11'</code></pre></div><p>两个对象之间的比较也是如此。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">[2] &gt; [1] // true\n// 等同于 [2].valueOf().toString() &gt; [1].valueOf().toString()\n// 即 '2' &gt; '1'\n\n[2] &gt; [11] // true\n// 等同于 [2].valueOf().toString() &gt; [11].valueOf().toString()\n// 即 '2' &gt; '11'\n\n{ x: 2 } &gt;= { x: 1 } // true\n// 等同于 { x: 2 }.valueOf().toString() &gt;= { x: 1 }.valueOf().toString()\n// 即 '[object Object]' &gt;= '[object Object]'</code></pre></div><h4>严格相等运算符</h4><p><em>JavaScript</em> 提供两种相等运算符：<code data-backticks=\"1\">==</code>和<code data-backticks=\"1\">===</code>。</p><p><br></p><p>简单说，它们的区别是相等运算符（<code data-backticks=\"1\">==</code>）比较两个值是否相等，严格相等运算符（<code data-backticks=\"1\">===</code>）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（<code data-backticks=\"1\">===</code>）直接返回<code data-backticks=\"1\">false</code>，而相等运算符（<code data-backticks=\"1\">==</code>）会将它们转换成同一个类型，再用严格相等运算符进行比较。</p><p><br></p><p><strong>（1）不同类型的值</strong></p><p><br></p><p>如果两个值的类型不同，直接返回<code data-backticks=\"1\">false</code>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">1 === \"1\" // false\ntrue === \"true\" // false</code></pre></div><p>上面代码比较数值的<code data-backticks=\"1\">1</code>与字符串的“1”、布尔值的<code data-backticks=\"1\">true</code>与字符串<code data-backticks=\"1\">\"true\"</code>，因为类型不同，结果都是<code data-backticks=\"1\">false</code>。</p><p><br></p><p><strong>（2）同一类的原始类型值</strong></p><p><br></p><p>同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回<code data-backticks=\"1\">true</code>，值不同就返回<code data-backticks=\"1\">false</code>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">1 === 0x1 // true</code></pre></div><p>上面代码比较十进制的<code data-backticks=\"1\">1</code>与十六进制的<code data-backticks=\"1\">1</code>，因为类型和值都相同，返回<code data-backticks=\"1\">true</code>。</p><p><br></p><p>需要注意的是，<code data-backticks=\"1\">NaN</code>与任何值都不相等（包括自身）。另外，正<code data-backticks=\"1\">0</code>等于负<code data-backticks=\"1\">0</code>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">NaN === NaN  // false\n+0 === -0 // true</code></pre></div><p><strong>（3）复合类型值</strong></p><p><br></p><p>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">{} === {} // false\n[] === [] // false\n(function () {} === function () {}) // false</code></pre></div><p>上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是<code data-backticks=\"1\">false</code>。</p><p><br></p><p>如果两个变量引用同一个对象，则它们相等。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var v1 = {};\nvar v2 = v1;\nv1 === v2 // true</code></pre></div><p>注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj1 = {};\nvar obj2 = {};\n\nobj1 &gt; obj2 // false\nobj1 &lt; obj2 // false\nobj1 === obj2 // false</code></pre></div><p>上面的三个比较，前两个比较的是值，最后一个比较的是地址，所以都返回<code data-backticks=\"1\">false</code>。</p><p><br></p><p><strong>（4）undefined 和 null</strong></p><p><br></p><p><code data-backticks=\"1\">undefined</code>和<code data-backticks=\"1\">null</code>与自身严格相等。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">undefined === undefined // true\nnull === null // true</code></pre></div><p>由于变量声明后默认值是<code data-backticks=\"1\">undefined</code>，因此两个只声明未赋值的变量是相等的。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var v1;\nvar v2;\nv1 === v2 // true</code></pre></div><h4>严格不相等运算符</h4><p>严格相等运算符有一个对应的“严格不相等运算符”（<code data-backticks=\"1\">!==</code>），它的算法就是先求严格相等运算符的结果，然后返回相反值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">1 !== '1' // true\n// 等同于\n!(1 === '1')</code></pre></div><p>上面代码中，感叹号<code data-backticks=\"1\">!</code>是求出后面表达式的相反值。</p><h4>相等运算符</h4><p>相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">1 == 1.0\n// 等同于\n1 === 1.0</code></pre></div><p>比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。下面分成几种情况，讨论不同类型的值互相比较的规则。</p><p><br></p><p><strong>（1）原始类型值</strong></p><p><br></p><p>原始类型的值会转换成数值再进行比较。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">1 == true // true\n// 等同于 1 === Number(true)\n\n0 == false // true\n// 等同于 0 === Number(false)\n\n2 == true // false\n// 等同于 2 === Number(true)\n\n2 == false // false\n// 等同于 2 === Number(false)\n\n'true' == true // false\n// 等同于 Number('true') === Number(true)\n// 等同于 NaN === 1\n\n'' == 0 // true\n// 等同于 Number('') === 0\n// 等同于 0 === 0\n\n'' == false  // true\n// 等同于 Number('') === Number(false)\n// 等同于 0 === 0\n\n'1' == true  // true\n// 等同于 Number('1') === Number(true)\n// 等同于 1 === 1\n\n'\\n  123  \\t' == 123 // true\n// 因为字符串转为数字时，省略前置和后置的空格</code></pre></div><p>上面代码将字符串和布尔值都转为数值，然后再进行比较。</p><p><br></p><p><strong>（2）对象与原始类型值比较</strong></p><p><br></p><p>对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。</p><p><br></p><p>具体来说，先调用对象的<code data-backticks=\"1\">valueOf()</code>方法，如果得到原始类型的值，就按照上一小节的规则，互相比较；如果得到的还是对象，则再调用<code data-backticks=\"1\">toString()</code>方法，得到字符串形式，再进行比较。</p><p><br></p><p>下面是数组与原始类型值比较的例子。</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>// 数组与数值的比较\n[1] == 1 // true\n\n// 数组与字符串的比较\n[1] == '1' // true\n[1, 2] == '1,2' // true\n\n// 对象与布尔值的比较\n[1] == true // true\n[2] == true // false</code></pre></div><p>上面例子中，JavaScript 引擎会先对数组<code data-backticks=\"1\">[1]</code>调用数组的<code data-backticks=\"1\">valueOf()</code>方法，由于返回的还是一个数组，所以会接着调用数组的<code data-backticks=\"1\">toString()</code>方法，得到字符串形式，再按照上一小节的规则进行比较。</p><p><br></p><p>下面是一个更直接的例子。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const obj = {\n  valueOf: function () {\n    console.log('执行 valueOf()');\n    return obj;\n  },\n  toString: function () {\n    console.log('执行 toString()');\n    return 'foo';\n  }\n};\n\nobj == 'foo'\n// 执行 valueOf()\n// 执行 toString()\n// true</code></pre></div><p>上面例子中，<code data-backticks=\"1\">obj</code>是一个自定义了<code data-backticks=\"1\">valueOf()</code>和<code data-backticks=\"1\">toString()</code>方法的对象。这个对象与字符串<code data-backticks=\"1\">'foo'</code>进行比较时，会依次调用<code data-backticks=\"1\">valueOf()</code>和<code data-backticks=\"1\">toString()</code>方法，最后返回<code data-backticks=\"1\">'foo'</code>，所以比较结果是<code data-backticks=\"1\">true</code>。</p><p><br></p><p><strong>（3）undefined 和 null</strong></p><p><br></p><p><code data-backticks=\"1\">undefined</code>和<code data-backticks=\"1\">null</code>只有与自身比较，或者互相比较时，才会返回<code data-backticks=\"1\">true</code>；与其他类型的值比较时，结果都为<code data-backticks=\"1\">false</code>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">undefined == undefined // true\nnull == null // true\nundefined == null // true\n\nfalse == null // false\nfalse == undefined // false\n\n0 == null // false\n0 == undefined // false</code></pre></div><p><strong>（4）相等运算符的缺点</strong></p><p><br></p><p>相等运算符隐藏的类型转换，会带来一些违反直觉的结果。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">0 == ''             // true\n0 == '0'            // true\n\n2 == true           // false\n2 == false          // false\n\nfalse == 'false'    // false\nfalse == '0'        // true\n\nfalse == undefined  // false\nfalse == null       // false\nnull == undefined   // true\n\n' \\t\\r\\n ' == 0     // true</code></pre></div><p>上面这些表达式都不同于直觉，很容易出错。因此建议不要使用相等运算符（<code data-backticks=\"1\">==</code>），最好只使用严格相等运算符（<code data-backticks=\"1\">===</code>）。</p><h4>不相等运算符</h4><p>相等运算符有一个对应的“不相等运算符”（<code data-backticks=\"1\">!=</code>），它的算法就是先求相等运算符的结果，然后返回相反值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">1 != '1' // false\n\n// 等同于\n!(1 == '1')</code></pre></div><h2>3. 布尔运算符（逻辑运算符）</h2><p>布尔运算符用于将表达式转为布尔值，一共包含四个运算符。</p><ul><li><p>取反运算符：<code data-backticks=\"1\">!</code></p></li><li><p>且（并）运算符：<code data-backticks=\"1\">&amp;&amp;</code></p></li><li><p>或运算符：<code data-backticks=\"1\">||</code></p></li><li><p>三元运算符：<code data-backticks=\"1\">?:</code></p></li></ul><h4>取反运算符（!）</h4><p>取反运算符是一个感叹号，用于将布尔值变为相反值，即<code data-backticks=\"1\">true</code>变成<code data-backticks=\"1\">false</code>，<code data-backticks=\"1\">false</code>变成<code data-backticks=\"1\">true</code>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">!true // false\n!false // true</code></pre></div><p>对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为<code data-backticks=\"1\">true</code>，其他值都为<code data-backticks=\"1\">false</code>。</p><ul><li><p><code data-backticks=\"1\">undefined</code></p></li><li><p><code data-backticks=\"1\">null</code></p></li><li><p><code data-backticks=\"1\">false</code></p></li><li><p><code data-backticks=\"1\">0</code></p></li><li><p><code data-backticks=\"1\">NaN</code></p></li><li><p>空字符串（<code data-backticks=\"1\">''</code>）</p></li></ul><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">!undefined // true\n!null // true\n!0 // true\n!NaN // true\n!\"\" // true\n\n!54 // false\n!'hello' // false\n![] // false\n!{} // false</code></pre></div><p>上面代码中，不管什么类型的值，经过取反运算后，都变成了布尔值。</p><p><br></p><p>如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与<code data-backticks=\"1\">Boolean</code>函数的作用相同。这是一种常用的类型转换的写法。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">!!x\n// 等同于\nBoolean(x)</code></pre></div><p>上面代码中，不管<code data-backticks=\"1\">x</code>是什么类型的值，经过两次取反运算后，变成了与<code data-backticks=\"1\">Boolean</code>函数结果相同的布尔值。所以，两次取反就是将一个值转为布尔值的简便写法。</p><h4>且运算符（&amp;&amp;）</h4><p>且运算符（<code data-backticks=\"1\">&amp;&amp;</code>）往往用于多个表达式的求值。</p><p><br></p><p>它的运算规则是：如果第一个运算子的布尔值为<code data-backticks=\"1\">true</code>，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为<code data-backticks=\"1\">false</code>，则直接返回第一个运算子的值，且不再对第二个运算子求值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">'t' &amp;&amp; '' // \"\"\n't' &amp;&amp; 'f' // \"f\"\n't' &amp;&amp; (1 + 2) // 3\n'' &amp;&amp; 'f' // \"\"\n'' &amp;&amp; '' // \"\"\n\nvar x = 1;\n(1 - 1) &amp;&amp; ( x += 1) // 0\nx // 1</code></pre></div><p>上面代码的最后一个例子，由于且运算符的第一个运算子的布尔值为<code data-backticks=\"1\">false</code>，则直接返回它的值<code data-backticks=\"1\">0</code>，而不再对第二个运算子求值，所以变量<code data-backticks=\"1\">x</code>的值没变。</p><p><br></p><p>这种跳过第二个运算子的机制，被称为“短路”。有些程序员喜欢用它取代<code data-backticks=\"1\">if</code>结构，比如下面是一段<code data-backticks=\"1\">if</code>结构的代码，就可以用且运算符改写。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">if (i) {\n  doSomething();\n}\n\n// 等价于\n\ni &amp;&amp; doSomething();</code></pre></div><p>上面代码的两种写法是等价的，但是后一种不容易看出目的，也不容易除错，建议谨慎使用。</p><p><br></p><p>且运算符可以多个连用，这时返回第一个布尔值为<code data-backticks=\"1\">false</code>的表达式的值。如果所有表达式的布尔值都为<code data-backticks=\"1\">true</code>，则返回最后一个表达式的值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">true &amp;&amp; 'foo' &amp;&amp; '' &amp;&amp; 4 &amp;&amp; 'foo' &amp;&amp; true\n// ''\n\n1 &amp;&amp; 2 &amp;&amp; 3\n// 3</code></pre></div><p>上面代码中，例一里面，第一个布尔值为<code data-backticks=\"1\">false</code>的表达式为第三个表达式，所以得到一个空字符串。例二里面，所有表达式的布尔值都是<code data-backticks=\"1\">true</code>，所以返回最后一个表达式的值<code data-backticks=\"1\">3</code>。</p><h4>或运算符（||）</h4><p>或运算符（<code data-backticks=\"1\">||</code>）也用于多个表达式的求值。它的运算规则是：如果第一个运算子的布尔值为<code data-backticks=\"1\">true</code>，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为<code data-backticks=\"1\">false</code>，则返回第二个运算子的值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">'t' || '' // \"t\"\n't' || 'f' // \"t\"\n'' || 'f' // \"f\"\n'' || '' // \"\"</code></pre></div><p>短路规则对这个运算符也适用。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var x = 1;\ntrue || (x = 2) // true\nx // 1</code></pre></div><p>上面代码中，或运算符的第一个运算子为<code data-backticks=\"1\">true</code>，所以直接返回<code data-backticks=\"1\">true</code>，不再运行第二个运算子。所以，<code data-backticks=\"1\">x</code>的值没有改变。这种只通过第一个表达式的值，控制是否运行第二个表达式的机制，就称为“短路”（short-cut）。</p><p><br></p><p>或运算符可以多个连用，这时返回第一个布尔值为<code data-backticks=\"1\">true</code>的表达式的值。如果所有表达式都为<code data-backticks=\"1\">false</code>，则返回最后一个表达式的值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">false || 0 || '' || 4 || 'foo' || true\n// 4\n\nfalse || 0 || ''\n// ''</code></pre></div><p>上面代码中，例一里面，第一个布尔值为<code data-backticks=\"1\">true</code>的表达式是第四个表达式，所以得到数值4。例二里面，所有表达式的布尔值都为<code data-backticks=\"1\">false</code>，所以返回最后一个表达式的值。</p><p><br></p><p>或运算符常用于为一个变量设置默认值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function saveText(text) {\n  text = text || '';\n  // ...\n}\n\n// 或者写成\nsaveText(this.text || '')</code></pre></div><p>上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串。</p><h4>三元条件运算符（?:）</h4><p>三元条件运算符由问号（?）和冒号（:）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为<code data-backticks=\"1\">true</code>，则返回第二个表达式的值，否则返回第三个表达式的值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">'t' ? 'hello' : 'world' // \"hello\"\n0 ? 'hello' : 'world' // \"world\"</code></pre></div><p>上面代码的<code data-backticks=\"1\">t</code>和<code data-backticks=\"1\">0</code>的布尔值分别为<code data-backticks=\"1\">true</code>和<code data-backticks=\"1\">false</code>，所以分别返回第二个和第三个表达式的值。</p><p><br></p><p>通常来说，三元条件表达式与<code data-backticks=\"1\">if...else</code>语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，<code data-backticks=\"1\">if...else</code>是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用<code data-backticks=\"1\">if..else</code>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">console.log(true ? 'T' : 'F');</code></pre></div><p>上面代码中，<code data-backticks=\"1\">console.log</code>方法的参数必须是一个表达式，这时就只能使用三元条件表达式。如果要用<code data-backticks=\"1\">if...else</code>语句，就必须改变整个代码写法了。</p><h2>4. 位运算符</h2><p>按位运算符是将操作数换算成 <em>32</em> 位的二进制整数，然后按每一位来进行运算。例如：</p><p><br></p><p><em>5</em> 的 <em>32</em> 位为：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>00000000000000000000000000000101</code></pre></div><p><em>100</em> 的 <em>32</em> 位为：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>00000000000000000000000001100100</code></pre></div><p><em>15</em> 的 <em>32</em> 位为：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>00000000000000000000000000001111</code></pre></div><h4>按位非</h4><p>按位非运算符<code data-backticks=\"1\">~</code>会把数字转为32位二进制整数，然后反转每一位。所有的 1 变为 0，所有的 0 变为 1</p><p><br></p><p>例如：</p><p><br></p><p>5 的 32 位为：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>00000000000000000000000000000101</code></pre></div><p>~5 的 32 位为：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>11111111111111111111111111111010  </code></pre></div><p>转换出来就为 -6</p><p><br></p><p>按位非，实质上是对操作数求负，然后减去1。</p><h4>按位与</h4><p>按位或运算符<code data-backticks=\"1\">&amp;</code>会把两个数字转为 32 位二进制整数，并对两个数的每一位执行按位与运算。按位与的规则如下表：</p><table><thead><tr><th><p>第一个数字</p></th><th><p>第二个数字</p></th><th><p>结果</p></th></tr></thead><tbody><tr><td><p>1</p></td><td><p>1</p></td><td><p>1</p></td></tr><tr><td><p>1</p></td><td><p>0</p></td><td><p>0</p></td></tr><tr><td><p>0</p></td><td><p>1</p></td><td><p>0</p></td></tr><tr><td><p>0</p></td><td><p>0</p></td><td><p>0</p></td></tr></tbody></table><p>具体示例：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">console.log(12 &amp; 10); // 8</code></pre></div><p>12 的 32 位二进制表示为：1100</p><p>10 的 32 位二进制表示为：1010</p><p><br></p><p>按位与的结果为：1000</p><h4>按位或</h4><p>按位或运算符<code data-backticks=\"1\">|</code>会把两个数字转为 32 位二进制整数，并对两个数的每一位执行按位或运算。按位或的规则如下表：</p><table><thead><tr><th><p>第一个数字</p></th><th><p>第二个数字</p></th><th><p>结果</p></th></tr></thead><tbody><tr><td><p>1</p></td><td><p>1</p></td><td><p>1</p></td></tr><tr><td><p>1</p></td><td><p>0</p></td><td><p>1</p></td></tr><tr><td><p>0</p></td><td><p>1</p></td><td><p>1</p></td></tr><tr><td><p>0</p></td><td><p>0</p></td><td><p>0</p></td></tr></tbody></table><p>具体示例：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">console.log(12 | 10); // 14</code></pre></div><p>12 的 32 位二进制表示为：1100</p><p>10 的 32 位二进制表示为：1010</p><p><br></p><p>按位或的结果为：1110</p><h4>按位异或</h4><p>按位或运算符<code data-backticks=\"1\">^</code>会把两个数字转为 32 位二进制整数，并对两个数的每一位执行按位异或运算。运算规则为两位不同返回 1，两位相同返回 0，如下表：</p><table><thead><tr><th><p>第一个数字</p></th><th><p>第二个数字</p></th><th><p>结果</p></th></tr></thead><tbody><tr><td><p>1</p></td><td><p>1</p></td><td><p>0</p></td></tr><tr><td><p>1</p></td><td><p>0</p></td><td><p>1</p></td></tr><tr><td><p>0</p></td><td><p>1</p></td><td><p>1</p></td></tr><tr><td><p>0</p></td><td><p>0</p></td><td><p>0</p></td></tr></tbody></table><p>具体示例：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">console.log(12 ^ 10); // 6</code></pre></div><p>12 的 32 位二进制表示为：1100</p><p>10 的 32 位二进制表示为：1010</p><p><br></p><p>按位异或的结果为：0110</p><p><br></p><p>按位异或如果是非整数值，如果两个操作数中只有一个为真，就返回 1，如果两个操作数都是真，或者都是假，就返回 0，示例如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">console.log(true ^ \"Hello\"); // 1\nconsole.log(false ^ \"Hello\"); // 0\nconsole.log(true ^ true); // 0\nconsole.log(\"Hello\" ^ \"Hello\"); // 0\nconsole.log(false ^ false); // 0\nconsole.log(true ^ false); // 1</code></pre></div><p>注意这里的 Hello 被转换为了 NaN</p><h4>按位移位</h4><p>按位移位运算符<code data-backticks=\"1\">&lt;&lt;</code>和<code data-backticks=\"1\">&gt;&gt;</code>会将所有位向左或者向右移动指定的数量，实际上就是高效率地将数字乘以或者除以 2 的指定数的次方。</p><p><br></p><p><code data-backticks=\"1\">&lt;&lt;</code>：乘以 2 的指定数次方</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">console.log(2&lt;&lt;2); // 8</code></pre></div><p>2 乘以 2 的 2 次方</p><p><br></p><p>00000010 转换为 00001000</p><p><br></p><p><code data-backticks=\"1\">&gt;&gt;</code>：除以 2 的指定数次方</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">console.log(16&gt;&gt;1); // 8</code></pre></div><p>16 除以 2 的 1 次方</p><p><br></p><p>00010000转换为00001000</p><h2>5. 其他运算符</h2><h4><em>void</em> 运算符</h4><p><em>void</em> 运算符的作用是执行一个表达式，然后不返回任何值，或者说返回 <em>undefined</em>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">void 0 // undefined\nvoid(0) // undefined</code></pre></div><p>上面是 <em>void</em> 运算符的两种写法，都正确。建议采用后一种形式，即总是使用圆括号。</p><p><br></p><p>因为 <em>void</em> 运算符的优先性很高，如果不使用括号，容易造成错误的结果。</p><p><br></p><p>比如，<em>“void 4 + 7”</em> 实际上等同于 <em>“(void 4) + 7”</em>。</p><p><br></p><p>下面是 <em>void</em> 运算符的一个例子。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var x = 3;\nvoid (x = 5) //undefined\nx // 5</code></pre></div><p>这个运算符的主要用途是浏览器的书签工具（<em>Bookmarklet</em>），以及在超级链接中插入代码防止网页跳转。</p><p><br></p><p>请看下面的代码。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">&lt;script&gt;\nfunction f() {\n  console.log('Hello World');\n}\n&lt;/script&gt;\n&lt;a href=\"http://example.com\" onclick=\"f(); return false;\"&gt;点击&lt;/a&gt;</code></pre></div><p>上面代码中，点击链接后，会先执行 <em>onclick</em> 的代码，由于 <em>onclick</em> 返回 <em>false</em>，所以浏览器不会跳转到 <em>example.com</em>。</p><p><br></p><p><em>void</em> 运算符可以取代上面的写法。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">&lt;a href=\"javascript: void(f())\"&gt;文字&lt;/a&gt;</code></pre></div><p>下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">&lt;a href=\"javascript: void(document.form.submit())\"&gt;\n  提交\n&lt;/a&gt;</code></pre></div><h4>逗号运算符</h4><p>逗号运算符用于对两个表达式求值，并返回后一个表达式的值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">'a', 'b' // \"b\"\n\nvar x = 0;\nvar y = (x++, 10);\nx // 1\ny // 10</code></pre></div><p>上面代码中，逗号运算符返回后一个表达式的值。</p><p><br></p><p>逗号运算符的一个用途是，在返回一个值之前，进行一些辅助操作。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">var value = (console.log('Hi!'), true);\n// Hi!\n\nvalue // true</code></pre></div><p>上面代码中，先执行逗号之前的操作，然后返回逗号后面的值。</p><h2>6. 运算顺序</h2><h4>优先级</h4><p><em>JavaScript</em> 各种运算符的优先级别（<em>Operator Precedence</em>）是不一样的。优先级高的运算符先执行，优先级低的运算符后执行。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">4 + 5 * 6 // 34</code></pre></div><p>上面的代码中，乘法运算符（ * ）的优先性高于加法运算符（ + ），所以先执行乘法，再执行加法，相当于下面这样。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">4 + (5 * 6) // 34</code></pre></div><p>如果多个运算符混写在一起，常常会导致令人困惑的代码。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var x = 1;\nvar arr = [];\n\nvar y = arr.length &lt;= 0 || arr[0] === undefined ? x : arr[0];</code></pre></div><p>上面代码中，变量 <em>y</em> 的值就很难看出来，因为这个表达式涉及 <em>5</em> 个运算符，到底谁的优先级最高，实在不容易记住。</p><p><br></p><p>根据语言规格，这五个运算符的优先级从高到低依次为：小于等于（ &lt;= )、严格相等（ === ）、或（ || ）、三元（ ?: ）、等号（ = ）。因此上面的表达式，实际的运算顺序如下。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var y = ((arr.length &lt;= 0) || (arr[0] === undefined)) ? x : arr[0];</code></pre></div><p>记住所有运算符的优先级，是非常难的，也是没有必要的。</p><h4>圆括号的作用</h4><p>圆括号可以用来提高运算的优先级，因为它的优先级是最高的，即圆括号中的表达式会第一个运算。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">(4 + 5) * 6 // 54</code></pre></div><p>上面代码中，由于使用了圆括号，加法会先于乘法执行。</p><p><br></p><p>运算符的优先级别十分繁杂，且都是硬性规定，因此建议总是使用圆括号，保证运算顺序清晰可读，这对代码的维护和除错至关重要。</p><p><br></p><p>顺便说一下，圆括号不是运算符，而是一种语法结构。它一共有两种用法：一种是把表达式放在圆括号之中，提升运算的优先级；另一种是跟在函数的后面，作用是调用函数。</p><p><br></p><p>注意，因为圆括号不是运算符，所以不具有求值作用，只改变运算的优先级。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var x = 1;\n(x) = 2;</code></pre></div><p>上面代码的第二行，如果圆括号具有求值作用，那么就会变成 <em>1 = 2</em>，这是会报错了。但是，上面的代码可以运行，这验证了圆括号只改变优先级，不会求值。</p><p><br></p><p>这也意味着，如果整个表达式都放在圆括号之中，那么不会有任何效果。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">(expression)\n// 等同于\nexpression</code></pre></div><p>函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function f() {\n  return 1;\n}\n\n(f) // function f(){return 1;}\nf() // 1</code></pre></div><p>上面代码中，函数放在圆括号之中会返回函数本身，圆括号跟在函数后面则是调用函数。</p><p><br></p><p>圆括号之中，只能放置表达式，如果将语句放在圆括号之中，就会报错。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">(var a = 1)\n// SyntaxError: Unexpected token var</code></pre></div><h4>左结合和右结合</h4><p>对于优先级别相同的运算符，同时出现的时候，就会有计算顺序的问题。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">a OP b OP c</code></pre></div><p>上面代码中，<em>OP</em> 表示运算符。它可以有两种解释方式。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">// 方式一\n(a OP b) OP c\n\n// 方式二\na OP (b OP c)</code></pre></div><p>上面的两种方式，得到的计算结果往往是不一样的。</p><p><br></p><p>方式一是将左侧两个运算数结合在一起，采用这种解释方式的运算符，称为“左结合”（<em>left-to-right associativity</em>）运算符；</p><p><br></p><p>方式二是将右侧两个运算数结合在一起，这样的运算符称为“右结合”运算符（<em>right-to-left associativity</em>）。</p><p><br></p><p><em>JavaScript</em> 语言的大多数运算符是“左结合”，请看下面加法运算符的例子。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">x + y + z\n\n// 引擎解释如下\n(x + y) + z</code></pre></div><p>上面代码中，<em>x</em> 与 <em>y</em> 结合在一起，它们的预算结果再与 <em>z</em> 进行运算。</p><p><br></p><p>少数运算符是“右结合”，其中最主要的是赋值运算符（ = ）和三元条件运算符（ ?: ）。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">w = x = y = z;\nq = a ? b : c ? d : e ? f : g;</code></pre></div><p>上面代码的解释方式如下。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">w = (x = (y = z));\nq = a ? b : (c ? d : (e ? f : g));</code></pre></div><p>上面的两行代码，都是右侧的运算数结合在一起。</p><p><br></p><p>另外，指数运算符（**）也是右结合。</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">2 ** 3 ** 2\n// 相当于 2 ** (3 ** 2)\n// 512</code></pre></div><h2>真题解答</h2><ul><li><p>下面代码中，<em>a</em> 在什么情况下会执行输出语句打印 <em>1</em> ？</p></li></ul><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var a = ?;\nif(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3){\n \tconsole.log(1);\n}</code></pre></div><blockquote><p>参考答案：</p><p><br></p><p>方法一：利用 <em>toString( )</em> 方法</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var a = {\n i: 1,\n toString() {\n     return a.i++;\n }\n}\nif (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {\n console.log('1');\n}</code></pre></div><p>方法二：利用 <em>valueOf( )</em> 方法</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var a = {\n i: 1,\n valueOf() {\n     return a.i++\n }\n}\nif (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {\n console.log('1');\n}</code></pre></div></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666076979038",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e516c2fac4881713db374"
  },
  "interviewTitle": "说一说你对 JS 中原型与原型链的理解？",
  "interviewContent": "<h1>原型和原型链</h1><h2>经典真题</h2><ul><li><p>说一说你对 <em>JavaScript</em> 中原型与原型链的理解？（美团 <em>2019</em>年）</p></li><li><p>对一个构造函数实例化后，它的原型链指向什么？</p></li></ul><h2>原型与原型链介绍</h2><p>在 <em>Brendan Eich</em> 设计 <em>JavaScript</em> 时，借鉴了 <em>Self</em> 和 <em>Smalltalk</em> 这两门基于原型的语言。</p><p><br></p><p>之所以选择基于原型的对象系统，是因为 <em>Brendan Eich</em> 一开始就没有打算在 <em>JavaScript</em> 中加入类的概念，因为 <em>JavaScript</em> 的设计初衷就是为非专业的开发人员（例如网页设计者）提供一个方便的工具。由于大部分网页设计者都没有任何的编程背景，所以在设计 <em>JavaScript</em> 时也是尽可能使其简单、易学。</p><p><br></p><p>这因为如此，<em>JavaScript</em> 中的原型以及原型链成为了这门语言最大的一个特点，在面试的时候，面试官也经常会围绕原型和原型链展开提问。</p><p><br></p><p><em>JavaScript</em> 是一门基于原型的语言，<strong>对象的产生是通过原型对象而来的</strong>。</p><p><br></p><p><em>ES5</em> 中提供了 <em>Object.create</em> 方法，可以用来克隆对象。</p><p><br></p><p>示例如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const person = {\n    arms: 2,\n    legs: 2,\n    walk() {\n        console.log('walking');\n    }\n}\nconst zhangsan = Object.create(person);\nconsole.log(zhangsan.arms); // 2\nconsole.log(zhangsan.legs); // 2\nzhangsan.walk(); // walking\nconsole.log(zhangsan.__proto__ === person); // true</code></pre></div><p>在上面的示例中，我们通过 <em>Object.create</em> 方法来对 <em>person</em> 对象进行克隆，克隆出来了一个名为 <em>zhangsan</em> 的对象，所以 <em>person</em> 对象就是 <em>zhangsan</em> 这个对象的原型对象。</p><p><br></p><p><em>person</em> 对象上面的属性和方法，<em>zhangsan</em> 这个对象上面都有。</p><p><br></p><p>通过 __<em>proto</em>__ 属性，我们可以访问到一个对象的原型对象。</p><p><br></p><p>从上面的代码可以看出，当我们打印<code data-backticks=\"1\">zhangsan.__proto__ === person</code>，返回的是 <em>true</em> ，因为对于 <em>zhangsan</em> 这个对象而言，它的原型对象就是 <em>person</em> 这个对象。</p><p><br></p><p>我们在使用 <em>Object.create</em> 方法来克隆对象的时候，还可以传入第 <em>2</em> 个参数，第 <em>2</em> 个参数是一个 <em>JSON</em> 对象，该对象可以书写新对象的<strong>新属性</strong>以及<strong>属性特性</strong>。</p><p><br></p><p>通过这种方式，基于对象创建的新对象，可以继承祖辈对象的属性和方法，这其实就是一个继承的关系，来看一个示例：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const person = {\n    arms: 2,\n    legs: 2,\n    walk() {\n        console.log('walking');\n    }\n}\nconst zhangsan = Object.create(person, {\n    name: {\n        value: \"zhangsan\",\n    },\n    age: {\n        value: 18,\n    },\n    born: {\n        value: \"chengdu\"\n    }\n});\nconst zhangxiaosan = Object.create(zhangsan, {\n    name: {\n        value: \"zhangxiaosan\"\n    },\n    age: {\n        value: 1\n    }\n})\nconsole.log(zhangxiaosan.name); // zhangxiaosan\nconsole.log(zhangxiaosan.age); // 1\nconsole.log(zhangxiaosan.born); // chengdu\nconsole.log(zhangxiaosan.arms); // 2\nconsole.log(zhangxiaosan.legs); // 2\nzhangxiaosan.walk(); // walking\nconsole.log(zhangsan.isPrototypeOf(zhangxiaosan)); // true\nconsole.log(person.isPrototypeOf(zhangxiaosan)); // true</code></pre></div><p>该例中，<em>zhangsan</em> 这个对象是从 <em>person</em> 这个对象克隆而来的，而 <em>zhangxiaosan</em> 这个对象又是从 <em>zhangsan</em> 这个对象克隆而来，以此<strong>形成了一条原型链</strong>。无论是 <em>person</em> 对象，还是 <em>zhangsan</em> 对象上面的属性和方法，<em>zhangxiaosan</em> 这个对象都能继承到。</p><p><br></p><p>来看下面的图：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-10-050603.png\" alt=\"image-20210810130602385\" contenteditable=\"false\"><br></p><p><br></p><p>这就是 <em>JavaScript</em> 中最原始的创建对象的方式，一个对象是通过克隆另外一个对象所得到的。就像克隆羊多莉一样，通过克隆可以创造一个一模一样的对象，被克隆的对象是新对象的原型对象。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-10-051614.png\" alt=\"image-20210810131613519\" contenteditable=\"false\"><br></p><p><br></p><p>但是，随着 <em>JavaScript</em> 语言的发展，这样创建对象的方式还是太过于麻烦了。开发者还是期望 <em>JavaScript</em> 能够像 <em>Java、C#</em> 等标准面向对象语言一样，通过类来批量的生成对象。于是出现了通过构造函数来模拟类的形式。</p><p><br></p><p>来看下面的例子：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function Computer(name, price) {\n    // 属性写在类里面 \n    this.name = name;\n    this.price = price;\n}\n// 方法挂在原型对象上面\nComputer.prototype.showSth = function () {\n    console.log(`这是一台${this.name}电脑`);\n}\n\nconst apple = new Computer(\"苹果\", 12000);\nconsole.log(apple.name); // 苹果\nconsole.log(apple.price); // 12000\napple.showSth(); // 这是一台苹果电脑\n\nconst huawei = new Computer(\"华为\", 7000);\nconsole.log(huawei.name); // 华为\nconsole.log(huawei.price); // 7000\nhuawei.showSth(); // 这是一台华为电脑</code></pre></div><p>在上面的例子中，我们书写了一个 <em>Computer</em> 的函数，我们称之为构造函数，为了区分普通函数和构造函数，一般构造函数的函数名<strong>首字母会大写</strong>。</p><p><br></p><p>区别于普通函数的直接调用，构造函数一般通过配合 <em>new</em> 关键字一起使用，每当我们 <em>new</em> 一次，就会生成一个新的对象，而在构造函数中的 <em>this</em> 就指向这个新生成的对象。</p><p><br></p><p>在上面的例子中，我们 <em>new</em> 了两次，所以生成了两个对象，我们把这两个对象分别存储到 <em>apple</em> 和 <em>huawei</em> 这两个变量里面。</p><p><br></p><p>有一个非常有意思的现象，就是我们在书写 <em>Computer</em> 构造函数的实例方法的时候，并没有将这个方法书写在构造函数里面，而是写在了 <em>Computer.prototype</em> 上面，那么这个 <em>Computer.prototype</em> 是啥呢？</p><p><br></p><p>这个  <em>Computer.prototype</em>  实际上就是 <em>Computer</em> 实例对象的原型对象。要搞清楚这个，看下面的图：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-27-063331.png\" alt=\"image-20211027143330933\" contenteditable=\"false\"><br></p><p><br></p><p>这是最重要的一个三角关系，也是我往往要求学生记下来的三角关系。</p><p><br></p><p>通过上图，我们可以得出以下的结论：</p><ul><li><p><em>JavaScript</em> 中每个对象都有一个原型对象。可以通过 __<em>proto</em>__ 属性来访问到对象的原型对象。</p></li><li><p>构造函数的 <em>prototype</em> 属性指向一个对象，这个对象是该构造函数实例化出来的对象的原型对象。</p></li><li><p>原型对象的 <em>constructor</em> 属性也指向其构造函数。</p></li><li><p>实例对象的 <em>constructor</em> 属性是从它的原型对象上面访问到。</p></li></ul><p>实践才是检验真理的唯一标准。接下来我们在代码中来验证一下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function Computer(name, price) {\n    // 属性写在类里面 \n    this.name = name;\n    this.price = price;\n}\n// 方法挂在原型对象上面\nComputer.prototype.showSth = function () {\n    console.log(`这是一台${this.name}电脑`);\n}\n\nconst apple = new Computer(\"苹果\", 12000);\n\nconsole.log(apple.__proto__ === Computer.prototype); // true\nconsole.log(apple.__proto__.constructor === Computer); // true</code></pre></div><p>在上面的代码中，<em>apple</em> 是从 <em>Computer</em> 这个构造函数中实例化出来的对象，我们通过  __<em>proto</em>__  来访问到 <em>apple</em> 的原型对象，而这个原型对象和 <em>Computer.prototype</em> 是等价的。另外， 我们也发现 <em>apple</em> 和它原型对象的 <em>constructor</em> 属性都指向 <em>Computer</em> 这个构造函数。</p><p><br></p><p>接下来我们还可以来验证内置的构造函数是不是也是这样的关系，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function Computer(name, price) {\n    // 属性写在类里面 \n    this.name = name;\n    this.price = price;\n}\n// 方法挂在原型对象上面\nComputer.prototype.showSth = function () {\n    console.log(`这是一台${this.name}电脑`);\n}\n\nconst apple = new Computer(\"苹果\", 12000);\n\nconsole.log(apple.__proto__ === Computer.prototype); // true\nconsole.log(apple.__proto__.constructor === Computer); // true\n\n// 数组的三角关系\nvar arr = [];\nconsole.log(arr.__proto__ === Array.prototype); // true\n\n// 其实所有的构造函数的原型对象都相同\nconsole.log(Computer.__proto__ === Array.__proto__); // true\nconsole.log(Computer.__proto__ === Date.__proto__); // true\nconsole.log(Computer.__proto__ === Number.__proto__);  // true\nconsole.log(Computer.__proto__ === Function.__proto__);  // true\nconsole.log(Computer.__proto__ === Object.__proto__);  // true\nconsole.log(Computer.__proto__); // {}</code></pre></div><p>通过上面的代码，我们发现所有的构造函数，无论是自定义的还是内置的，它们的原型对象都是同一个对象。</p><p><br></p><p>如果你能够把上面的三角关系理清楚，恭喜你，你已经把整个原型和原型链的知识掌握一大部分。</p><p><br></p><p>如果你还想继续往下深究，那么上面的图可以扩展成这样：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-23-093053.jpg\" alt=\"WechatIMG195\" contenteditable=\"false\"><br></p><p><br></p><p>在 <em>JavaScript</em> 中，每一个对象，都有一个原型对象。而原型对象上面也有一个自己的原型对象，一层一层向上找，最终会到达 <em>null</em>。</p><p><br></p><p>我们可以在上面代码的基础上，继续进行验证，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function Computer(name, price) {\n    // 属性写在类里面 \n    this.name = name;\n    this.price = price;\n}\n// 方法挂在原型对象上面\nComputer.prototype.showSth = function () {\n    console.log(`这是一台${this.name}电脑`);\n}\n\nvar apple = new Computer(\"苹果\", 12000);\n\nconsole.log(apple.__proto__.__proto__); // [Object: null prototype] {}\nconsole.log(apple.__proto__.__proto__.__proto__); // null\nconsole.log(apple.__proto__.__proto__ === Object.prototype); // true</code></pre></div><p>可以看到，在上面的代码中，我们顺着原型链一层一层往上找，最终到达了 <em>null</em>。</p><p><br></p><p>但是目前来看我们这个图还是不完整，既然构造函数的原型对象也是对象，那么必然该对象也有自己的原型，所以完整的图其实如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-23-093129.jpg\" alt=\"WechatIMG194\" contenteditable=\"false\"><br></p><p><br></p><p>下面可以简单验证一下，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// 自定义构造函数函数\nfunction Computer() {}\n\nconsole.log(Computer.__proto__.__proto__.__proto__); // null\nconsole.log(Computer.__proto__.constructor.__proto__ === Computer.__proto__); // true\nconsole.log(Computer.__proto__.__proto__.constructor.__proto__ === Computer.__proto__); // true\n<br></code></pre></div><h2>真题解答</h2><ul><li><p>说一说你对 <em>JavaScript</em> 中原型与原型链的理解？（美团 <em>2019</em>年）</p></li></ul><blockquote><p>参考答案：</p><ul><li><p>每个对象都有一个 __<em>proto</em>__  属性，该属性指向自己的原型对象</p></li><li><p>每个构造函数都有一个 <em>prototype</em> 属性，该属性指向实例对象的原型对象</p></li><li><p>原型对象里的 <em>constructor</em> 指向构造函数本身</p></li></ul><p>如下图：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-27-063331.png\" alt=\"image-20211027143330933\" contenteditable=\"false\"><br></p><p><br></p><p>每个对象都有自己的原型对象，而原型对象本身，也有自己的原型对象，从而形成了一条原型链条。</p><p><br></p><p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p></blockquote><ul><li><p>对一个构造函数实例化后，它的原型链指向什么？</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>指向该构造函数实例化出来对象的原型对象。</p><p><br></p><p>对于构造函数来讲，可以通过 <em>prototype</em> 访问到该对象。</p><p><br></p><p>对于实例对象来讲，可以通过隐式属性 __<em>proto</em>__ 来访问到。</p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666077036383",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e51992fac4881713db378"
  },
  "interviewTitle": "谈谈你对 JS 执行上下文栈理解",
  "interviewContent": "<h1>执行栈和执行上下文</h1><h2>经典真题</h2><ul><li><p>谈谈你对 <em>JavaScript</em> 执行上下文栈理解</p></li></ul><h2>执行上下文</h2><p>执行上下文，英文全称为 <em>Execution Context</em>，一句话概括就是“代码（全局代码、函数代码）执行前进行的准备工作”，也称之为“执行上下文环境”。</p><p><br></p><p>运行 <em>JavaScript</em> 代码时，当代码执行进入一个环境时，就会为该环境创建一个执行上下文，它会在你运行代码前做一些准备工作，如确定作用域，创建局部变量对象等。</p><p><br></p><p>具体做了什么我们后面再说，先来看下 <em>JavaScript</em> 执行环境有哪些？</p><p><br></p><p><strong><em>JavaScript</em> 中执行环境</strong></p><ol><li><p>全局环境</p></li><li><p>函数环境</p></li><li><p><em>eval</em> 函数环境 （已不推荐使用）</p></li></ol><p>那么与之对应的执行上下文类型同样有 <em>3</em> 种：</p><ol><li><p>全局执行上下文</p></li><li><p>函数执行上下文</p></li><li><p><em>eval</em> 函数执行上下文</p></li></ol><p><em>JavaScript</em> 运行时首先会进入全局环境，对应会生成全局上下文。程序代码中基本都会存在函数，那么<strong>调用函数</strong>，就会进入函数执行环境，对应就会生成该函数的执行上下文。</p><p><br></p><p>由于代码中会声明多个函数，对应的函数执行上下文也会存在多个。在 <em>JavaScript</em> 中，通过栈的存取方式来管理执行上下文，我们可称其为执行栈，或函数调用栈（<em>Call Stack</em>）。</p><h2>栈数据结构</h2><p>先来简单复习一下栈这种数据结构。</p><p><br></p><p>要简单理解栈的存取方式，我们可以通过类比乒乓球盒子来分析。如下图：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-02-060310.png\" alt=\"img\" contenteditable=\"false\"><br></p><p><br></p><p>栈遵循**“先进后出，后进先出”**的规则，或称 <strong><em>LIFO</em></strong> （”<em>Last In First Out</em>“）规则。</p><p><br></p><p>如图所示，我们只能从栈顶取出或放入乒乓球，最先放进盒子的总是最后才能取出。</p><p><br></p><p>栈中**“放入/取出”<strong>，也可称为</strong>“入栈/出栈”**。</p><p><br></p><p>总结栈数据结构的特点：</p><ol><li><p>后进先出，先进后出</p></li><li><p>出口在顶部，且仅有一个</p></li></ol><p><strong>执行栈（函数调用栈）</strong></p><p><br></p><p>理解完栈的存取方式，我们接着分析 <em>JavaScript</em> 中如何通过栈来管理多个执行上下文。</p><p><br></p><p>程序执行进入一个执行环境时，它的执行上下文就会被创建，并被推入执行栈中（入栈）；程序执行完成时，它的执行上下文就会被销毁，并从栈顶被推出（出栈），控制权交由下一个执行上下文。</p><p><br></p><p>因为 <em>JavaScript</em> 在执行代码时最先进入全局环境，所以<strong>处于栈底的永远是全局环境的执行上下文</strong>。而处于<strong>栈顶的是当前正在执行函数的执行上下文</strong>。</p><p><br></p><p>当函数调用完成后，它就会从栈顶被推出，理想的情况下，闭包会阻止该操作，闭包可以参阅《闭包》章节。</p><p><br></p><p>而全局环境只有一个，对应的全局执行上下文也只有一个，只有当页面被关闭之后它才会从执行栈中被推出，否则一直存在于栈底。</p><p><br></p><p>下面我们来看一段具体的代码示例：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function foo () { \n    function bar () {        \n      return 'I am bar';\n    }\n    return bar();\n}\nfoo();</code></pre></div><p>对应图解如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-02-060848.png\" alt=\"image-20211002140848188\" contenteditable=\"false\"><br></p><p><br></p><p><strong>执行上下文的数量限制（堆栈溢出）</strong></p><p><br></p><p>执行上下文可存在多个，虽然没有明确的数量限制，但如果超出栈分配的空间，会造成堆栈溢出。常见于递归调用，没有终止条件造成死循环的场景。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// 递归调用自身\nfunction foo() {\n    foo();\n}\nfoo();\n// 报错： Uncaught RangeError: Maximum call stack size exceeded</code></pre></div><h2>执行上下文生命周期</h2><p>前面我们有说到，运行 <em>JavaScript</em> 代码时，当代码执行进入一个环境时，就会为该环境创建一个执行上下文，它会在你运行代码前做一些准备工作。接下来我们就来看一下具体会做哪些准备工作。</p><p><br></p><p>具体要做的事，和执行上下文的生命周期有关。</p><p><br></p><p>执行上下文的生命周期有两个阶段：</p><ol><li><p>创建阶段（<strong>进入</strong>执行上下文）：函数被调用时，进入函数环境，为其创建一个执行上下文，此时进入创建阶段。</p></li><li><p>执行阶段（代码<strong>执行</strong>）：执行函数中代码时，此时执行上下文进入执行阶段。</p></li></ol><p><strong>创建阶段</strong></p><p><br></p><p>创建阶段要做的事情主要如下：</p><ol><li><p>创建变量对象（<em>VO：variable object</em>）</p><ul><li><p>确定函数的形参（<strong>并赋值</strong>）</p></li><li><p>函数环境会初始化创建 <em>Arguments</em>对象（<strong>并赋值</strong>）</p></li><li><p>确定普通字面量形式的函数声明（<strong>并赋值</strong>）</p></li><li><p>变量声明，函数表达式声明（<strong>未赋值</strong>）</p></li></ul></li><li><p>确定 <em>this</em> 指向（<strong><em>this</em> 由调用者确定</strong>）</p></li><li><p>确定作用域（<strong>词法环境决定，哪里声明定义，就在哪里确定</strong>）</p></li></ol><p>这里有必要说一下变量对象。</p><p><br></p><p>当处于执行上下文的建立阶段时，我们可以将整个上下文环境看作是一个对象。该对象拥有 <em>3</em> 个属性，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">executionContextObj = {\n    variableObject : {}, // 变量对象，里面包含 Arguments 对象，形式参数，函数和局部变量\n    scopeChain : {},// 作用域链，包含内部上下文所有变量对象的列表\n    this : {}// 上下文中 this 的指向对象\n}</code></pre></div><p>可以看到，这里执行上下文抽象成为了一个对象，拥有 <em>3</em> 个属性，分别是<strong>变量对象</strong>，<strong>作用域链</strong>以及 <strong><em>this</em> 指向</strong>，这里我们重点来看一下变量对象里面所拥有的东西。</p><p><br></p><p>在函数的建立阶段，首先会建立 <em>Arguments</em> 对象。然后确定形式参数，检查当前上下文中的函数声明，每找到一个函数声明，就在 <em>variableObject</em> 下面用函数名建立一个属性，属性值就指向该函数在内存中的地址的一个引用。</p><p><br></p><p>如果上述函数名已经存在于 <em>variableObject</em>（简称 <em>VO</em>） 下面，那么对应的属性值会被新的引用给覆盖。</p><p><br></p><p>最后，是确定当前上下文中的局部变量，如果遇到和函数名同名的变量，则会忽略该变量。</p><p><br></p><p><strong>执行阶段</strong></p><ol><li><p>变量对象赋值</p><ul><li><p>变量赋值</p></li><li><p>函数表达式赋值</p></li></ul></li><li><p>调用函数</p></li><li><p>顺序执行其它代码</p></li></ol><p>两个阶段要做的事情介绍完毕，接下来我们来通过代码来演示一下这两个阶段做的每一件事以及变量对象是如何变化的。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const foo = function(i){\n    var a = \"Hello\";\n    var b = function privateB(){};\n    function c(){}\n}\nfoo(10);</code></pre></div><p>首先在建立阶段的变量对象如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">fooExecutionContext = {\n    variavleObject : {\n        arguments : {0 : 10,length : 1}, // 确定 Arguments 对象\n        i : 10, // 确定形式参数\n        c : pointer to function c(), // 确定函数引用\n        a : undefined, // 局部变量 初始值为 undefined\n        b : undefined  // 局部变量 初始值为 undefined\n    },\n    scopeChain : {},\n    this : {}\n}</code></pre></div><p>由此可见，在建立阶段，除了 <em>Arguments</em>，函数的声明，以及形式参数被赋予了具体的属性值外，其它的变量属性默认的都是 <em>undefined</em>。并且普通形式声明的函数的提升是在变量的上面的。</p><p><br></p><p>一旦上述建立阶段结束，引擎就会进入代码执行阶段，这个阶段完成后，上述执行上下文对象如下，变量会被赋上具体的值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">fooExecutionContext = {\n    variavleObject : {\n        arguments : {0 : 10,length : 1},\n        i : 10,\n        c : pointer to function c(),\n        a : \"Hello\",// a 变量被赋值为 Hello\n        b : pointer to function privateB() // b 变量被赋值为 privateB() 函数\n    },\n    scopeChain : {},\n    this : {}\n}</code></pre></div><p>我们看到，只有在代码执行阶段，局部变量才会被赋予具体的值。在建立阶段局部变量的值都是 <em>undefined</em>。</p><p><br></p><p>这其实也就解释了变量提升的原理。</p><p><br></p><p>接下来我们再通过一段代码来加深对函数这两个阶段的过程的理解，代码如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">(function () {\n    console.log(typeof foo);\n    console.log(typeof bar);\n    var foo = \"Hello\";\n    var bar = function () {\n        return \"World\";\n    }\n\n    function foo() {\n        return \"good\";\n    }\n    console.log(foo, typeof foo);\n})()</code></pre></div><p>这里，我们定义了一个 <em>IIFE</em>，该函数在建立阶段的变量对象如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">fooExecutionContext = {\n    variavleObject : {\n        arguments : {length : 0},\n        foo : pointer to function foo(),\n        bar : undefined\n    },\n    scopeChain : {},\n    this : {}\n}</code></pre></div><p>首先确定 <em>Arguments</em> 对象，接下来是形式参数，由于本例中不存在形式参数，所以接下来开始确定函数的引用，找到 <em>foo</em> 函数后，创建 <em>foo</em> 标识符来指向这个 <em>foo</em> 函数，之后同名的 <em>foo</em> 变量不会再被创建，会直接被忽略。</p><p><br></p><p>然后创建 <em>bar</em> 变量，不过初始值为 <em>undefined</em>。</p><p><br></p><p>建立阶段完成之后，接下来进入代码执行阶段，开始一句一句的执行代码，结果如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">(function () {\n    console.log(typeof foo); // function\n    console.log(typeof bar); // undefined\n    var foo = \"Hello\"; // foo 被重新赋值 变成了一个字符串\n    var bar = function () {\n        return \"World\";\n    }\n\n    function foo() {\n        return \"good\";\n    }\n    console.log(foo, typeof foo); //Hello string\n})()</code></pre></div><h2>真题解答</h2><ul><li><p>谈谈你对 <em>JavaScript</em> 执行上下文栈理解</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p><strong>什么是执行上下文？</strong></p><p><br></p><p>简而言之，执行上下文是评估和执行 <em>JavaScript</em> 代码的环境的抽象概念。每当 <em>Javascript</em> 代码在运行的时候，它都是在执行上下文中运行。</p><p><br></p><p><strong>执行上下文的类型</strong></p><p><br></p><p><em>JavaScript</em> 中有三种执行上下文类型。</p><ul><li><p>**全局执行上下文：**这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事，创建一个全局的 <em>window</em> 对象（浏览器的情况下），并且设置 <em>this</em> 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</p></li><li><p>**函数执行上下文：**每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。</p></li><li><p>**<em>Eval</em> 函数执行上下文：**执行在 <em>eval</em> 函数内部的代码也会有它属于自己的执行上下文。</p></li></ul><p><strong>调用栈</strong></p><p><br></p><p>调用栈是解析器（如浏览器中的的 <em>JavaScript</em> 解析器）的一种机制，可以在脚本调用多个函数时，跟踪每个函数在完成执行时应该返回控制的点。（如什么函数正在执行，什么函数被这个函数调用，下一个调用的函数是谁）</p><ul><li><p>当脚本要调用一个函数时，解析器把该函数添加到栈中并且执行这个函数。</p></li><li><p>任何被这个函数调用的函数会进一步添加到调用栈中，并且运行到它们被上个程序调用的位置。</p></li><li><p>当函数运行结束后，解释器将它从堆栈中取出，并在主代码列表中继续执行代码。</p></li><li><p>如果栈占用的空间比分配给它的空间还大，那么则会导致“栈溢出”错误。</p></li></ul></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666077081802",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e51c72fac4881713db37c"
  },
  "interviewTitle": "谈谈你对作用域和作用域链的理解",
  "interviewContent": "<h1>作用域和作用域链</h1><h2>经典真题</h2><ul><li><p>谈谈你对作用域和作用域链的理解？</p></li></ul><h2>作用域（<em>Scope</em>）</h2><h3>什么是作用域</h3><p>作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。</p><p><br></p><p>换句话说，作用域决定了代码区块中变量和其他资源的可见性。</p><p><br></p><p>可能这两句话并不好理解，我们先来看个例子：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function outFun2() {\n    var inVariable = \"内层变量2\";\n}\noutFun2();\nconsole.log(inVariable); // Uncaught ReferenceError: inVariable is not defined</code></pre></div><p>从上面的例子可以体会到作用域的概念，变量 <em>inVariable</em> 在全局作用域没有声明，所以在全局作用域下取值会报错。</p><p><br></p><p>我们可以这样理解：<strong>作用域就是一个独立的地盘，让变量不会外泄、暴露出去</strong>。也就是说<strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong></p><p><br></p><p><strong><em>ES6</em> 之前 <em>JavaScript</em> 没有块级作用域，只有全局作用域和函数作用域</strong>。</p><p><br></p><p><em>ES6</em> 的到来，为我们提供了“块级作用域”，可通过新增命令 <em>let</em> 和 <em>const</em> 来体现。</p><h3>全局作用域和函数作用域</h3><p><strong>（1）全局作用域</strong></p><p><br></p><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：</p><ul><li><p>最外层函数和在最外层函数外面定义的变量拥有全局作用域</p></li></ul><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var outVariable = \"我是最外层变量\"; //最外层变量\nfunction outFun() { //最外层函数\n    var inVariable = \"内层变量\";\n    function innerFun() { //内层函数\n        console.log(inVariable);\n    }\n    innerFun();\n}\nconsole.log(outVariable); // 我是最外层变量\noutFun(); // 内层变量\nconsole.log(inVariable); // inVariable is not defined\ninnerFun(); // innerFun is not defined</code></pre></div><ul><li><p>所有未定义直接赋值的变量自动声明为拥有全局作用域</p></li></ul><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function outFun2() {\n    variable = \"未定义直接赋值的变量\";\n    var inVariable2 = \"内层变量2\";\n}\noutFun2();//要先执行这个函数，否则根本不知道里面是啥\nconsole.log(variable); //未定义直接赋值的变量\nconsole.log(inVariable2); //inVariable2 is not defined</code></pre></div><ul><li><p>所有 <em>window</em> 对象的属性拥有全局作用域</p></li></ul><p>一般情况下，<em>window</em> 对象的内置属性都拥有全局作用域，例如 <em>window.name、window.location、window.top</em> 等等。</p><p><br></p><p>全局作用域有个弊端：如果我们写了很多行 <em>JS</em> 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会污染全局命名空间， 容易引起命名冲突。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// 张三写的代码中\nvar data = {a: 100}\n\n// 李四写的代码中\nvar data = {x: true}</code></pre></div><p>这就是为何  <em>jQuery、Zepto</em> 等库的源码，所有的代码都会放在 <em>(function(){....})( )</em> 中。</p><p><br></p><p>因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 <em>JS</em> 脚本造成影响。这是函数作用域的一个体现。</p><p><br></p><p><strong>（2）函数作用域</strong></p><p><br></p><p>函数作用域，是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function doSomething(){\n    var stuName=\"zhangsan\";\n    function innerSay(){\n        console.log(stuName);\n    }\n    innerSay();\n}\nconsole.log(stuName); // 脚本错误\ninnerSay(); // 脚本错误</code></pre></div><p><strong>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行</strong>。</p><p><br></p><p>我们看个例子，用泡泡来比喻作用域可能好理解一点：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-01-151740.png\" alt=\"image-20211001231740498\" contenteditable=\"false\"><br></p><p><br></p><p>最后输出的结果为 <em>2、4、12</em></p><ul><li><p>泡泡 <em>1</em> 是全局作用域，有标识符 <em>foo</em>；</p></li><li><p>泡泡 <em>2</em> 是作用域 <em>foo</em>，有标识符 <em>a、bar、b</em>；</p></li><li><p>泡泡 <em>3</em> 是作用域 <em>bar</em>，仅有标识符 <em>c</em>。</p></li></ul><p>值得注意的是：<strong>块语句（大括号“｛  ｝”中间的语句），如  <em>if</em>  和 <em>switch</em> 条件语句或  <em>for</em>  和  <em>while</em>  循环语句，不像函数，它们不会创建一个新的作用域</strong>。在块语句中定义的变量将保留在它们已经存在的作用域中。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">if (true) {\n    // 'if' 条件语句块不会创建一个新的作用域\n    var name = 'Hammad'; // name 依然在全局作用域中\n}\nconsole.log(name); // logs 'Hammad'</code></pre></div><p><em>JS</em> 的初学者经常需要花点时间才能习惯变量提升，而如果不理解这种特有行为，就可能导致 <em>bug</em> 。</p><p><br></p><p>正因为如此， <em>ES6</em> 引入了块级作用域，让变量的生命周期更加可控。</p><h3>块级作用域</h3><p>块级作用域可通过新增命令 <em>let</em> 和 <em>const</em> 声明，所声明的变量在指定块的作用域外无法被访问。</p><p><br></p><p>块级作用域在如下情况被创建：</p><ol><li><p>在一个函数内部</p></li><li><p>在一个代码块（由一对花括号包裹）内部</p></li></ol><p><em>let</em> 声明的语法与 <em>var</em> 的语法一致。你基本上可以用 <em>let</em> 来代替 <em>var</em> 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：</p><ul><li><p>声明变量不会提升到代码块顶部</p></li></ul><p><em>let、const</em> 声明并不会被提升到当前代码块的顶部，因此你需要手动将 <em>let、const</em> 声明放置到顶部，以便让变量在整个代码块内部可用。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function getValue(condition) {\n    if (condition) {\n        let value = \"blue\";\n        return value;\n    } else {\n        // value 在此处不可用\n        return null;\n    }\n    // value 在此处不可用\n}</code></pre></div><ul><li><p>禁止重复声明</p></li></ul><p>如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 <em>let</em> 声明就会导致抛出错误。例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var count = 30;\nlet count = 40; // Uncaught SyntaxError: Identifier 'count' has already been declared</code></pre></div><p>在本例中， <em>count</em> 变量被声明了两次：一次使用 <em>var</em> ，另一次使用 <em>let</em>。</p><p><br></p><p>因为 <em>let</em> 不能在同一作用域内重复声明一个已有标识符，此处的 <em>let</em> 声明就会抛出错误。但如果在嵌套的作用域内使用 <em>let</em> 声明一个同名的新变量，则不会抛出错误。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var count = 30;\n// 不会抛出错误\nif (condition) {\n    let count = 40;\n    // 其他代码\n}</code></pre></div><ul><li><p>循环中的绑定块作用域的妙用</p></li></ul><p>开发者可能最希望实现 <em>for</em> 循环的块级作用域了，因为可以把声明的计数器变量限制在循环内。</p><p><br></p><p>例如，以下代码在 <em>JS</em> 经常见到：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;button&gt;测试1&lt;/button&gt;\n&lt;button&gt;测试2&lt;/button&gt;\n&lt;button&gt;测试3&lt;/button&gt;</code></pre></div><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var btns = document.getElementsByTagName('button')\nfor (var i = 0; i &lt; btns.length; i++) {\n  btns[i].onclick = function () {\n    console.log('第' + (i + 1) + '个')\n  }\n}</code></pre></div><p>我们要实现这样的一个需求: 点击某个按钮, 提示\"点击的是第 <em>n</em> 个按钮\"。</p><p><br></p><p>此处我们先不考虑事件代理，万万没想到，点击任意一个按钮，后台都是弹出“第四个”。</p><p><br></p><p>这是因为 <em>i</em> 是全局变量，执行到点击事件时，此时 <em>i</em> 的值为 <em>3</em>。</p><p><br></p><p>那该如何修改，最简单的是用 <em>let</em> 声明 <em>i</em></p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">for (let i = 0; i &lt; btns.length; i++) {\n  btns[i].onclick = function () {\n    console.log('第' + (i + 1) + '个')\n  }\n}</code></pre></div><h2>作用域链</h2><h3>什么是自由变量</h3><p>首先认识一下什么叫做<strong>自由变量</strong> 。</p><p><br></p><p>如下代码中，<em>console.log(a)</em> 要得到 <em>a</em> 变量，但是在当前的作用域中没有定义 <em>a</em>（可对比一下 <em>b</em>）。当前作用域没有定义的变量，这成为自由变量 。</p><p><br></p><p>自由变量的值如何得到 ？</p><p><br></p><p>需要向父级作用域寻找（注意：这种说法并不严谨，下文会重点解释）。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var a = 100\nfunction fn() {\n    var b = 200\n    console.log(a) // 这里的 a 在这里就是一个自由变量\n    console.log(b)\n}\nfn()</code></pre></div><h3>什么是作用域链</h3><p>如果父级也没呢？</p><p><br></p><p>再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链 。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var a = 100\nfunction f1() {\n    var b = 200\n    function f2() {\n        var c = 300\n        console.log(a) // 100 自由变量，顺作用域链向父作用域找\n        console.log(b) // 200 自由变量，顺作用域链向父作用域找\n        console.log(c) // 300 本作用域的变量\n    }\n    f2()\n}\nf1()</code></pre></div><h3>关于自由变量的取值</h3><p>关于自由变量的值，上文提到要到父作用域中取，其实有时候这种解释会产生歧义。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var x = 10\nfunction fn() {\n    console.log(x)\n}\nfunction show(f) {\n    var x = 20;\n    (function () {\n        f() // 10，而不是 20\n    })()\n}\nshow(fn)</code></pre></div><p>在 <em>fn</em> 函数中，取自由变量 <em>x</em> 的值时，要到哪个作用域中取 ？</p><p><br></p><p>要到创建 <em>fn</em> 函数的那个作用域中取，<strong>无论 <em>fn</em> 函数将在哪里调用</strong>。</p><p><br></p><p>所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切：<strong>要到创建这个函数的那个域”。作用域中取值，这里强调的是“创建”，而不是“调用”</strong>，切记切记，其实这就是所谓的\"静态作用域\"。</p><p><br></p><p>再来看一个例子：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const food = \"rice\";\nconst eat = function () {\n    console.log(`eat ${food}`);\n};\n(function () {\n    const food = \"noodle\";\n    eat(); // eat rice\n})();</code></pre></div><p>在本示例中，最终打印的结果为 <em>eat rice</em>。因为对于 <em>eat( )</em> 函数来说，创建该函数时它的父级上下文为全局上下文，所以 <em>food</em> 的值为 <em>rice</em>。</p><p><br></p><p>如果我们将代码稍作修改，改成如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const food = \"rice\";\n(function () {\n    const food = \"noodle\";\n    const eat = function () {\n        console.log(`eat ${food}`);\n    };\n    eat(); // eat noodle\n})();</code></pre></div><p>这个时候，打印出来的值就为 <em>eat noodle</em>。因为对于 <em>eat( )</em> 函数来讲，创建它的时候父级上下文为 <em>IIFE</em>，所以 <em>food</em> 的值为 <em>noodle</em>。</p><h2>作用域与执行上下文</h2><p>许多开发人员经常混淆作用域和执行上下文的概念，误认为它们是相同的概念，但事实并非如此。</p><p><br></p><p>我们知道 <em>JavaScript</em> 属于解释型语言，<em>JavaScript</em> 的执行分为：解释和执行两个阶段，这两个阶段所做的事并不一样。</p><p><br></p><p><strong>解释阶段</strong></p><ul><li><p>词法分析</p></li><li><p>语法分析</p></li><li><p>作用域规则确定</p></li></ul><p><strong>执行阶段</strong></p><ul><li><p>创建执行上下文</p></li><li><p>执行函数代码</p></li><li><p>垃圾回收</p></li></ul><p><em>JavaScript</em> 解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。</p><p><br></p><p>执行上下文最明显的就是 <em>this</em> 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。</p><p><br></p><p>作用域和执行上下文之间最大的区别是：</p><p><br></p><p><strong>执行上下文在运行时确定，随时可能改变，作用域在定义时就确定，并且不会改变</strong>。</p><h2>真题解答</h2><ul><li><p>谈谈你对作用域和作用域链的理解？</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p><strong>什么是作业域 ？</strong></p><p><br></p><p><em>ES5</em> 中只存在两种作用域：全局作用域和函数作用域。</p><p><br></p><p>在 <em>JavaScript</em> 中，我们将作用域定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套子作用域中根据标识符名称进行变量（变量名或者函数名）查找。<em>ES6</em> 新增了块级作用域。</p><p><br></p><p><strong>什么是作用域链 ？</strong></p><p><br></p><p>当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止。</p><p><br></p><p>而作用域链，就是有当前作用域与上层作用域的一系列变量对象组成，它保证了当前执行的作用域对符合访问权限的变量和函数的有序访问。</p><p><br></p><p>作用域链有一个非常重要的特性，<strong>那就是作用域中的值是在函数创建的时候，就已经被存储了，是静态的</strong>。</p><p><br></p><p>所谓静态，就是说作用域中的值一旦被确定了，永远不会变。**函数可以永远不被调用，但是作用域中的值在函数创建的时候就已经被写入了，**并且存储在函数作用域链对象里面。</p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666077127179",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e51fb2fac4881713db380"
  },
  "interviewTitle": "JS 中 this 的指向有哪些？",
  "interviewContent": "<h1><em>this</em> 指向</h1><h2>经典真题</h2><ul><li><p><em>this</em> 的指向哪几种 ？</p></li></ul><h2><em>this</em> 指向总结</h2><p><em>this</em> 关键字是一个非常重要的语法点。毫不夸张地说，不理解它的含义，大部分开发任务都无法完成。</p><p><br></p><p><em>this</em> 可以用在构造函数之中，表示实例对象。除此之外，<em>this</em> 还可以用在别的场合。<strong>但不管是什么场合，<em>this</em> 都有一个共同点：它总是返回一个对象</strong>。</p><p><br></p><p>关于 <em>this</em> 的指向，有一种广为流传的说法就是“谁调用它，<em>this</em> 就指向谁”。</p><p><br></p><p>这样的说法没有太大的问题，但是并不是太全面。总结起来，<em>this</em> 的指向规律有如下几条：</p><ul><li><p>在函数体中，非显式或隐式地简单调用函数时，在严格模式下，函数内的 <em>this</em> 会被绑定到 <em>undefined</em> 上，在非严格模式下则会被绑定到全局对象 <em>window/global</em> 上。</p></li><li><p>一般使用 <em>new</em> 方法调用构造函数时，构造函数内的 <em>this</em> 会被绑定到新创建的对象上。</p></li><li><p>一般通过 <em>call/apply/bind</em> 方法显式调用函数时，函数体内的 <em>this</em> 会被绑定到指定参数的对象上。</p></li><li><p>一般通过上下文对象调用函数时，函数体内的 <em>this</em> 会被绑定到该对象上。</p></li><li><p>在箭头函数中，<em>this</em> 的指向是由外层（函数或全局）作用域来决定的。</p></li></ul><p>当然，真实环境多种多样，下面我们就来根据实战例题逐一梳理。</p><h3>全局环境中的 <em>this</em></h3><p>例题 <em>1</em>：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function f1() {\n    console.log(this);\n}\n\nfunction f2() {\n    'use strict'\n    console.log(this);\n}\n\nf1(); // window or global\nf2(); // undefined</code></pre></div><p>这种情况相对简单、直接，函数在浏览器全局环境下被简单调用，在非严格模式下 <em>this</em> 指向 <em>window</em>，在通过 <em>use strict</em> 指明严格模式的情况下指向 <em>undefined</em>。</p><p><br></p><p>虽然上面的题目比较基础，但是需要注意上面题目的变种，例如</p><p><br></p><p>例题 <em>2</em>：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const foo = {\n    bar : 10,\n    fn : function(){\n        console.log(this); // window or global\n        console.log(this.bar); // undefined\n    }\n}\nvar fn1 = foo.fn;\nfn1();</code></pre></div><p>这里的 <em>this</em> 仍然指向 <em>window</em>。虽然 <em>fn</em> 函数在 <em>foo</em> 对象中作为该对象的一个方法，但是在赋值给 <em>fn1</em> 之后，<em>fn1</em> 仍然是在 <em>window</em> 的全局环境下执行的。因此上面的代码仍然会输出 <em>window</em> 和 <em>undefined</em>。</p><p><br></p><p>还是上面这道题目，如果改成如下的形式</p><p><br></p><p>例题 <em>3</em>：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const foo = {\n    bar : 10,\n    fn : function(){\n        console.log(this); // { bar: 10, fn: [Function: fn] }\n        console.log(this.bar); // 10\n    }\n}\nfoo.fn();</code></pre></div><p>这时，<em>this</em> 指向的是最后调用它的对象，在 <em>foo.fn( )</em> 语句中，this 指向的是 <em>foo</em> 对象。</p><h3>上下文对象调用中的 <em>this</em></h3><p>例题 <em>4</em>：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const student = {\n    name: 'zhangsan',\n    fn: function () {\n        return this;\n    }\n}\nconsole.log(student.fn() === student); // true</code></pre></div><p>在上面的代码中，<em>this</em> 指向当前的对象 <em>student</em>，所以最终会返回 <em>true</em>。</p><p><br></p><p>当存在更复杂的调用关系时，如以下代码中的嵌套关系，<em>this</em> 将指向最后调用它的对象，例如</p><p><br></p><p>例题 <em>5</em>：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const student = {\n    name: 'zhangsan',\n    son: {\n        name: 'zhangxiaosan',\n        fn: function () {\n            return this.name\n        }\n    }\n}\nconsole.log(student.son.fn()); // zhangxiaosan</code></pre></div><p>在上面的代码中，<em>this</em> 会指向最后调用它的对象，因此输出的是 <em>zhangxiaosan</em>。</p><p><br></p><p>至此，<em>this</em> 的上下文对象调用已经介绍得比较清楚了。我们再来看一道比较高阶的题目</p><p><br></p><p>例题 <em>6</em>：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const o1 = {\n    text: 'o1',\n    fn: function () {\n        return this.text;\n    }\n}\n\nconst o2 = {\n    text: 'o2',\n    fn: function () {\n        return o1.fn();\n    }\n}\n\nconst o3 = {\n    text: 'o3',\n    fn: function () {\n        var fn = o1.fn;\n        return fn();\n    }\n}\n\nconsole.log(o1.fn()); // o1\nconsole.log(o2.fn()); // o1\nconsole.log(o3.fn()); // undefined</code></pre></div><p>答案是 <em>o1、o1、undefined</em>。</p><p><br></p><p>这里主要讲一下为什么第三个是 <em>undefined</em>。这里将 <em>o1.fn</em> 赋值给了 <em>fn</em>，所以 <em>fn</em> 等价于 <em>function () { return this.text; }</em>，然后该函数在调用的时候，是直接 <em>fn( )</em> 的形式调用的，并不是以对象的形式，相当于还是全局调用，指向 <em>window</em>，所以打印出 <em>undefined</em>。</p><h3><em>this</em> 指向绑定事件的元素</h3><p><em>DOM</em> 元素绑定事件时，事件处理函数里面的 <em>this</em> 指向绑定了事件的元素。</p><p><br></p><p>这个地方一定要注意它和 <em>target</em> 的区别，<em>target</em> 是指向触发事件的元素。</p><p><br></p><p>示例如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;ul id=\"color-list\"&gt;\n  &lt;li&gt;red&lt;/li&gt;\n  &lt;li&gt;yellow&lt;/li&gt;\n  &lt;li&gt;blue&lt;/li&gt;\n  &lt;li&gt;green&lt;/li&gt;\n  &lt;li&gt;black&lt;/li&gt;\n  &lt;li&gt;white&lt;/li&gt;\n&lt;/ul&gt;</code></pre></div><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// this 是绑定事件的元素\n// target 是触发事件的元素 和 srcElememnt 等价\nlet colorList = document.getElementById(\"color-list\");\ncolorList.addEventListener(\"click\", function (event) {\n  console.log('this:', this);\n  console.log('target:', event.target);\n  console.log('srcElement:', event.srcElement);\n})</code></pre></div><p>当我点击如下位置时打印出来的信息如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-28-033304.png\" alt=\"image-20210928113303839\" contenteditable=\"false\"><br></p><p><br></p><p>有些时候我们会遇到一些困扰，比如在 <em>div</em> 节点的事件函数内部，有一个局部的 <em>callback</em> 方法，该方法被作为普通函数调用时，<em>callback</em> 内部的 <em>this</em> 是指向全局对象 <em>window</em> 的</p><p><br></p><p>例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div id=\"div1\"&gt;我是一个div&lt;/div&gt;</code></pre></div><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">window.id = 'window';\ndocument.getElementById('div1').onclick = function(){\n  console.log(this.id); // div1\n  const callback = function(){\n    console.log(this.id); // 因为是普通函数调用，所以 this 指向 window\n  }\n  callback();\n}</code></pre></div><p>此时有一种简单的解决方案，可以用一个变量保存 <em>div</em> 节点的引用，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">window.id = 'window';\ndocument.getElementById('div1').onclick = function(){\n  console.log(this.id); // div1\n  const that = this; // 保存当前 this 的指向\n  const callback = function(){\n    console.log(that.id); // div1\n  }\n  callback();\n}</code></pre></div><h3>改变 <em>this</em> 指向</h3><h4>1. <em>call、apply、bind</em> 方法修改 <em>this</em> 指向</h4><p>由于 <em>JavaScript</em>  中 <em>this</em> 的指向受函数运行环境的影响，指向经常改变，使得开发变得困难和模糊，所以在封装 <em>sdk</em> 或者写一些复杂函数的时候经常会用到 <em>this</em> 指向绑定，以避免出现不必要的问题。</p><p><br></p><p><em>call、apply、bind</em> 基本都能实现这一功能，起到确定 <em>this</em> 指向的作用</p><p><br></p><p><strong><em>Function.prototype.call( )</em></strong></p><p><br></p><p><em>call</em> 方法可以指定 <em>this</em> 的指向（即函数执行时所在的的作用域），然后再指定的作用域中，执行函数。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = {};\nvar f = function(){\n\treturn this;\n};\nconsole.log(f() === window);  // this 指向 window\nconsole.log(f.call(obj) === obj) // 改变this 指向 obj</code></pre></div><p>上面代码中，全局环境运行函数 <em>f</em> 时，<em>this</em> 指向全局环境（浏览器为 <em>window</em> 对象）；</p><p><br></p><p><em>call</em> 方法可以改变 <em>this</em> 的指向，指定 <em>this</em> 指向对象 <em>obj</em>，然后在对象 <em>obj</em> 的作用域中运行函数 <em>f</em>。</p><p><br></p><p><em>call</em> 方法的参数，应该是对象 <em>obj</em>，如果参数为空或 <em>null、undefind</em>，则默认传参全局对象。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var n = 123;\nvar obj = { n: 456 };\n\nfunction a() {\n  console.log(this.n);\n}\n\na.call() // 123\na.call(null) // 123\na.call(undefined) // 123\na.call(window) // 123\na.call(obj) // 456</code></pre></div><p>上面代码中，<em>a</em> 函数中的 <em>this</em> 关键字，如果指向全局对象，返回结果为 <em>123</em>。</p><p><br></p><p>如果使用 <em>call</em> 方法将 <em>this</em> 关键字指向 <em>obj</em> 对象，返回结果为 <em>456</em>。可以看到，如果 <em>call</em> 方法没有参数，或者参数为 <em>null</em> 或 <em>undefined</em>，则等同于指向全局对象。</p><p><br></p><p>如果 <em>call</em> 传参不是以上类型，则转化成对应的包装对象，然后传入方法。</p><p><br></p><p>例如，<em>5</em> 转成 <em>Number</em> 实例，绑定 <em>f</em> 内部 <em>this</em></p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var f = function () {\n  return this;\n};\n\nf.call(5); // Number {[[PrimitiveValue]]: 5}</code></pre></div><p><em>call</em> 可以接受多个参数，第一个参数是 <em>this</em> 指向的对象，之后的是函数回调所需的参数。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function add(a, b) {\n  return a + b;\n}\n\nadd.call(this, 1, 2) // 3</code></pre></div><p><em>call</em> 方法的一个应用是调用对象的原生方法。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = {};\nobj.hasOwnProperty('toString') // false\n\n// 覆盖掉继承的 hasOwnProperty 方法\nobj.hasOwnProperty = function () {\n  return true;\n};\nobj.hasOwnProperty('toString') // true\n\nObject.prototype.hasOwnProperty.call(obj, 'toString') // false</code></pre></div><p>上面代码中 <em>hasOwnProperty</em> 是 <em>obj</em> 继承来的方法，用来判断对象是否包含自身特点（非继承）属性，但是 <em>hasOwnProperty</em> 并不是保留字，如果被对象覆盖，会造成结果错误。</p><p><br></p><p><em>call</em> 方法可以解决这个问题，它将 <em>hasOwnProperty</em> 方法的原始定义放到 <em>obj</em> 对象上执行，这样无论 <em>obj</em> 上有没有同名方法，都不会影响结果。</p><p><br></p><p><strong><em>Function.prototype.apply( )</em></strong></p><p><br></p><p><em>apply</em> 和 <em>call</em> 作用类似，也是改变 <em>this</em> 指向，然后调用该函数，唯一区别是 <em>apply</em> 接收数组作为函数执行时的参数。语法如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">func.apply(thisValue, [arg1, arg2, ...])</code></pre></div><p><em>apply</em> 方法的第一个参数也是 <em>this</em> 所要指向的那个对象，如果设为 <em>null</em> 或 <em>undefined</em>，则等同于指定全局对象。</p><p><br></p><p>第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。</p><p><br></p><p>原函数的参数，在 <em>call</em> 方法中必须一个个添加，但是在 <em>apply</em> 方法中，必须以数组形式添加。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function f(x, y){\n  console.log(x + y);\n}\n\nf.call(null, 1, 1) // 2\nf.apply(null, [1, 1]) // 2</code></pre></div><p>利用这一特性，可以实现很多小功能。比如，输出数组的最大值：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var a = [24,30,2,33,1]\nMath.max.apply(null,a)  //33</code></pre></div><p>还可以将数组中的空值，转化成 <em>undefined</em>。</p><p><br></p><p>通过 <em>apply</em> 方法，利用 <em>Array</em> 构造函数将数组的空元素变成 <em>undefined</em>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var a = ['a',,'b'];\nArray.apply(null,a) //['a',undefind,'b']</code></pre></div><p>空元素与 <em>undefined</em> 的差别在于，数组的 <em>forEach</em> 方法会跳过空元素，但是不会跳过 <em>undefined</em>。因此，遍历内部元素的时候，会得到不同的结果。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var a = ['a', , 'b'];\n\nfunction print(i) {\n  console.log(i);\n}\n\na.forEach(print)\n// a\n// b\n\nArray.apply(null, a).forEach(print)\n// a\n// undefined\n// b</code></pre></div><p>配合数组对象的 <em>slice</em> 方法，可以将一个类似数组的对象（比如 <em>arguments</em> 对象）转为真正的数组。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">Array.prototype.slice.apply({0: 1, length: 1}) // [1]\nArray.prototype.slice.apply({0: 1}) // []\nArray.prototype.slice.apply({0: 1, length: 2}) // [1, undefined]\nArray.prototype.slice.apply({length: 1}) // [undefined]</code></pre></div><p>上面代码的 <em>apply</em> 方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。</p><p><br></p><p>从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有 <em>length</em> 属性，以及相对应的数字键。</p><p><br></p><p><strong><em>Function.prototype.bind( )</em></strong></p><p><br></p><p><em>bind</em> 用于将函数体内的 <em>this</em> 绑定到某个对象，然后返回一个新函数</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var d = new Date();\nd.getTime() // 1481869925657\n\nvar print = d.getTime;\nprint() // Uncaught TypeError: this is not a Date object.</code></pre></div><p>报错是因为 <em>d.getTime</em> 赋值给 <em>print</em> 后，<em>getTime</em> 内部的 <em>this</em> 指向方式变化，已经不再指向 <em>date</em> 对象实例了。</p><p><br></p><p>解决方法：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var print = d.getTime.bind(d);\nprint() // 1481869925657</code></pre></div><p><em>bind</em> 接收的参数就是所要绑定的对象</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var counter = {\n  count: 0,\n  inc: function () {\n    this.count++;\n  }\n};\n\nvar func = counter.inc.bind(counter);\nfunc();\ncounter.count // 1</code></pre></div><p>绑定到其他对象</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var counter = {\n  count: 0,\n  inc: function () {\n    this.count++;\n  }\n};\n\nvar obj = {\n  count: 100\n};\nvar func = counter.inc.bind(obj);\nfunc();\nobj.count // 101</code></pre></div><p><em>bind</em> 还可以接收更多的参数，将这些参数绑定到原函数的参数</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var add = function (x, y) {\n  return x * this.m + y * this.n;\n}\n\nvar obj = {\n  m: 2,\n  n: 2\n};\n\nvar newAdd = add.bind(obj, 5);\nnewAdd(5) // 20</code></pre></div><p>上面代码中，<em>bind</em> 方法除了绑定 <em>this</em> 对象，还将 <em>add</em> 函数的第一个参数 <em>x</em> 绑定成 <em>5</em>，然后返回一个新函数 <em>newAdd</em>，这个函数只要再接受一个参数 <em>y</em> 就能运行了。</p><p><br></p><p>如果 <em>bind</em> 方法的第一个参数是 <em>null</em> 或 <em>undefined</em>，等于将 <em>this</em> 绑定到全局对象，函数运行时 <em>this</em> 指向顶层对象（浏览器为 <em>window</em>）。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function add(x, y) {\n  return x + y;\n}\n\nvar plus5 = add.bind(null, 5);\nplus5(10) // 15</code></pre></div><p>上面代码中，函数 <em>add</em> 内部并没有 <em>this</em>，使用 <em>bind</em> 方法的主要目的是绑定参数 <em>x</em>，以后每次运行新函数 <em>plus5</em>，就只需要提供另一个参数 <em>y</em> 就够了。</p><p><br></p><p>而且因为 <em>add</em> 内部没有 <em>this</em>，所以 <em>bind</em> 的第一个参数是 <em>null</em>，不过这里如果是其他对象，也没有影响。</p><p><br></p><p><em>bind</em> 方法有一些使用注意点。</p><p><br></p><p>（1）每一次返回一个新函数</p><p><br></p><p><em>bind</em> 方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>element.addEventListener('click', o.m.bind(o));</code></pre></div><p>上面代码中，<em>click</em> 事件绑定 <em>bind</em> 方法生成的一个匿名函数。这样会导致无法取消绑定，所以，下面的代码是无效的。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">element.removeEventListener('click', o.m.bind(o));</code></pre></div><p>正确的方法是写成下面这样：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var listener = o.m.bind(o);\nelement.addEventListener('click', listener);\n//  ...\nelement.removeEventListener('click', listener);</code></pre></div><p>（2）结合回调函数使用</p><p><br></p><p>回调函数是 <em>JavaScript</em> 最常用的模式之一，但是一个常见的错误是，将包含 <em>this</em> 的方法直接当作回调函数。解决方法就是使用 <em>bind</em> 方法，将 <em>counter.inc</em> 绑定 <em>counter</em>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var counter = {\n  count: 0,\n  inc: function () {\n    'use strict';\n    this.count++;\n  }\n};\n\nfunction callIt(callback) {\n  callback();\n}\n\ncallIt(counter.inc.bind(counter));\ncounter.count // 1</code></pre></div><p>上面代码中，<em>callIt</em> 方法会调用回调函数。这时如果直接把 <em>counter.inc</em> 传入，调用时 <em>counter.inc</em> 内部的 <em>this</em> 就会指向全局对象。使用 <em>bind</em> 方法将 <em>counter.inc</em> 绑定 <em>counter</em> 以后，就不会有这个问题，<em>this</em> 总是指向 <em>counter</em>。</p><p><br></p><p>还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的 <em>this</em> 指向，很可能也会出错。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = {\n  name: '张三',\n  times: [1, 2, 3],\n  print: function () {\n    this.times.forEach(function (n) {\n      console.log(this.name);\n    });\n  }\n};\n\nobj.print()\n// 没有任何输出</code></pre></div><p>上面代码中，<em>obj.print</em> 内部 <em>this.times</em> 的 <em>this</em> 是指向 <em>obj</em> 的，这个没有问题。</p><p><br></p><p>但是，<em>forEach</em> 方法的回调函数内部的 <em>this.name</em> 却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">obj.print = function () {\n  this.times.forEach(function (n) {\n    console.log(this === window);\n  });\n};\n\nobj.print()\n// true\n// true\n// true</code></pre></div><p>解决这个问题，也是通过 <em>bind</em> 方法绑定 <em>this</em>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">obj.print = function () {\n  this.times.forEach(function (n) {\n    console.log(this.name);\n  }.bind(this));\n};\n\nobj.print()\n// 张三\n// 张三\n// 张三</code></pre></div><p>（3）结合 <em>call</em> 方法使用</p><p><br></p><p>利用 <em>bind</em> 方法，可以改写一些 <em>JavaScript</em> 原生方法的使用形式，以数组的 <em>slice</em> 方法为例。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">[1, 2, 3].slice(0, 1) // [1]\n// 等同于\nArray.prototype.slice.call([1, 2, 3], 0, 1) // [1]</code></pre></div><p>上面的代码中，数组的 <em>slice</em> 方法从 <em>[1, 2, 3]</em> 里面，按照指定位置和长度切分出另一个数组。这样做的本质是在 <em>[1, 2, 3]</em> 上面调用 <em>Array.prototype.slice</em> 方法，因此可以用 <em>call</em> 方法表达这个过程，得到同样的结果。</p><p><br></p><p><em>call</em> 方法实质上是调用 <em>Function.prototype.call</em> 方法，因此上面的表达式可以用 <em>bind</em> 方法改写。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var slice = Function.prototype.call.bind(Array.prototype.slice);\nslice([1, 2, 3], 0, 1) // [1]</code></pre></div><p>上面代码的含义就是，将 <em>Array.prototype.slice</em> 变成 <em>Function.prototype.call</em> 方法所在的对象，调用时就变成了 <em>Array.prototype.slice.call</em>。类似的写法还可以用于其他数组方法。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var push = Function.prototype.call.bind(Array.prototype.push);\nvar pop = Function.prototype.call.bind(Array.prototype.pop);\n\nvar a = [1 ,2 ,3];\npush(a, 4)\na // [1, 2, 3, 4]\n\npop(a)\na // [1, 2, 3]</code></pre></div><p>如果再进一步，将 <em>Function.prototype.call</em> 方法绑定到 <em>Function.prototype.bind</em> 对象，就意味着 <em>bind</em> 的调用形式也可以被改写。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function f() {\n  console.log(this.v);\n}\n\nvar o = { v: 123 };\nvar bind = Function.prototype.call.bind(Function.prototype.bind);\nbind(f, o)() // 123</code></pre></div><p>上面代码的含义就是，将 <em>Function.prototype.bind</em> 方法绑定在 <em>Function.prototype.call</em> 上面，所以 <em>bind</em> 方法就可以直接使用，不需要在函数实例上使用。</p><h4>2. 箭头函数的 <em>this</em> 指向</h4><p>当我们的 <em>this</em> 是以函数的形式调用时，<em>this</em> 指向的是全局对象。</p><p><br></p><p>不过对于箭头函数来讲，却比较特殊。箭头函数的 <em>this</em> 指向始终为外层的作用域。</p><p><br></p><p>先来看一个普通函数作为对象的一个方法被调用时，<em>this</em> 的指向，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const obj = {\n    x : 10,\n    test : function(){\n        console.log(this); // 指向 obj 对象\n        console.log(this.x); // 10\n    }\n}\nobj.test();\n// { x: 10, test: [Function: test] }\n// 10</code></pre></div><p>可以看到，普通函数作为对象的一个方法被调用时，<em>this</em> 指向当前对象。</p><p><br></p><p>在上面的例子中，就是 <em>obj</em> 这个对象，<em>this.x</em> 的值为 <em>10</em>。</p><p><br></p><p>接下来是箭头函数以对象的方式被调用的时候的 <em>this</em> 的指向，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var x = 20;\nconst obj = {\n    x: 10,\n    test: () =&gt; {\n        console.log(this); // {}\n        console.log(this.x); // undefined\n    }\n}\nobj.test();\n// {}\n// undefined</code></pre></div><p>这里的结果和上面不一样，<em>this</em> 打印出来为 { }，而 <em>this.x</em> 的值为 <em>undefined</em>。</p><p><br></p><p>为什么呢？</p><p><br></p><p>实际上刚才我们有讲过，箭头函数的 <em>this</em> 指向与普通函数不一样，它的 <em>this</em> 指向始终是指向的外层作用域。所以这里的 <em>this</em> 实际上是指向的全局对象。</p><p><br></p><p>如果证明呢？</p><p><br></p><p>方法很简单，将这段代码放入浏览器运行，在浏览器中用 <em>var</em> 所声明的变量会成为全局对象 <em>window</em> 的一个属性，如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-28-052059.png\" alt=\"image-20210928132058878\" contenteditable=\"false\"><br></p><p><br></p><p>接下来我们再来看一个例子，来证明箭头函数的 <em>this</em> 指向始终是指向的外层作用域。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var name = \"JavaScript\";\nconst obj = {\n    name: \"PHP\",\n    test: function () {\n        const i = function () {\n            console.log(this.name);\n            // i 是以函数的形式被调用的，所以 this 指向全局\n            // 在浏览器环境中打印出 JavaScript，node 里面为 undeifned\n        }\n        i();\n    }\n}\nobj.test(); // JavaScript</code></pre></div><p>接下来我们将 i 函数修改为箭头函数，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var name = \"JavaScript\";\nconst obj = {\n    name : \"PHP\",\n    test : function(){\n        const i = ()=&gt;{\n            console.log(this.name);\n            // 由于 i 为一个箭头函数，所以 this 是指向外层的\n            // 所以 this.name 将会打印出 PHP\n        }\n        i();\n    }\n}\nobj.test();// PHP</code></pre></div><p>最后需要说一点的就是，箭头函数不能作为构造函数，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const Test = (name, age) =&gt; {\n    this.name = name;\n    this.age = age;\n};\nconst test = new Test(\"xiejie\", 18);\n// TypeError: Test is not a constructor</code></pre></div><h2>真题解答</h2><ul><li><p><em>this</em> 的指向哪几种 ？</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>总结起来，<em>this</em> 的指向规律有如下几条：</p><ul><li><p>在函数体中，非显式或隐式地简单调用函数时，在严格模式下，函数内的 <em>this</em> 会被绑定到 <em>undefined</em> 上，在非严格模式下则会被绑定到全局对象 <em>window/global</em> 上。</p></li><li><p>一般使用 <em>new</em> 方法调用构造函数时，构造函数内的 <em>this</em> 会被绑定到新创建的对象上。</p></li><li><p>一般通过 <em>call/apply/bind</em> 方法显式调用函数时，函数体内的 <em>this</em> 会被绑定到指定参数的对象上。</p></li><li><p>一般通过上下文对象调用函数时，函数体内的 <em>this</em> 会被绑定到该对象上。</p></li><li><p>在箭头函数中，<em>this</em> 的指向是由外层（函数或全局）作用域来决定的。</p></li></ul></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666077179833",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e52302fac4881713db384"
  },
  "interviewTitle": "是否了解 JS 中的垃圾回收站机制",
  "interviewContent": "<h1>垃圾回收与内存泄漏</h1><h2>经典真题</h2><ul><li><p>请介绍一下 <em>JavaScript</em> 中的垃圾回收站机制</p></li></ul><h2>什么是内存泄露</h2><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（<em>runtime</em>）就必须供给内存。</p><p><br></p><p>对于持续运行的服务进程（<em>daemon</em>），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p><p><br></p><p>也就是说，不再用到的内存，如果没有及时释放，就叫做内存泄漏（<em>memory leak</em>）。</p><h2><em>JavaScript</em> 中的垃圾回收</h2><p>浏览器的 <em>Javascript</em> 具有自动垃圾回收机制（<em>GC</em>：<em>Garbage Collecation</em>），也就是说，执行环境会负责管理代码执行过程中使用的内存。其原理是：<strong>垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存</strong>。</p><p><br></p><p>但是这个过程不是实时的，因为其开销比较大并且 <em>GC</em> 时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p><p><br></p><p>不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。</p><p><br></p><p>下面是一段示例代码：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function fn1() {\n    var obj = {name: 'zhangsan', age: 10};\n}\nfunction fn2() {\n    var obj = {name:'zhangsan', age: 10};\n    return obj;\n}\n\nvar a = fn1();\nvar b = fn2();</code></pre></div><p>在上面的代码中，我们首先声明了两个函数，分别叫做 <em>fn1</em> 和 <em>fn2</em>。</p><p><br></p><p>当 <em>fn1</em> 被调用时，进入 <em>fn1</em> 的环境，会开辟一块内存存放对象 <em>{name: 'zhangsan', age: 10}</em>。而当调用结束后，出了 <em>fn1</em> 的环境，那么该块内存会被  <em>JavaScript</em> 引擎中的垃圾回收器自动释放；</p><p><br></p><p>在 <em>fn2</em> 被调用的过程中，返回的对象被全局变量 <em>b</em> 所指向，所以该块内存并不会被释放。</p><p><br></p><p>这里问题就出现了：到底哪个变量是没有用的？</p><p><br></p><p>所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。</p><p><br></p><p>用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：<strong>标记清除</strong>和<strong>引用计数</strong>。</p><p><br></p><p>引用计数不太常用，标记清除较为常用。</p><h2>标记清除</h2><p><em>JavaScript</em> 中最常用的垃圾回收方式就是标记清除。</p><p><br></p><p>当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。</p><p><br></p><p>从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。</p><p><br></p><p>而当变量离开环境时，则将其标记为“离开环境”。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function test(){\n  var a = 10 ; // 被标记 ，进入环境 \n  var b = 20 ; // 被标记 ，进入环境\n}\ntest(); // 执行完毕 之后 a、b 又被标离开环境，被回收。</code></pre></div><p>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。</p><p><br></p><p>然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。</p><p><br></p><p>最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p><p><br></p><p>到目前为止，<em>IE9+、Firefox、Opera、Chrome、Safari</em> 的 <em>JS</em> 实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p><h2>引用计数</h2><p>引用计数的含义是跟踪记录每个值被引用的次数。</p><p><br></p><p>当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 <em>1</em>。如果同一个值又被赋给另一个变量，则该值的引用次数加 <em>1</em>。</p><p><br></p><p>相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 <em>1</em>。当这个值的引用次数变成 <em>0</em> 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。</p><p><br></p><p>这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 <em>0</em> 的值所占用的内存。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function test() {\n    var a = {};\t// a 指向对象的引用次数为 1\n    var b = a;\t// a 指向对象的引用次数加 1，为 2\n    var c = a;\t// a 指向对象的引用次数再加 1，为 3\n    var b = {};\t// a 指向对象的引用次数减 1，为 2\n}</code></pre></div><p><em>Netscape Navigator3</em> 是最早使用引用计数策略的浏览器，但很快它就遇到一个严重的问题：<strong>循环引用</strong>。</p><p><br></p><p>循环引用指的是对象 <em>A</em> 中包含一个指向对象B的指针，而对象 <em>B</em> 中也包含一个指向对象 <em>A</em> 的引用。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function fn() {\n    var a = {};\n    var b = {};\n    a.pro = b;\n    b.pro = a;\n}\nfn();</code></pre></div><p>以上代码 <em>a</em> 和 <em>b</em> 的引用次数都是 <em>2</em>，<em>fn</em> 执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为 <em>a</em> 和 <em>b</em> 的引用次数不为 <em>0</em>，所以不会被垃圾回收器回收内存，如果 <em>fn</em> 函数被大量调用，就会造成内存泄露。在 <em>IE7</em> 与 <em>IE8</em> 上，内存直线上升。</p><h2>真题解答</h2><ul><li><p>请介绍一下 <em>JavaScript</em> 中的垃圾回收站机制</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p><em>JavaScript</em> 具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。</p><p><br></p><p><em>JavaScript</em> 常见的垃圾回收方式：<strong>标记清除</strong>、<strong>引用计数</strong>方式。</p><p><br></p><p>1、标记清除方式：</p><ul><li><p>工作原理：当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</p></li><li><p>工作流程：</p></li><li><p>垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记；</p></li><li><p>去掉环境中的变量以及被环境中的变量引用的变量的标记；</p></li><li><p>被加上标记的会被视为准备删除的变量；</p></li><li><p>垃圾回收器完成内存清理工作，销毁那些带标记的值并回收他们所占用的内存空间。</p></li></ul><p>2、引用计数方式：</p><ul><li><p>工作原理：跟踪记录每个值被引用的次数。</p></li><li><p>工作流程：</p></li><li><p>声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是 <em>1</em>；</p></li><li><p>同一个值又被赋值给另一个变量，这个引用类型值的引用次数加 <em>1</em>；</p></li><li><p>当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减 <em>1</em>；</p></li><li><p>当引用次数变成 <em>0</em> 时，说明没办法访问这个值了；</p></li><li><p>当垃圾收集器下一次运行时，它就会释放引用次数是 <em>0</em> 的值所占的内存。</p></li></ul></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666077232238",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e52672fac4881713db388"
  },
  "interviewTitle": "JS 中的闭包是指什么？",
  "interviewContent": "<h1>闭包</h1><h2>经典真题</h2><ul><li><p>闭包是什么？闭包的应用场景有哪些？怎么销毁闭包？</p></li></ul><h2>什么是闭包</h2><p>闭包，是 <em>JavaScript</em> 中一个非常重要的知识点，也是我们前端面试中较高几率被问到的知识点之一。</p><p><br></p><p>打开《<em>JavaScript</em> 高级程序设计》和《 <em>JavaScript</em> 权威指南》，会发现里面针对闭包的解释各执一词，在网络上搜索关于闭包的内容，也发现众说纷纭，这就导致了这个知识点本身显得有点神秘，甚至还有一点玄幻。</p><p><br></p><p>那么这个知识点真的有那么深奥么？</p><p><br></p><p>非也！其实要理解 <em>JavaScript</em> 中的闭包，非常容易，但是在此之前你需要先知道以下两个知识点：</p><ul><li><p><em>JavaScript</em> 中的作用域和作用域链</p></li><li><p><em>JavaScript</em> 中的垃圾回收</p></li></ul><p>这里我们来简单回顾一下这两个知识点：</p><p><br></p><p><strong>1. <em>JavaScript</em> 中的作用域和作用域链</strong></p><ul><li><p>作用域就是一个独立的地盘，让变量不会外泄、暴露出去，不同作用域下同名变量不会有冲突。</p></li><li><p>作用域在定义时就确定，并且不会改变。</p></li><li><p>如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</p></li></ul><p><strong>2. <em>JavaScript</em> 中的垃圾回收</strong></p><ul><li><p><em>Javascript</em> 执行环境会负责管理代码执行过程中使用的内存，其中就涉及到一个垃圾回收机制</p></li><li><p>垃圾收集器会定期（周期性）找出那些不再继续使用的变量，只要该变量不再使用了，就会被垃圾收集器回收，然后释放其内存。如果该变量还在使用，那么就不会被回收。</p></li></ul><p><em>OK</em>，有了这 <em>2</em> 个知识点的铺垫后，接下来我们再来看什么是闭包。</p><blockquote><p>闭包不是一个具体的技术，而是一种现象，是指在定义函数时，周围环境中的信息可以在函数中使用。换句话说，执行函数时，只要在函数中使用了外部的数据，就创建了闭包。</p><p><br></p><p>而作用域链，正是实现闭包的手段。</p></blockquote><p>什么？只要在函数中使用了外部的数据，就创建了闭包？</p><p><br></p><p>真的是这样么？下面我们可以证明一下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-27-065017.png\" alt=\"image-20211227145016552\" contenteditable=\"false\"><br></p><p><br></p><p>在上面的代码中，我们在函数 <em>a</em> 中定义了一个变量 <em>i</em>，然后打印这个 <em>i</em> 变量。对于 <em>a</em> 这个函数来讲，自己的函数作用域中存在 <em>i</em> 这个变量，所以我们在调试时可以看到 <em>Local</em> 中存在变量 <em>i</em>。</p><p><br></p><p>下面我们将上面的代码稍作修改，如下图：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-27-065522.png\" alt=\"image-20211227145521272\" contenteditable=\"false\"><br></p><p><br></p><p>在上面的代码中，我们将声明 <em>i</em> 这个变量的动作放到了 <em>a</em> 函数外面，也就是说 <em>a</em> 函数在自己的作用域已经找不到这个 <em>i</em> 变量了，它会怎么办？</p><p><br></p><p>学习了作用域链的你肯定知道，它会顺着作用域链一层一层往外找。然而上面在介绍闭包时说过，如果出现了这种情况，也就是函数使用了外部的数据的情况，就会创建闭包。</p><p><br></p><p>仔细观察调试区域，我们会发现此时的 <em>i</em> 就放在 <em>Closure</em> 里面的，从而证实了我们前面的说法。</p><p><br></p><p>所以你看，闭包其实也没有那么难理解，当你觉得一个词对你来说特别难的时候，你还可以使用拆词法，这也是我比较推荐的屡试不爽的一种方法。</p><p><br></p><p>“闭”可以理解为“封闭，闭环”，“包”可以理解为“一个类似于包裹的空间”，因此闭包实际上可以看作是一个封闭的空间，那么这个空间用来干啥呢？实际上就是用来存储变量的。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-27-083947.png\" alt=\"image-20211227163947135\" contenteditable=\"false\"><br></p><p><br></p><p>那么是一个函数下所有的变量声明都会被放入到闭包这个封闭的空间里面么？</p><p><br></p><p>倒也不是，放不放入到闭包中，要看其他地方有没有对这个变量进行引用，例如：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-27-084334.png\" alt=\"image-20211227164333723\" contenteditable=\"false\"><br></p><p><br></p><p>在上面的代码中，函数 c 中一个变量都没有创建，却要打印 <em>i、j、k</em> 和 <em>x</em>，这些变量分别存在于 <em>a、b</em> 函数以及全局作用域中，因此创建了 <em>3</em> 个闭包，全局闭包里面存储了 <em>i</em> 的值，闭包 <em>a</em> 中存储了变量 <em>j</em> 和 <em>k</em> 的值，闭包 <em>b</em> 中存储了变量 <em>x</em> 的值。</p><p><br></p><p>但是你仔细观察，你就会发现函数 <em>b</em> 中的 <em>y</em> 变量并没有被放在闭包中，所以要不要放入闭包取决于该变量有没有被引用。</p><p><br></p><p>当然，此时的你可能会有这样的一个新问题，那么多闭包，那岂不是占用内存空间么？</p><p><br></p><p>实际上，如果是自动形成的闭包，是会被销毁掉的。例如：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-27-094043.png\" alt=\"image-20211227174043786\" contenteditable=\"false\"><br></p><p><br></p><p>在上面的代码中，我们在第 <em>16</em> 行尝试打印输出变量 <em>k</em>，显然这个时候是会报错的，在第 <em>16</em> 行打一个断点调试就可以清楚的看到，此时已经没有任何闭包存在，垃圾回收器会自动回收没有引用的变量，不会有任何内存占用的情况。</p><p><br></p><p>当然，这里我指的是自动产生闭包的情况，关于闭包，有时我们需要根据需求手动的来制造一个闭包。</p><p><br></p><p>来看下面的例子：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function eat(){\n    var food = \"鸡翅\";\n    console.log(food);\n}\neat(); // 鸡翅\nconsole.log(food); // 报错</code></pre></div><p>在上面的例子中，我们声明了一个名为 <em>eat</em> 的函数，并对它进行调用。</p><p><br></p><p><em>JavaScript</em> 引擎会创建一个 <em>eat</em> 函数的执行上下文，其中声明 <em>food</em> 变量并赋值。</p><p><br></p><p>当该方法执行完后，上下文被销毁，<em>food</em> 变量也会跟着消失。这是因为 <em>food</em> 变量属于 <em>eat</em> 函数的局部变量，它作用于 <em>eat</em> 函数中，会随着 <em>eat</em> 的执行上下文创建而创建，销毁而销毁。所以当我们再次打印 <em>food</em> 变量时，就会报错，告诉我们该变量不存在。</p><p><br></p><p>但是我们将此代码稍作修改：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function eat(){\n    var food = '鸡翅';\n    return function(){\n        console.log(food);\n    }\n}\nvar look = eat();\nlook(); // 鸡翅\nlook(); // 鸡翅</code></pre></div><p>在这个例子中，<em>eat</em> 函数返回一个函数，并在这个内部函数中访问 <em>food</em> 这个局部变量。调用 <em>eat</em> 函数并将结果赋给 <em>look</em> 变量，这个 <em>look</em> 指向了 <em>eat</em> 函数中的内部函数，然后调用它，最终输出 <em>food</em> 的值。</p><p><br></p><p>为什么能访问到 <em>food</em>，原因很简单，上面我们说过，垃圾回收器只会回收没有被引用到的变量，但是一旦一个变量还被引用着的，垃圾回收器就不会回收此变量。在上面的示例中，照理说 <em>eat</em> 调用完毕 <em>food</em> 就应该被销毁掉，但是我们向外部返回了 <em>eat</em> 内部的匿名函数，而这个匿名函数有引用了 <em>food</em>，所以垃圾回收器是不会对其进行回收的，这也是为什么在外面调用这个匿名函数时，仍然能够打印出 <em>food</em> 变量的值。</p><p><br></p><p>至此，闭包的一个优点或者特点也就体现出来了，那就是：</p><ul><li><p>通过闭包可以让外部环境访问到函数内部的局部变量。</p></li><li><p>通过闭包可以让局部变量持续保存下来，不随着它的上下文环境一起销毁。</p></li></ul><p>通过此特性，我们可以解决一个全局变量污染的问题。早期在 <em>JavaScript</em> 还无法进行模块化的时候，在多人协作时，如果定义过多的全局变量 有可能造成全局变量命名冲突，使用闭包来解决功能对变量的调用将变量写到一个独立的空间里面，从而能够一定程度上解决全局变量污染的问题。</p><p><br></p><p>例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var name = \"GlobalName\";\n// 全局变量\nvar init = (function () {\n    var name = \"initName\";\n    function callName() {\n        console.log(name);\n        // 打印 name\n    }\n    return function () {\n        callName();\n        // 形成接口\n    }\n}());\ninit(); // initName\nvar initSuper = (function () {\n    var name = \"initSuperName\";\n    function callName() {\n        console.log(name);\n        // 打印 name\n    }\n    return function () {\n        callName();\n        // 形成接口\n    }\n}());\ninitSuper(); // initSuperName</code></pre></div><p>好了，在此小节的最后，我们来对闭包做一个小小的总结：</p><ul><li><p>闭包是一个封闭的空间，里面存储了在其他地方会引用到的该作用域的值，在 <em>JavaScript</em> 中是通过作用域链来实现的闭包。</p></li><li><p>只要在函数中使用了外部的数据，就创建了闭包，这种情况下所创建的闭包，我们在编码时是不需要去关心的。</p></li><li><p>我们还可以通过一些手段手动创建闭包，从而让外部环境访问到函数内部的局部变量，让局部变量持续保存下来，不随着它的上下文环境一起销毁。</p></li></ul><h2>闭包经典问题</h2><p>聊完了闭包，接下来我们来看一个闭包的经典问题。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">for (var i = 1; i &lt;= 3; i++) {\n    setTimeout(function () {\n        console.log(i);\n    }, 1000);\n}</code></pre></div><p>在上面的代码中，我们预期的结果是过 <em>1</em> 秒后分别输出 <em>i</em> 变量的值为 <em>1，2，3</em>。但是，执行的结果是：<em>4，4，4</em>。</p><p><br></p><p>实际上，问题就出在闭包身上。你看，循环中的 <em>setTimeout</em> 访问了它的外部变量 <em>i</em>，形成闭包。</p><p><br></p><p>而 <em>i</em> 变量只有 <em>1</em> 个，所以循环 <em>3</em> 次的 <em>setTimeout</em> 中都访问的是同一个变量。循环到第 <em>4</em> 次，<em>i</em> 变量增加到 <em>4</em>，不满足循环条件，循环结束，代码执行完后上下文结束。但是，那 <em>3</em> 个 <em>setTimeout</em> 等 <em>1</em> 秒钟后才执行，由于闭包的原因，所以它们仍然能访问到变量 <em>i</em>，不过此时 <em>i</em> 变量值已经是 <em>4</em> 了。</p><p><br></p><p>要解决这个问题，我们可以让 <em>setTimeout</em> 中的匿名函数不再访问外部变量，而是访问自己内部的变量，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">for (var i = 1; i &lt;= 3; i++) {\n    (function (index) {\n        setTimeout(function () {\n            console.log(index);\n        }, 1000);\n    })(i)\n}</code></pre></div><p>这样 <em>setTimeout</em> 中就可以不用访问 <em>for</em> 循环声明的变量 <em>i</em> 了。而是采用调用函数传参的方式把变量 <em>i</em> 的值传给了 <em>setTimeout</em>，这样它们就不再创建闭包，因为在我自己的作用域里面能够找到 <em>i</em> 这个变量。</p><p><br></p><p>当然，解决这个问题还有个更简单的方法，就是使用 <em>ES6</em> 中的 <em>let</em> 关键字。</p><p><br></p><p>它声明的变量有块作用域，如果将它放在循环中，那么每次循环都会有一个新的变量 <em>i</em>，这样即使有闭包也没问题，因为每个闭包保存的都是不同的 <em>i</em> 变量，那么刚才的问题也就迎刃而解。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">for (let i = 1; i &lt;= 3; i++) {\n    setTimeout(function () {\n        console.log(i);\n    }, 1000);\n}</code></pre></div><h2>真题解答</h2><ul><li><p>闭包是什么？闭包的应用场景有哪些？怎么销毁闭包？</p></li></ul><blockquote><p>闭包是一个封闭的空间，里面存储了在其他地方会引用到的该作用域的值，在 <em>JavaScript</em> 中是通过作用域链来实现的闭包。</p><p><br></p><p>只要在函数中使用了外部的数据，就创建了闭包，这种情况下所创建的闭包，我们在编码时是不需要去关心的。</p><p><br></p><p>我们还可以通过一些手段手动创建闭包，从而让外部环境访问到函数内部的局部变量，让局部变量持续保存下来，不随着它的上下文环境一起销毁。</p><p><br></p><p>使用闭包可以解决一个全局变量污染的问题。</p><p><br></p><p>如果是自动产生的闭包，我们无需操心闭包的销毁，而如果是手动创建的闭包，可以把被引用的变量设置为 <em>null</em>，即手动清除变量，这样下次 <em>JavaScript</em> 垃圾回收器在进行垃圾回收时，发现此变量已经没有任何引用了，就会把设为 <em>null</em> 的量给回收了。</p></blockquote><div contenteditable=\"false\"><hr></div><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666077287842",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e529a2fac4881713db38c"
  },
  "interviewTitle": "如何注册 DOM 事件和移除事件",
  "interviewContent": "<h1><em>DOM</em> 事件的注册和移除</h1><h2>经典真题</h2><ul><li><p>总结一下 <em>DOM</em> 中如何注册事件和移除事件</p></li></ul><h2><em>DOM</em> 注册事件</h2><p>使用 <em>JavaScript</em> 为 <em>DOM</em> 元素注册事件的方式有多种。但是并不是一开始就设计了多种方式，而是随着技术的发展，发展前一种方式有所缺陷，所以设计了新的 <em>DOM</em> 元素注册事件的方式。</p><p><br></p><p>这里我们就一起来总结一下 <em>DOM</em> 中注册事件的方式有哪些。</p><h3><em>HTML</em> 元素中注册事件</h3><p><em>HTML</em> 元素中注册的事件，又被称之为行内事件监听器。这是在浏览器中处理事件最原始的方法。</p><p><br></p><p>具体的示例如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;button onclick=\"test('张三')\"&gt;点击我&lt;/button&gt;</code></pre></div><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function test(name) {\n  console.log(`我知道你已经点击了，${name}`);\n}</code></pre></div><p>在上面的代码中，我们为 <em>button</em> 元素添加了 <em>onclick</em> 属性，然后绑定了一个名为 <em>test</em> 的事件处理器。</p><p><br></p><p>在 <em>JavaScript</em> 中只需要书写对应的 <em>test</em> 事件处理函数即可。</p><p><br></p><p>但是有一点需要注意，就是这种方法已经过时了，原因如下：</p><ul><li><p><em>JavaScript</em> 代码与 <em>HTML</em> 标记混杂在一起，破坏了结构和行为分离的理念。</p></li><li><p>每个元素只能为每种事件类型绑定一个事件处理器。</p></li><li><p>事件处理器的代码隐藏于标记中，很难找到事件是在哪里声明的。</p></li></ul><p>但是如果是做简单的事件测试，那么这种写法还是非常方便快捷的。</p><h3><em>DOM0</em> 级方式注册事件</h3><p>这种方式是首先取到要为其绑定事件的元素节点对象，然后给这些节点对象的事件处理属性赋值一个函数。</p><p><br></p><p>这样就可以达到 <em>JavaScript</em> 代码和 <em>HTML</em> 代码相分离的目的。</p><p><br></p><p>具体的示例如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;button id=\"test\"&gt;点击我&lt;/button&gt;</code></pre></div><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var test = document.getElementById(\"test\");\ntest.onclick = function(){\n  console.log(\"this is a test\");\n}</code></pre></div><p>这种方式虽然相比 <em>HTML</em> 元素中注册事件有所改进，但是它也有一个缺点，那就是它依然存在每个元素只能绑定一个函数的局限性。</p><p><br></p><p>下面我们尝试使用这种方式为同一个元素节点绑定 <em>2</em> 个事件，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var test = document.getElementById(\"test\");\ntest.onclick = function(){\n  console.log(\"this is a test\");\n}\ntest.onclick = function(){\n  console.log(\"this is a test,too\");\n}</code></pre></div><p>当我们为该 <em>DOM</em> 元素绑定 <em>2</em> 个相同类型的事件时，后面的事件处理函数就会把前面的事件处理函数给覆盖掉。</p><h3><em>DOM2</em> 级方式注册事件</h3><p><em>DOM2</em> 级再次对事件的绑定方式进行了改进。</p><p><br></p><p><em>DOM2</em> 级通过 <em>addEventListener</em> 方法来为一个 <em>DOM</em> 元素添加多个事件处理函数。</p><p><br></p><p>该方法接收 <em>3</em> 个参数：事件名、事件处理函数、布尔值。</p><p><br></p><p>如果这个布尔值为 <em>true</em>，则在捕获阶段处理事件，如果为 <em>false</em>，则在冒泡阶段处理事件。若最后的布尔值不填写，则和 <em>false</em> 效果一样，也就是说默认为 <em>false</em>，在冒泡阶段进行事件的处理。</p><p><br></p><p>接下来我们来看下面的示例：这里我们为 <em>button</em> 元素绑定了 <em>2</em> 个事件处理程序，并且 <em>2</em> 个事件处理程序都是通过点击来触发。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var test = document.getElementById(\"test\");\ntest.addEventListener(\"click\", function () {\n  console.log(\"this is a test\");\n}, false);\ntest.addEventListener(\"click\", function () {\n  console.log(\"this is a test,too\");\n}, false);</code></pre></div><p>在上面的代码中，我们通过 <em>addEventListener</em> 为按钮绑定了 <em>2</em> 个点击的事件处理程序，<em>2</em> 个事件处理程序都会执行。</p><p><br></p><p>另外需要注意的是，在 <em>IE</em> 中和 <em>addEventListener</em> 方法与之对应的是 <em>attachEvent</em> 方法。</p><h2><em>DOM</em> 移除事件</h2><p>通过 <em>DOM0</em> 级来添加的事件，删除的方法很简单，只需要将 <em>DOM</em> 元素的事件处理属性赋值为 <em>null</em> 即可。</p><p><br></p><p>例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var test = document.getElementById(\"test\");\ntest.onclick = function(){\n  console.log(\"this is a test\");\n  test.onclick = null;\n}</code></pre></div><p>在上面的代码中，我们通过 <em>DOM0</em> 级的方式为 <em>button</em> 按钮绑定了点击事件，但是在事件处理函数中又移除了该事件。所以该事件只会生效一次。</p><p><br></p><p>如果是通过 <em>DOM2</em> 级来添加的事件，我们可以使用 <em>removeEventLister</em> 方法来进行事件的删除。</p><p><br></p><p>需要注意的是，如果要通过该方法移除<strong>某一类事件类型的一个事件</strong>的话，在通过 <em>addEventListener</em> 来绑定事件时的写法就要稍作改变。</p><p><br></p><p>先单独将绑定函数写好，然后 <em>addEventListener</em> 进行绑定时第 <em>2</em> 个参数传入要绑定的函数名即可。</p><p><br></p><p>示例如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var test = document.getElementById(\"test\");\n//DOM 2级添加事件\nfunction fn1() {\n  console.log(\"this is a test\");\n  test.removeEventListener(\"click\", fn1); // 只删除第一个点击事件\n}\nfunction fn2() {\n  console.log(\"this is a test,too\");\n}\ntest.addEventListener(\"click\", fn1, false);\ntest.addEventListener(\"click\", fn2, false);</code></pre></div><p>在上面的代码中，我们为 <em>button</em> 元素绑定了两个 <em>click</em> 事件，之后在第一个事件处理函数中，对 <em>fn1</em> 事件处理函数进行了移除。所以第一次点击时，<em>fn1</em> 和 <em>fn2</em> 都会起作用，之后因为 <em>fn1</em> 被移除，所以只会 <em>fn2</em> 有作用。</p><h2>真题解答</h2><ul><li><p>总结一下 <em>DOM</em> 中如何注册事件和移除事件</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>注册事件的方式常见的有 <em>3</em> 种方式：</p><ul><li><p><em>HTML</em> 元素中注册的事件：这种方式又被称之为行内事件监听器。这是在浏览器中处理事件最原始的方法。</p></li><li><p><em>DOM0</em> 级方式注册事件：这种方式是首先取到要为其绑定事件的元素节点对象，然后给这些节点对象的事件处理属性赋值一个函数。</p></li><li><p><em>DOM2</em> 级方式注册事件：<em>DOM2</em> 级通过 <em>addEventListener</em> 方法来为一个 <em>DOM</em> 元素添加多个事件处理函数。</p><p><br></p><p>该方法接收 <em>3</em> 个参数：事件名、事件处理函数、布尔值。</p><p><br></p><p>如果这个布尔值为 <em>true</em>，则在捕获阶段处理事件，如果为 <em>false</em>，则在冒泡阶段处理事件。若最后的布尔值不填写，则和 <em>false</em> 效果一样，也就是说默认为 <em>false</em>，在冒泡阶段进行事件的处理。</p></li></ul><p>关于移除注册的事件，如果是 <em>DOM0</em> 级方式注册的事件，直接将值设置为 <em>null</em> 即可。如果是 <em>DOM2</em> 级注册的事件，可以使用 <em>removeEventListener</em> 方法来移除事件。</p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666077338867",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e52c62fac4881713db390"
  },
  "interviewTitle": "谈一谈事件委托以及冒泡原理",
  "interviewContent": "<h1><em>DOM</em> 事件的传播机制</h1><h2>经典真题</h2><ul><li><p>谈一谈事件委托以及冒泡原理</p></li></ul><h2>事件与事件流</h2><p>事件最早是在 <em>IE3</em> 和 <em>NetscapeNavigator2</em> 中出现的，当时是作为分担服务器运算负担的一种手段。</p><p><br></p><p>要实现和网页的互动，就需要通过 <em>JavaScript</em> 里面的事件来实现。</p><p><br></p><p>每次用户与一个网页进行交互，例如点击链接，按下一个按键或者移动鼠标时，就会触发一个事件。我们的程序可以检测这些事件，然后对此作出响应。从而形成一种交互。</p><p><br></p><p>这样可以使我们的页面变得更加的有意思，而不仅仅像以前一样只能进行浏览。</p><p><br></p><p>在早期拨号上网的年代，如果所有的功能都放在服务器端进行处理的话，效率是非常低的。</p><p><br></p><p>所以 <em>JavaScript</em> 最初被设计出来就是用来解决这些问题的。通过允许一些功能在客户端处理，以节省到服务器的往返时间。</p><p><br></p><p><em>JavaScript</em> 中采用一个叫做事件监听器的东西来监听事件是否发生。这个事件监听器类似于一个通知，当事件发生时，事件监听器会让我们知道，然后程序就可以做出相应的响应。</p><p><br></p><p>通过这种方式，就可以避免让程序不断地去检查事件是否发生，让程序在等待事件发生的同时，可以继续做其他的任务。</p><h3>事件流</h3><p>当浏览器发展到第 <em>4</em> 代时（<em>IE4</em> 及 <em>Netscape4</em>），浏览器开发团队遇到了一个很有意思的问题：页面的哪一部分会拥有某个特定的事件？</p><p><br></p><p>想象在一张纸上的一组同心圆。如果把手指放在圆心上，那么手指指向的不是一个圆，而是纸上的所有圆。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-02-094941.png\" alt=\"image-20211002174941387\" contenteditable=\"false\"><br></p><p><br></p><p>好在两家公司的浏览器开发团队在看待浏览器事件方面还是一致的。</p><p><br></p><p>如果单击了某个按钮，他们都认为单击事件不仅仅发生在按钮上，甚至也单击了整个页面。</p><p><br></p><p>但有意思的是，<em>IE</em> 和 <em>Netscape</em> 开发团队居然提出了差不多是完全相反的事件流的概念。</p><p><br></p><p><em>IE</em> 的事件流是事件冒泡流，而 <em>Netscape</em> 的事件流是事件捕获流。</p><h3>事件冒泡流</h3><p><em>IE</em> 的事件流叫做事件冒泡（<em>event bubbling</em>），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。</p><p><br></p><p>以下列 <em>HTML</em> 结构为例，来说明事件冒泡。如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;title&gt;Document&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div&gt;&lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;</code></pre></div><p>如果单击了页面中的 <em>div</em> 元素，那么这个 <em>click</em> 事件沿 <em>DOM</em> 树向上传播，在每一级节点上都会发生，按照如下顺序进行传播：</p><ol><li><p><em>div</em></p></li><li><p><em>body</em></p></li><li><p><em>html</em></p></li><li><p><em>document</em></p></li></ol><p>所有现代浏览器都支持事件冒泡，但在具体实现在还是有一些差别。</p><p><br></p><p><em>IE9、Firefox、Chrome、Safari</em> 将事件一直冒泡到 <em>window</em> 对象。</p><p><br></p><p>我们可以通过下面的代码，来查看文档具体的冒泡顺序，示例如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div id=\"box\" style=\"height:100px;width:300px;background-color:pink;\"&gt;&lt;/div&gt;\n&lt;button id=\"reset\"&gt;还原&lt;/button&gt;</code></pre></div><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// IE8 以下浏览器返回 div body html document\n// 其他浏览器返回 div body html document window\nreset.onclick = function () {\n  history.go();\n}\nbox.onclick = function () {\n  box.innerHTML += 'div\\n';\n}\ndocument.body.onclick = function () {\n  box.innerHTML += 'body\\n';\n}\ndocument.documentElement.onclick = function () {\n  box.innerHTML += 'html\\n';\n}\ndocument.onclick = function () {\n  box.innerHTML += 'document\\n';\n}\nwindow.onclick = function () {\n  box.innerHTML += 'window\\n';\n}</code></pre></div><p>在上面的示例中，我们为 <em>div</em> 以及它的祖先元素绑定了点击事件，由于事件冒泡的存在，当我们点击 <em>div</em> 时，所有祖先元素的点击事件也会被触发。</p><p><br></p><p>如下图所示：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-02-092307.png\" alt=\"image-20211002172307085\" contenteditable=\"false\"><br></p><h3>事件捕获流</h3><p><em>Netscape Communicator</em> 团队提出的另一种事件流叫做事件捕获（<em>event captruing</em>）。</p><p><br></p><p>事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。</p><p><br></p><p>事件捕获的思想是在事件到达预定目标之前就捕获它。</p><p><br></p><p>以同样的 <em>HTML</em> 结构为例来说明事件捕获，如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;title&gt;Document&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div&gt;&lt;/div&gt;    \n    &lt;/body&gt;\n&lt;/html&gt;</code></pre></div><p>在事件捕获过程中，<em>document</em> 对象首先接收到 <em>click</em> 事件，然后事件沿 <em>DOM</em> 树依次向下，一直传播到事件的实际目标，即 <em>div</em> 元素：</p><ol><li><p><em>document</em></p></li><li><p><em>html</em></p></li><li><p><em>body</em></p></li><li><p><em>div</em></p></li></ol><p><em>IE9、Firefox、Chrome、Safari</em> 等现代浏览器都支持事件捕获，但是也是从 <em>window</em> 对象开始捕获。</p><p><br></p><p>下面我们来演示一个事件捕获流的示例：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div id=\"box\" style=\"height:100px;width:300px;background-color:pink;\"&gt;&lt;/div&gt;\n&lt;button id=\"reset\"&gt;还原&lt;/button&gt;</code></pre></div><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// IE8 以下浏览器不支持\n// 其他浏览器返回 window document html body div\nreset.onclick = function () {\n  history.go();\n}\nbox.addEventListener('click', function () {\n  box.innerHTML += 'div\\n'\n}, true)\ndocument.body.addEventListener('click', function () {\n  box.innerHTML += 'body\\n';\n}, true);\ndocument.documentElement.addEventListener('click', function () {\n  box.innerHTML += 'html\\n';\n}, true);\ndocument.addEventListener('click', function () {\n  box.innerHTML += 'document\\n';\n}, true);\nwindow.addEventListener('click', function () {\n  box.innerHTML += 'window\\n';\n}, true);</code></pre></div><p>在上面的示例中，我们为 <em>div</em> 以及它所有的祖先元素绑定了点击事件，使用的 <em>addEventListener</em> 的方式来绑定的事件，并将第 <em>2</em> 个参数设置为了 <em>true</em> 表示使用事件捕获的方式来触发事件。</p><p><br></p><p>效果如下图所示：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-02-093549.png\" alt=\"image-20211002173549252\" contenteditable=\"false\"><br></p><h3>标准 <em>DOM</em> 事件流</h3><p><em>DOM</em> 标准采用的是<strong>捕获 + 冒泡</strong>的方式。</p><p><br></p><p>两种事件流都会触发 <em>DOM</em> 的所有对象，从 <em>document</em> 对象开始，也在 <em>document</em> 对象结束。</p><p><br></p><p>换句话说，起点和终点都是 <em>document</em> 对象（很多浏览器可以一直捕获 + 冒泡到 <em>window</em> 对象）</p><p><br></p><p><em>DOM</em> 事件流示意图：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-02-094149.png\" alt=\"image-20211002174148423\" contenteditable=\"false\"><br></p><p><br></p><p><em>DOM</em> 标准规定事件流包括三个阶段：<strong>事件捕获阶段</strong>、<strong>处于目标阶段</strong>和<strong>事件冒泡阶段</strong>。</p><ul><li><p>**事件捕获阶段：**实际目标 <em>div</em> 在捕获阶段不会触发事件。捕获阶段从 <em>window</em> 开始，然后到 <em>document、html</em>，最后到 <em>body</em> 意味着捕获阶段结束。</p></li><li><p>**处于目标阶段：**事件在 <em>div</em> 上发生并处理，但是本次事件处理会被看成是冒泡阶段的一部分。</p></li><li><p>**冒泡阶段：**事件又传播回文档。</p></li></ul><h2>事件委托</h2><p>上面介绍了事件冒泡流，事件冒泡一个最大的好处就是可以实现事件委托。</p><p><br></p><p>事件委托，又被称之为事件代理。在 <em>JavaScript</em> 中，添加到页面上的事件处理程序数量将直接关系到页面整体的运行性能。导致这一问题的原因是多方面的。</p><p><br></p><p>首先，每个函数都是对象，都会占用内存。内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的 <em>DOM</em> 访问次数，会延迟整个页面的交互就绪时间。</p><p><br></p><p>对事件处理程序过多问题的解决方案就是事件委托。</p><p><br></p><p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p><p><br></p><p>例如，<em>click</em> 事件会一直冒泡到 <em>document</em> 层次。也就是说，我们可以为整个页面指定一个 <em>onclick</em> 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。</p><p><br></p><p>举一个具体的例子，例如现在我的列表项有如下内容：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;ul id=\"color-list\"&gt;\n  &lt;li&gt;red&lt;/li&gt;\n  &lt;li&gt;yellow&lt;/li&gt;\n  &lt;li&gt;blue&lt;/li&gt;\n  &lt;li&gt;green&lt;/li&gt;\n  &lt;li&gt;black&lt;/li&gt;\n  &lt;li&gt;white&lt;/li&gt;\n&lt;/ul&gt;</code></pre></div><p>如果我们想把事件监听器绑定到所有的 <em>li</em> 元素上面，这样它们被单击的时候就弹出一些文字，为此我们需要给每一个元素来绑定一个事件监听器。</p><p><br></p><p>虽然上面的例子中好像问题也不大，但是想象一下如果这个列表有 <em>100</em> 个元素，那我们就需要添加 <em>100</em> 个事件监听器，这个工作量还是很恐怖的。</p><p><br></p><p>这个时候我们就可以利用事件代理来帮助我们解决这个问题。</p><p><br></p><p>将事件监听器绑定到父元素 <em>ul</em> 上，这样即可对所有的 <em>li</em> 元素添加事件，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var colorList = document.getElementById(\"color-list\");\ncolorList.addEventListener(\"click\",function(){\n  alert(\"Hello\");\n})</code></pre></div><p>现在我们单击列表中的任何一个 <em>li</em> 都会弹出东西，就好像这些 <em>li</em> 元素就是 <em>click</em> 事件的目标一样。</p><p><br></p><p>并且如果我们之后再为这个 <em>ul</em> 添加新的 <em>li</em> 元素的话，新的 <em>li</em> 元素也会自动添加上相同的事件。</p><p><br></p><p>但是，这个时候也存在一个问题，虽然我们使用事件代理避免了为每一个 <em>li</em> 元素添加相同的事件，但是如果用户没有点击 <em>li</em>，而是点击的 <em>ul</em>，同样也会触发事件。</p><p><br></p><p>这也很正常，因为我们事件就是绑定在 <em>ul</em> 上面的。</p><p><br></p><p>此时我们可以对点击的节点进行一个小小的判断，从而保证用户只在点击 <em>li</em> 的时候才触发事件，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var colorList = document.getElementById(\"color-list\");\ncolorList.addEventListener(\"click\", function (event) {\n  if (event.target.nodeName === 'LI') {\n    alert('点击 li');\n  }\n})</code></pre></div><h2>真题解答</h2><ul><li><p>谈一谈事件委托以及冒泡原理</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>事件委托，又被称之为事件代理。在 <em>JavaScript</em> 中，添加到页面上的事件处理程序数量将直接关系到页面整体的运行性能。导致这一问题的原因是多方面的。</p><p><br></p><p>首先，每个函数都是对象，都会占用内存。内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的 <em>DOM</em> 访问次数，会延迟整个页面的交互就绪时间。</p><p><br></p><p>对事件处理程序过多问题的解决方案就是事件委托。</p><p><br></p><p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，<em>click</em> 事件会一直冒泡到 <em>document</em> 层次。也就是说，我们可以为整个页面指定一个 <em>onclick</em> 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。</p><p><br></p><p>事件冒泡（<em>event bubbling</em>），是指事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。</p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666077382338",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e530c2fac4881713db394"
  },
  "interviewTitle": "如何阻止默认事件？",
  "interviewContent": "<h1>阻止事件默认行为</h1><h2>经典真题</h2><ul><li><p>如何阻止默认事件？</p></li></ul><h2>什么是默认行为</h2><p>所谓默认行为，一般是指 <em>HTML</em> 元素所自带的行为。例如点击一个 <em>a</em> 元素表示的是跳转：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;a href=\"https://www.baidu.com\"&gt;百度一下&lt;/a&gt;</code></pre></div><p>在上面的代码中，设置了 <em>a</em> 元素的 <em>href</em> 属性指向百度，当用户点击该 <em>a</em> 元素时，就会跳转至百度。</p><p><br></p><p>在例如：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;form action=\"\"&gt;&lt;/form&gt;</code></pre></div><p>上面的代码中我们书写了一个 <em>form</em> 元素，该元素有一个 <em>action</em> 属性，指的是表单内容要提交的地址。而当用户点击表单元素中嵌套的提交按钮时，就会进行一个默认的提交操作。</p><p><br></p><p>这些，就是 <em>HTML</em> 元素中的默认行为。</p><p><br></p><p>但是有些时候，我们是不需要这些默认行为的，例如，用户在填写了一个表单后，提交信息时我们采用 <em>ajax</em> 来异步发送到服务器，此时就不需要表单 <em>form</em> 元素默认的提交跳转这个行为了。</p><p><br></p><p>所以此时，我们就需要阻止默认行为。</p><h2>阻止默认行为的方式汇总</h2><p>下面我们来对阻止默认行为的方式进行一个总结。</p><p><br></p><p><strong>（1）<em>cancelable</em> 属性</strong></p><p><br></p><p>首先要介绍的是 <em>cancelable</em> 属性，该属性返回一个布尔值，表示事件是否可以取消。</p><p><br></p><p>该属性为只读属性。返回 <em>true</em> 时，表示可以取消。否则，表示不可取消。</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;a id=\"test\" href=\"https://www.baidu.com\"&gt;百度&lt;/a&gt;</code></pre></div><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var test = document.getElementById(\"test\");\ntest.onclick = function (event) {\n  test.innerHTML = event.cancelable; // true\n}</code></pre></div><p>在上面的代码中，我们为 <em>a</em> 元素绑定了一个点击事件，点击之后通过 <em>event</em> 对象的 <em>cancelable</em> 属性来查看该元素的默认行为是否能阻止。</p><p><br></p><p>最终返回的是 <em>true</em>，说明是能够阻止的。</p><p><br></p><p><strong>（2）<em>preventDefault</em> 方法</strong></p><p><br></p><p><em>preventDefault</em> 方法是 <em>DOM</em> 中最常见，也是最标准的取消浏览器默认行为的方式，无返回值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var test = document.getElementById(\"test\");\ntest.onclick = function(event){\n  event.preventDefault();\n}</code></pre></div><p>在上面的代码中，我们仍然是通过 <em>event</em> 对象来调用的 <em>preventDefault</em> 方法，从而阻止了 <em>a</em> 元素的默认跳转行为。</p><p><br></p><p><strong>（3）<em>returnValue</em> 属性</strong></p><p><br></p><p>这种方式使用的人比较少，知道这种方式的人也比较少。</p><p><br></p><p>首先 <em>returnValue</em> 是一个 <em>event</em> 对象上面的属性。该属性可读可写，默认值是 <em>true</em>，将其设置为 <em>false</em> 就可以取消事件的默认行为，与 <em>preventDefault</em> 方法的作用相同。</p><p><br></p><p>该属性最早是在 <em>IE</em> 的事件对象中，实现了这种取消默认行为的方式，但是现在大多数浏览器都实现了该方式。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var test = document.getElementById(\"test\");\ntest.onclick = function(event){\n  event.returnValue = false;\n}</code></pre></div><p><strong>（4）<em>return false</em></strong></p><p><br></p><p><em>return false</em> 是一条语句，该语句写在事件处理函数中也可以阻止默认行为。</p><p><br></p><p>但是需要注意的是，如果该条语句写在 <em>jQuery</em> 代码中，能够同时阻止默认行为和阻止冒泡，但是在原生 <em>JavaScript</em> 中只能阻止默认行为。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var test = document.getElementById(\"test\");\ntest.onclick = function(){\n  return false;\n}</code></pre></div><p><strong>（5）<em>defaultPrevented</em> 方法</strong></p><p><br></p><p><em>defaultPrevented</em> 属性也是 <em>event</em> 对象上面的一个属性。该属性表示默认行为是否被阻止，返回 <em>true</em> 表示被阻止，返回 <em>false</em> 表示未被阻止。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var test = document.getElementById(\"test\");\ntest.onclick = function (event) {\n  // 采用两种不同的方式来阻止浏览器默认行为，这是为了照顾其兼容性\n  if (event.preventDefault) {\n    event.preventDefault();\n  } else {\n    event.returnValue = false;\n  }\n  // 将是否阻止默认行为的结果赋值给 &lt;a&gt; 标签的文本内容\n  test.innerHTML = event.defaultPrevented;\n}</code></pre></div><p>在上面的代码中，我们点击 <em>a</em> 元素时，使用 <em>preventDefault</em> 方法阻止了浏览器默认行为。</p><p><br></p><p>之后访问 <em>event.defaultPrevented</em> 属性会得到 <em>true</em>，说明默认行为已经被阻止。</p><h2>真题解答</h2><ul><li><p>如何阻止默认事件？</p></li></ul><blockquote><p>参考答案：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// 方法一：全支持\nevent.preventDefault();\n// 方法二：该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。\nevent.returnValue = false;\n// 方法三：不建议滥用，jQuery 中可以同时阻止冒泡和默认事件\nreturn false;</code></pre></div></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666077452551",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e53492fac4881713db398"
  },
  "interviewTitle": "什么是递归？你是否使用过递归？",
  "interviewContent": "<h1>递归</h1><h2>经典真题</h2><ul><li><p>使用递归完成 <em>1</em> 到 <em>100</em> 的累加</p></li></ul><h2>递归</h2><p><em>A recursive method is a method that calls itself.</em></p><p><br></p><p>递归调用是一种特殊的调用形式，指的是方法自己调用自己的形式。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-19-063739.png\" alt=\"image-20211019143738665\" contenteditable=\"false\"><br></p><p><br></p><p>下面是一个递归的示例：</p><div data-language=\"java\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"java\">function neverEnd() {\n    console.log(\"This is the method that never ends!\");\n    neverEnd();\n}</code></pre></div><p><em>method</em> 会先输出 <em>This is the method that never ends!</em> 然后再调用自己，导致无限递归（<em>infinite recursion</em>）。当然这一般是我们需要避免的状况。</p><p><br></p><p>在进行递归操作的时候，我们需要满足以下几个条件：</p><ul><li><p>递归调用必须有结束条件</p></li><li><p>每次调用的时候都需要根据需求改变传递的参数内容</p></li></ul><p>下面是递归的一个示例，求某个数的阶乘。</p><div data-language=\"java\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"java\">function factorial(x) {\n    if (x === 1) {\n        return 1;\n    } else {\n        return x * factorial(x - 1);\n    }\n}\nconsole.log(factorial(5)); // 120</code></pre></div><p>整个递归的计算过程如下：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>===&gt; factorial(5)\n===&gt; 5 * factorial(4)\n===&gt; 5 * (4 * factorial(3))\n===&gt; 5 * (4 * (3 * factorial(2)))\n===&gt; 5 * (4 * (3 * (2 * factorial(1))))\n===&gt; 5 * (4 * (3 * (2 * 1)))\n===&gt; 5 * (4 * (3 * 2))\n===&gt; 5 * (4 * 6)\n===&gt; 5 * 24\n===&gt; 120</code></pre></div><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-19-063535.png\" alt=\"image-20211019143535293\" contenteditable=\"false\"><br></p><p><br></p><p>使用递归时需要注意如下事项：</p><ul><li><p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以用循环的方式来实现。</p></li><li><p>使用递归时需要注意防止栈溢出。在计算机中，函数调用是通过栈（<em>stack</em>）这种数据结构实现的，每当一个函数调用，栈就会加一层，每当函数返回，栈就会减一层。由于栈的大小不是无限的，所以递归调用的次数过多，会导致栈溢出。</p></li></ul><p>下面再来看几个递归的示例：</p><p><br></p><p>示例 <em>1</em>：使用递归来计算从 <em>x</em> 加到 <em>y</em> 的结果</p><div data-language=\"go\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"go\">function calc(i, j) {\n    if (i == j) {\n        return i;\n    }\n    return calc(i, j - 1) + j;\n}\nconsole.log(calc(1, 100)); // 5050</code></pre></div><p>示例 <em>2</em>：使用递归来计算斐波那契数列</p><div data-language=\"go\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"go\">function calc(i) {\n    if (i == 1) {\n        return 1;\n    } else if (i == 2) {\n        return 2;\n    } else {\n        return calc(i - 1) + calc(i - 2);\n    }\n}\nconsole.log(calc(7)); // 21</code></pre></div><h2>真题解答</h2><ul><li><p>使用递归完成 <em>1</em> 到 <em>100</em> 的累加</p></li></ul><blockquote><p>参考答案：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function calc(i, j) {\n if (i == j) {\n     return i;\n }\n return calc(i, j - 1) + j;\n}\nconsole.log(calc(1, 100)); // 5050</code></pre></div></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666077513144",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e536b2fac4881713db39c"
  },
  "interviewTitle": "JS 中对象的属性描述符有哪些？分别有什么作用？",
  "interviewContent": "<h1>属性描述符</h1><h2>经典真题</h2><ul><li><p><em>JavaScript</em> 中对象的属性描述符有哪些？分别有什么作用？</p></li></ul><h2>属性描述符详解</h2><p>在 <em>JavaScript</em> 中，对象的属性可以分为两种：</p><ul><li><p>数据属性：它的本质就是一个数据</p></li><li><p>存取器属性：它的本质是一个函数，但是可以将它当作普通属性来使用，当给该属性赋值时，会运行相应的 <em>setter</em> 函数，当获取该属性的值时，会运行相应的 <em>getter</em> 函数。除了存取器，还有一些其他的关键字，用以表示当前属性是否可写、是否有默认值、是否可枚举等，这些关键字就是属性描述符。</p></li></ul><p>属性描述符是 <em>ECMAScript</em> 5 新增的语法，它其实就是一个内部对象，用来描述对象的属性的特性。</p><h3>属性描述符的结构</h3><p>在定义对象、定义属性时，我们曾经介绍过属性描述符，属性描述符实际上就是一个对象。</p><p><br></p><p>属性描述符一共有 <em>6</em> 个，可以选择使用。</p><ul><li><p><em>value</em>：设置属性值，默认值为 <em>undefined</em>。</p></li><li><p><em>writable</em>：设置属性值是否可写，默认值为 <em>true</em>。</p></li><li><p><em>enumerable</em>：设置属性是否可枚举，即是否允许使用 <em>for/in</em> 语句或 <em>Object.keys( )</em> 函数遍历访问，默认为 <em>true</em>。</p></li><li><p><em>configurable</em>：设置是否可设置属性特性，默认为 <em>true</em>。如果为 <em>false</em>，将无法删除该属性，不能够修改属性值，也不能修改属性的属性描述符。</p></li><li><p><em>get</em>：取值函数，默认为 <em>undefined</em>。</p></li><li><p><em>set</em>：存值函数，默认为 <em>undefined</em>。</p></li></ul><p>注意这几个属性不是都可以一起设置，具体如下图：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-21-031647.png\" alt=\"image-20211021111647398\" contenteditable=\"false\"><br></p><p><br></p><p><strong>示例 1</strong></p><p><br></p><p>下面示例演示了使用 <em>value</em> 读写属性值的基本用法。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = {};  //定义空对象\nObject.defineProperty(obj, 'x', {value : 100});  //添加属性x，值为100\nconsole.log(Object.getOwnPropertyDescriptor(obj, 'x').value);  //返回100</code></pre></div><p><strong>示例 2</strong></p><p><br></p><p>下面示例演示了使用 <em>writable</em> 属性禁止修改属性 <em>x</em>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = {};\nObject.defineProperty(obj, 'x', {\n    value : 1,  //设置属性默认值为1\n    writable : false  //禁止修改属性值\n});\nobj.x = 2;  //修改属性x的值\nconsole.log(obj.x);  // 1 说明修改失败</code></pre></div><p>在正常模式下，如果 <em>writable</em> 为 <em>false</em>，重写属性值不会报错，但是操作失败，而在严格模式下则会抛出异常。</p><p><br></p><p><strong>示例 3</strong></p><p><br></p><p><em>configurable</em> 可以禁止修改属性描述符，当其值为 <em>false</em> 时，<em>value、writable、enumerable</em> 和 <em>configurable</em> 禁止修改，同时禁止删除属性。</p><p><br></p><p>在下面示例中，当设置属性 <em>x</em> 禁止修改配置后，下面操作都是不允许的，其中 <em>obj.x=5;</em> 若操作失败，则后面 <em>4</em> 个操作方法都将抛出异常。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = Object.defineProperty({}, 'x', {\n    configurable : false  // 禁止配置\n});\nobj.x = 5;  //试图修改其值\nconsole.log(obj.x);  //修改失败，返回undefined\nObject.defineProperty(obj, 'x', {value : 2});  //抛出异常\nObject.defineProperty(obj, 'x', {writable: true});  //抛出异常\nObject.defineProperty(obj, 'x', {enumerable: true});  //抛出异常\nObject.defineProperty(obj, 'x', {configurable: true});  //抛出异常</code></pre></div><p>当 <em>configurable</em> 为 <em>false</em> 时，如果把 <em>writable=true</em> 改为 <em>false</em> 是允许的。只要 <em>writable</em> 或 <em>configurable</em> 有一个为 <em>true</em>，则 <em>value</em> 也允许修改。</p><h3><em>get</em> 和 <em>set</em> 函数</h3><p>除了使用点语法或中括号语法访问属性的 <em>value</em> 外，还可以使用访问器，包括 <em>set</em> 和 <em>get</em> 两个函数。</p><p><br></p><p>其中，<em>set( )</em> 函数可以设置 <em>value</em> 属性值，而 <em>get( )</em> 函数可以读取 <em>value</em> 属性值。</p><p><br></p><p>借助访问器，可以为属性的 <em>value</em> 设计高级功能，如禁用部分特性、设计访问条件、利用内部变量或属性进行数据处理等。</p><p><br></p><p><strong>示例 1</strong></p><p><br></p><p>下面示例设计对象 <em>obj</em> 的 <em>x</em> 属性值必须为数字。为属性 <em>x</em> 定义了 <em>get</em> 和 <em>set</em> 特性，<em>obj.x</em> 取值时，就会调用 <em>get</em>；赋值时，就会调用 <em>set</em>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = Object.create(Object.prototype, {\n    _x : {  //数据属性\n        value : 1,  //初始值\n        writable : true\n    },\n    x : {  //访问器属性\n        get : function () {  //getter\n            return this._x;  //返回_x属性值\n        },\n        set : function (value) {  //setter\n            if (typeof value != \"number\"){\n              throw new Error('请输入数字');\n            }\n            this._x = value;  //赋值\n        }\n    }\n});\nconsole.log(obj.x);  //1\nobj.x = \"2\";  //抛出异常</code></pre></div><p><strong>示例 2</strong></p><p><br></p><p><em>JavaScript</em> 也支持一种简写方法。针对示例 <em>1</em>，通过以下方式可以快速定义属性。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = {\n    _x : 1,  // 定义 _x 属性\n    get x() { return this._x },  //定义 x 属性的 getter\n    set x(value) {  //定义 x 属性的 setter\n        if (typeof value != \"number\"){\n          throw new Error('请输入数字');\n        }\n        this._x = value;  // 赋值\n    }\n};\nconsole.log(obj.x);  //1\nobj.x = 2;\nconsole.log(obj.x);  //2</code></pre></div><p>取值函数 <em>get( )</em> 不能接收参数，存值函数 <em>set( )</em> 只能接收一个参数，用于设置属性的值。</p><h3>操作属性描述符</h3><p>属性描述符是一个内部对象，无法直接读写，可以通过下面几个函数进行操作。</p><ul><li><p><em>Object.getOwnPropertyDescriptor( )</em>：可以读出指定对象私有属性的属性描述符。</p></li><li><p><em>Object.defineProperty( )</em>：通过定义属性描述符来定义或修改一个属性，然后返回修改后的描述符。</p></li><li><p><em>Object.defineProperties( )</em>：可以同时定义多个属性描述符。</p></li><li><p><em>Object.getOwnPropertyNames( )</em>：获取对象的所有私有属性。</p></li><li><p><em>Object.keys( )</em>：获取对象的所有本地可枚举的属性。</p></li><li><p><em>propertyIsEnumerable( )</em>：对象实例方法，直接调用，判断指定的属性是否可枚举。</p></li></ul><p><strong>示例 1</strong></p><p><br></p><p>在下面示例中，定义 <em>obj</em> 的 <em>x</em> 属性允许配置特性，然后使用 <em>Object.getOwnPropertyDescriptor( )</em> 函数获取对象 <em>obj</em> 的 <em>x</em> 属性的属性描述符。修改属性描述符的 <em>set</em> 函数，重设检测条件，允许非数值型数字赋值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = Object.create(Object.prototype, {\n    _x: {  //数据属性\n        value: 1,  //初始值\n        writable: true\n    },\n    x: {  //访问器属性\n        configurable: true,  //允许修改配置\n        get: function () {  //getter\n            return this._x;  //返回_x属性值\n        },\n        set: function (value) {\n            if (typeof value != \"number\") {\n                throw new Error('请输入数字');\n            }\n            this._x = value;  //赋值\n        }\n    }\n});\nvar des = Object.getOwnPropertyDescriptor(obj, \"x\");  //获取属性x的属性描述符\ndes.set = function (value) {\n    //修改属性x的属性描述符set函数\n    //允许非数值型的数字，也可以进行赋值\n    if (typeof value != \"number\" &amp;&amp; isNaN(value * 1)) {\n        throw new Error('请输入数字');\n    }\n    this._x = value;\n}\nobj = Object.defineProperty(obj, \"x\", des);\nconsole.log(obj.x);  //1\nobj.x = \"2\";  //把一个给数值型数字赋值给属性x\nconsole.log(obj.x);  //2</code></pre></div><p><strong>示例 2</strong></p><p><br></p><p>下面示例先定义一个扩展函数，使用它可以把一个对象包含的属性以及丰富的信息复制给另一个对象。</p><p><br></p><p>【实现代码】</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function extend (toObj, fromObj) {  //扩展对象\n    for (var property in fromObj) {  //遍历对象属性\n        if (!fromObj.hasOwnProperty(property)) continue;  //过滤掉继承属性\n        Object.defineProperty(  //复制完整的属性信息\n            toObj,  //目标对象\n            property,  //私有属性\n            Object.getOwnPropertyDescriptor(fromObj, property)  //获取属性描述符\n        );\n    }\n    return toObj;  //返回目标对象\n}</code></pre></div><p>【应用代码】</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = {};  //新建对象\nobj.x = 1;  //定义对象属性\nextend(obj, { get y() { return 2} })  //定义读取器对象\nconsole.log(obj.y);  //2</code></pre></div><h3>控制对象状态</h3><p><em>JavaScript</em> 提供了 <em>3</em> 种方法，用来精确控制一个对象的读写状态，防止对象被改变。</p><ul><li><p><em>Object.preventExtensions</em>：阻止为对象添加新的属性。</p></li><li><p><em>Object.seal</em>：阻止为对象添加新的属性，同时也无法删除旧属性。等价于属性描述符的 <em>configurable</em> 属性设为 <em>false</em>。注意，该方法不影响修改某个属性的值。</p></li><li><p><em>Object.freeze</em>：阻止为一个对象添加新属性、删除旧属性、修改属性值。</p></li></ul><p>同时提供了 <em>3</em> 个对应的辅助检查函数，简单说明如下：</p><ul><li><p><em>Object.isExtensible</em>：检查一个对象是否允许添加新的属性。</p></li><li><p><em>Object.isSealed</em>：检查一个对象是否使用了 <em>Object.seal</em> 方法。</p></li><li><p><em>Object.isFrozen</em>：检查一个对象是否使用了 <em>Object.freeze</em> 方法。</p></li></ul><p><strong>示例</strong></p><p><br></p><p>下面代码分别使用 <em>Object.preventExtensions、Object.seal</em> 和 <em>Object.freeze</em> 函数控制对象的状态，然后再使用 <em>Object.isExtensible、Object.isSealed</em> 和 <em>Object.isFrozen</em> 函数检测对象的状态。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj1 = {};\nconsole.log(Object.isExtensible(obj1));  //true\nObject.preventExtensions(obj1);\nconsole.log(Object.isExtensible(obj1));  //false\nvar obj2 = {};\nconsole.log(Object.isSealed(obj2));  //true\nObject.seal(obj2);\nconsole.log(Object.isSealed(obj2));  //false\nvar obj3 = {};\nconsole.log(Object.isFrozen(obj3));  //true\nObject.freeze(obj3);\nconsole.log(Object.isFrozen(obj3));  //false</code></pre></div><h2>真题解答</h2><ul><li><p><em>JavaScript</em> 中对象的属性描述符有哪些？分别有什么作用？</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>属性描述符一共有 <em>6</em> 个，可以选择使用。</p><ul><li><p><em>value</em>：设置属性值，默认值为 <em>undefined</em>。</p></li><li><p><em>writable</em>：设置属性值是否可写，默认值为 <em>true</em>。</p></li><li><p><em>enumerable</em>：设置属性是否可枚举，即是否允许使用 <em>for/in</em> 语句或 <em>Object.keys( )</em> 函数遍历访问，默认为 <em>true</em>。</p></li><li><p><em>configurable</em>：设置是否可设置属性特性，默认为 <em>true</em>。如果为 <em>false</em>，将无法删除该属性，不能够修改属性值，也不能修改属性的属性描述符。</p></li><li><p><em>get</em>：取值函数，默认为 <em>undefined</em>。</p></li><li><p><em>set</em>：存值函数，默认为 <em>undefined</em>。</p></li></ul><p>使用属性描述符的时候，<em>get</em> 和 <em>set</em> 以及 <em>value</em> 和 <em>writable</em> 这两组是互斥的，设置了 <em>get</em> 和 <em>set</em> 就不能设置 <em>value</em> 和 <em>writable</em>，反之设置了 <em>value</em> 和 <em>writable</em> 也就不可以设置 <em>get</em> 和 <em>set</em>。</p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666077547067",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e53aa2fac4881713db3a0"
  },
  "interviewTitle": "class 和构造函数区别有哪些？",
  "interviewContent": "<h1><em>class</em> 和构造函数区别</h1><h2>经典真题</h2><ul><li><p>根据下面 <em>ES6</em> 构造函数的书写方式，要求写出 <em>ES5</em> 的</p></li></ul><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">class Example { \n  constructor(name) { \n    this.name = name;\n  }\n  init() { \n    const fun = () =&gt; { console.log(this.name) }\n    fun(); \n  } \n}\nconst e = new Example('Hello');\ne.init();</code></pre></div><h2>回顾 <em>class</em> 的写法</h2><p>上面的这道面试题，典型的就是考察 <em>ES6</em> 中新增的 <em>class</em> 和以前构造函数上面的区别是什么，以及如果通过 <em>ES5</em> 去模拟的话，具体如何实现。</p><p><br></p><p>那么在此之前，我们就先来回顾一下 <em>ES6</em> 中的 <em>class</em> 写法。</p><p><br></p><p>代码如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">class Computer {\n    // 构造器\n    constructor(name, price) {\n        this.name = name;\n        this.price = price;\n    }\n    // 原型方法\n    showSth() {\n        console.log(`这是一台${this.name}电脑`);\n    }\n    // 静态方法\n    static comStruct() {\n        console.log(\"电脑由显示器，主机，键鼠组成\");\n    }\n}</code></pre></div><p>上面的代码非常的简单，我们定义了一个名为 <em>Computer</em> 的类，该类存在 <em>name、price</em> 这两个实例属性，一个 <em>showSth</em> 的原型方法以及一个 <em>comStruct</em> 的静态方法。</p><p><br></p><p>我们可以简单的实例化一个对象出来，例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var apple = new Computer(\"苹果\", 15000);\nconsole.log(apple.name); // 苹果\nconsole.log(apple.price); // 15000\napple.showSth(); // 这是一台苹果电脑\nComputer.comStruct(); // 电脑由显示器，主机，键鼠组成</code></pre></div><p>在上面的代码中，我们从 <em>Computer</em> 类中实例化出来了一个 <em>apple</em> 的实例对象，然后简单访问了该对象的属性和方法。</p><h2>回顾构造函数的写法</h2><p>那么，在 <em>ES6</em> 出现之前，我们是如何实现类似于其他语言中的“类”的呢？</p><p><br></p><p>没错，我们是通过的构造函数，然后将方法挂在原型上面。例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function Computer(name, price){\n    this.name = name;\n    this.price = price;\n}\nComputer.prototype.showSth = function(){\n    console.log(`这是一台${this.name}电脑`);\n}\nComputer.comStruct = function(){\n    console.log(\"电脑由显示器，主机，键鼠组成\");\n}\n\nvar apple = new Computer(\"苹果\", 15000);\nconsole.log(apple.name); // 苹果\nconsole.log(apple.price); // 15000\napple.showSth(); // 这是一台苹果电脑\nComputer.comStruct(); // 电脑由显示器，主机，键鼠组成</code></pre></div><p>上面的代码就是我们经常在 <em>ES5</em> 中所书写的代码，通过构造函数来模拟类，实例方法挂在原型上面，静态方法就挂在构造函数上。</p><p><br></p><p>仿佛 <em>ES6</em> 的 <em>class</em> 写法就是上面构造函数写法的一种语法糖，但是事实真的如此么？</p><h2><em>class</em> 和构造函数区别上的细则</h2><p>接下来我们来详细比较一下两种写法在细节上面的一些差异。</p><p><br></p><p>首先我们书写两个“类”，一个用 <em>ES5</em> 的构造函数书写，一个用 <em>ES6</em> 的类的写法来书写，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">class Computer1 {\n    // 构造器\n    constructor(name, price) {\n        this.name = name;\n        this.price = price;\n    }\n    // 原型方法\n    showSth() {\n        console.log(`这是一台${this.name}电脑`);\n    }\n    // 静态方法\n    static comStruct() {\n        console.log(\"电脑由显示器，主机，键鼠组成\");\n    }\n}\n\nfunction Computer2(name, price){\n    this.name = name;\n    this.price = price;\n}\nComputer2.prototype.showSth = function(){\n    console.log(`这是一台${this.name}电脑`);\n}\nComputer2.comStruct = function(){\n    console.log(\"电脑由显示器，主机，键鼠组成\");\n}</code></pre></div><p>我们知道，构造函数也是函数，既然是函数，那么就可以通过函数调用的形式来调用该函数，例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var i = Computer2();\nconsole.log(i); // undefined</code></pre></div><p>运行上面的代码，代码不会报错，因为没有使用 <em>new</em> 的方式来调用，所以不会生成一个对象，返回值就为 <em>undefined</em>。</p><p><br></p><p>但是如果我们这样来调用 <em>ES6</em> 书写的类，会直接报错：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">Computer1();\n// TypeError: Class constructor Computer1 cannot be invoked without 'new'</code></pre></div><p>可以看到，<em>ES6</em> 所书写的 <em>class</em> ，虽然我们认为背后就是构造函数实现的，但是明显是做了特殊处理的，必须通过 <em>new</em> 关键字来调用。</p><p><br></p><p>接下来，我们来针对两种写法，各自实例化一个对象，代码如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var apple = new Computer2(\"苹果\", 15000);\nfor(var i in apple){\n    console.log(i); \n}\nconsole.log('-------');\nvar huawei = new Computer1(\"华为\", 12000);\nfor(var i in huawei){\n    console.log(i); \n}</code></pre></div><p>在上面的代码中， <em>apple</em> 对象是 <em>ES5</em> 构造函数的形式创建的实例，<em>huawei</em> 是 <em>ES6</em> 类的形式创建的实例。有了这两个对象后，我们遍历这两个对象的键，结果如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">name\nprice\nshowSth\n-------\nname\nprice</code></pre></div><p>可以看到，<em>ES6</em> 中的原型方法是不可被枚举的，说明 <em>ES6</em> 对此也是做了特殊处理的。</p><p><br></p><p>另外，<em>ES6</em> 的 <em>class</em> 中的所有代码均处于严格模式之下，这里我们也可以进行一个简单的验证。例如，对两种方式的 <em>showSth</em> 原型方法稍作修改，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">class Computer1 {\n    ...\n    // 原型方法\n    showSth(i,i) {\n        console.log(`这是一台${this.name}电脑`);\n    }\n   \t...\n}\nfunction Computer2(name, price){\n   ...\n}\nComputer2.prototype.showSth = function(j,j){\n    i = 10;\n    console.log(`这是一台${this.name}电脑`);\n}\n...</code></pre></div><p>在上面的代码中，我们为各自的 <em>showSth</em> 方法添加了重复的形式参数。我们知道，在严格模式中方法书写重复形参是不被允许的。</p><p><br></p><p>所以在运行代码时，<em>ES6</em> 的 <em>class</em> 声明方式会报错，错误信息如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// SyntaxError: Duplicate parameter name not allowed in this context</code></pre></div><p>还有就是，如果是 <em>ES6</em> 形式所声明的类，原型上的方法是不允许通过 <em>new</em> 来调用的。</p><p><br></p><p>这里我们也可以做一个简单的测试，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function Computer2(name, price){\n    this.name = name;\n    this.price = price;\n}\nComputer2.prototype.showSth = function(){\n    i = 10;\n    console.log(`这是一台${this.name}电脑`);\n}\nComputer2.comStruct = function(){\n    console.log(\"电脑由显示器，主机，键鼠组成\");\n}\n\nvar apple = new Computer2(\"苹果\", 15000);\nvar i = new apple.showSth(); // 这是一台undefined电脑\nconsole.log(i); // {}</code></pre></div><p>在上面的代码中，我们首先实例化了一个 <em>apple</em> 对象，在该对象的原型上面拥有一个 <em>showSth</em> 的实例方法，然后我们对其进行了 <em>new</em> 操作，可以看到返回了一个对象。</p><p><br></p><p>但是如果是 <em>ES6</em> 形式所声明的类，上面的做法将不被允许。示例如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">class Computer1 {\n    // 构造器\n    constructor(name, price) {\n        this.name = name;\n        this.price = price;\n    }\n    // 原型方法\n    showSth() {\n        console.log(`这是一台${this.name}电脑`);\n    }\n    // 静态方法\n    static comStruct() {\n        console.log(\"电脑由显示器，主机，键鼠组成\");\n    }\n}\nvar huawei = new Computer1(\"华为\", 12000);\nvar i = new huawei.showSth(); // TypeError: huawei.showSth is not a constructor\nconsole.log(i);</code></pre></div><p>在上面的代码中，我们企图对 <em>Computer1</em> 实例对象 <em>huawei</em> 的原型方法 <em>showSth</em> 进行 <em>new</em> 操作，可以看到，这里报出了 <em>TypeError</em>。</p><h2><em>Babel</em> 中具体的实现</h2><p>通过上面的各种例子，我们可以知道 <em>ES6</em> 中的 <em>class</em> 实现并不是我们单纯所想象的就是之前 <em>ES5</em> 写构造函数的写法，虽然本质上是构造函数，但是内部是做了各种处理的。</p><p><br></p><p>这里，我们就来使用 <em>Babel</em> 对下面的代码进行转义，转义之前的代码如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">class Computer {\n    // 构造器\n    constructor(name, price) {\n        this.name = name;\n        this.price = price;\n    }\n    // 原型方法\n    showSth() {\n        console.log(`这是一台${this.name}电脑`);\n    }\n    // 静态方法\n    static comStruct() {\n        console.log(\"电脑由显示器，主机，键鼠组成\");\n    }\n}</code></pre></div><p>转义后的代码如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">\"use strict\";\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\n\nfunction _defineProperties(target, props) {\n    for (var i = 0; i &lt; props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n            descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps)\n        _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\n\nvar Computer = /*#__PURE__*/function () {\n    // 构造器\n    function Computer(name, price) {\n        _classCallCheck(this, Computer);\n\n        this.name = name;\n        this.price = price;\n    } // 原型方法\n\n\n    _createClass(Computer, [{\n        key: \"showSth\",\n        value: function showSth() {\n            console.log(\"\\u8FD9\\u662F\\u4E00\\u53F0\".concat(this.name, \"\\u7535\\u8111\"));\n        } // 静态方法\n\n    }], [{\n        key: \"comStruct\",\n        value: function comStruct() {\n            console.log(\"电脑由显示器，主机，键鼠组成\");\n        }\n    }]);\n\n    return Computer;\n}();\nvar apple = new Computer(\"苹果\", 15000);\nconsole.log(apple.name); // 苹果\nconsole.log(apple.price); // 15000\napple.showSth(); // 这是一台苹果电脑\nComputer.comStruct(); // 电脑由显示器，主机，键鼠组成</code></pre></div><p>可以看到，果然没有我们想象的那么简单，接下来我们就来一点一点剖析转义的结果。</p><p><br></p><p>首先整体来讲分为下面几块：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">\"use strict\";\nfunction _classCallCheck(instance, Constructor) { ... }\n\nfunction _defineProperties(target, props) { ... }\n\nfunction _createClass(Constructor, protoProps, staticProps) { ... }\n\nvar Computer = /*#__PURE__*/function () { ... }();</code></pre></div><p>我们一块一块的来看。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}</code></pre></div><p>第一个方法叫做 <em>classCallCheck</em>，从名字上面我们也可以看出，这个方法是核对构造方法的调用形式的，接收两个参数，一个是实例对象，另一个是构造函数，通过 <em>instanceof</em> 来看参数 <em>instance</em> 是否是 <em>Constructor</em> 的实例，如果不是就抛出错误。</p><p><br></p><p>接下来是 <em>_defineProperties</em> 方法，我们对此方法稍作了修改，打印 <em>target</em> 和 <em>props</em> 的值</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function _defineProperties(target, props) {\n    console.log(\"target:::\",target);\n    console.log(\"props:::\",props);\n    for (var i = 0; i &lt; props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n            descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}</code></pre></div><p>结果如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">target::: {}\nprops::: [ { key: 'showSth', value: [Function: showSth] } ]\ntarget::: [Function: Computer]\nprops::: [ { key: 'comStruct', value: [Function: comStruct] } ]</code></pre></div><p>可以看出，该方法就是设置对象方法的属性描述符，包含是否可遍历呀，是否可写呀等信息，设置完成后将方法挂在 <em>target</em> 对象上面。</p><p><br></p><p>下一个是 <em>_createClass</em> 函数，我们仍然将三个参数打印出来</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function _createClass(Constructor, protoProps, staticProps) {\n    console.log(\"Constructor::\",Constructor);\n    console.log(\"protoProps::\",protoProps);\n    console.log(\"staticProps::\",staticProps);\n    if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps)\n        _defineProperties(Constructor, staticProps);\n    return Constructor;\n}</code></pre></div><p>结果如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">Constructor:: [Function: Computer]\nprotoProps:: [ { key: 'showSth', value: [Function: showSth] } ]\nstaticProps:: [ { key: 'comStruct', value: [Function: comStruct] } ]</code></pre></div><p>可以看出，接收的三个参数一次为构造函数、原型上的方法，静态方法。接下来在该方法里面所做的事情也就非常清晰了。</p><p><br></p><p>最后就是我们的构造函数了：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var Computer = /*#__PURE__*/function () {\n    // 构造器\n    function Computer(name, price) {\n        // 进行调用确认\n        _classCallCheck(this, Computer);\n\t\t\t\t// 添加实例属性\n        this.name = name;\n        this.price = price;\n    } // 原型方法\n\n\t\t// 将实例方法和静态方法添加到构造函数上面\n    _createClass(Computer, [{\n        key: \"showSth\",\n        value: function showSth() {\n            console.log(\"\\u8FD9\\u662F\\u4E00\\u53F0\".concat(this.name, \"\\u7535\\u8111\"));\n        } // 静态方法\n\n    }], [{\n        key: \"comStruct\",\n        value: function comStruct() {\n            console.log(\"电脑由显示器，主机，键鼠组成\");\n        }\n    }]);\n\n    return Computer;\n}();</code></pre></div><p>明白了 <em>_createClass</em> 方法的作用后，该方法的代码也就非常的清晰了。</p><h2>真题解答</h2><ul><li><p>根据下面 <em>ES6</em> 构造函数的书写方式，要求写出 <em>ES5</em> 的</p></li></ul><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">class Example { \n  constructor(name) { \n    this.name = name;\n  }\n  init() { \n    const fun = () =&gt; { console.log(this.name) }\n    fun(); \n  } \n}\nconst e = new Example('Hello');\ne.init();</code></pre></div><blockquote><p>参考答案：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\n\nfunction _defineProperties(target, props) {\n    for (var i = 0; i &lt; props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n            descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps)\n        _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\n\nvar Example = /*#__PURE__*/function () {\n   function Example(name) {\n        _classCallCheck(this, Example);\n\n        this.name = name;\n   }\n\n   _createClass(Example, [{\n        key: \"init\",\n        value: function init() {\n            var _this = this;\n\n            var fun = function fun() {\n                console.log(_this.name);\n            };\n\n            fun();\n        }\n   }]);\n\n   return Example;\n}();\n\nvar e = new Example('Hello');\ne.init();</code></pre></div><p>这里可以解释出 <em>_classCallCheck、_defineProperties、_createClass</em> 这几个方法各自的作用是什么。</p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666077610811",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e53fc2fac4881713db3a4"
  },
  "interviewTitle": "为什么 0.1+0.2==0.3 得到的值为 false",
  "interviewContent": "<h1>浮点数精度问题</h1><h2>经典真题</h2><ul><li><p>为什么 <em>console.log(0.2+0.1==0.3)</em>  得到的值为 <em>false</em></p></li></ul><h2>浮点数精度常见问题</h2><p>在 <em>JavaScript</em> 中整数和浮点数都属于 <em>number</em> 数据类型，所有数字都是以 <em>64</em> 位浮点数形式储存，即便整数也是如此。 所以我们在打印 <em>1.00</em> 这样的浮点数的结果是 <em>1</em> 而非 <em>1.00</em> 。</p><p><br></p><p>在一些特殊的数值表示中，例如金额，这样看上去有点别扭，但是至少值是正确了。</p><p><br></p><p>然而要命的是，当浮点数做数学运算的时候，你经常会发现一些问题，举几个例子：</p><p><br></p><p><strong>场景一</strong>：进行浮点值运算结果的判断</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// 加法 \nconsole.log(0.1 + 0.2); // 0.30000000000000004\nconsole.log(0.7 + 0.1); // 0.7999999999999999\nconsole.log(0.2 + 0.4); // 0.6000000000000001\nconsole.log(2.22 + 0.1); // 2.3200000000000003\n \n// 减法\nconsole.log(1.5 - 1.2); // 0.30000000000000004\nconsole.log(0.3 - 0.2); // 0.09999999999999998\n \n// 乘法 \nconsole.log(19.9 * 100); // 1989.9999999999998\nconsole.log(19.9 * 10 * 10); // 1990\nconsole.log(9.7 * 100); // 969.9999999999999\nconsole.log(39.7 * 100); // 3970.0000000000005\n \n// 除法 \nconsole.log(0.3 / 0.1); // 2.9999999999999996\nconsole.log(0.69 / 10); // 0.06899999999999999</code></pre></div><p><strong>场景二</strong>：将小数乘以 <em>10</em> 的 <em>n</em> 次方取整</p><p><br></p><p>比如将钱币的单位，从元转化成分，经常写出来的是 <em>parseInt(yuan*100, 10)</em></p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">console.log(parseInt(0.58 * 100, 10)); // 57</code></pre></div><p><strong>场景三</strong>：四舍五入保留 <em>n</em> 位小数</p><p><br></p><p>例如我们会写出  <em>(number).toFixed(2)</em>，但是看下面的例子：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">console.log((1.335).toFixed(2)); // 1.33</code></pre></div><p>在上面的例子中，我们得出的结果是 <em>1.33</em>，而不是预期结果 <em>1.34</em>。</p><h2>为什么会有这样的问题</h2><p>似乎是不可思议。小学生都会算的题目，<em>JavaScript</em> 不会？</p><p><br></p><p>我们来看看其真正的原因，到底为什么会产生精度丢失的问题呢？</p><p><br></p><p>计算机底层只有 <em>0</em> 和 <em>1</em>， 所以所有的运算最后实际上都是二进制运算。</p><p><br></p><p>十进制整数利用辗转相除的方法可以准确地转换为二进制数，但浮点数呢？</p><p><br></p><p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fc493d0e2e84274b8445d8c5df405ae~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"img\" contenteditable=\"false\"><br></p><p><br></p><p><em>JavaScript</em> 里的数字是采用 <em>IEEE 754</em> 标准的 <em>64</em> 位双精度浮点数。</p><p><br></p><p>先看下面一张图：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-29-060439.png\" alt=\"preview\" contenteditable=\"false\"><br></p><p><br></p><p>该规范定义了浮点数的格式，对于 <em>64</em> 位的浮点数在内存中的表示，最高的 <em>1</em> 位是符号位，接着的 <em>11</em> 位是指数，剩下的 <em>52</em> 位为有效数字，具体如下：</p><ul><li><p>符号位 <em>S</em>：第 <em>1</em> 位是正负数符号位（<em>sign</em>），<em>0</em> 代表正数，<em>1</em> 代表负数</p></li><li><p>指数位 <em>E</em>：中间的 <em>11</em> 位存储指数（<em>exponent</em>），用来表示次方数</p></li><li><p>尾数位 <em>M</em>：最后的 <em>52</em> 位是尾数（<em>mantissa</em>），储存小数部分，超出的部分自动进一舍零</p></li></ul><p>也就是说，浮点数最终在运算的时候实际上是一个符合该标准的二进制数</p><p><br></p><p>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。</p><p><br></p><p><em>IEEE 754</em> 规定，有效数字第一位默认总是 <em>1</em>，不保存在 <em>64</em> 位浮点数之中。也就是说，有效数字总是 <em>1.xx…xx</em> 的形式，其中 <em>xx…xx</em> 的部分保存在 <em>64</em> 位浮点数之中，最长可能为 <em>52</em> 位。因此，<em>JavaScript</em> 提供的有效数字最长为 <em>53</em> 个二进制位（<em>64</em> 位浮点的后 <em>52</em> 位 + 有效数字第一位的 <em>1</em>）。</p><p><br></p><p>既然限定位数，必然有截断的可能。</p><p><br></p><p>我们可以看一个例子：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">console.log(0.1 + 0.2); // 0.30000000000000004</code></pre></div><p>为了验证该例子，我们得先知道怎么将浮点数转换为二进制，整数我们可以用除 <em>2</em> 取余的方式，小数我们则可以用乘 <em>2</em> 取整的方式。</p><p><br></p><p><em>0.1</em> 转换为二进制：</p><p><br></p><p><em>0.1 * 2</em>，值为 <em>0.2</em>，小数部分 <em>0.2</em>，整数部分 <em>0</em></p><p><br></p><p><em>0.2 * 2</em>，值为 <em>0.4</em>，小数部分 <em>0.4</em>，整数部分 <em>0</em></p><p><br></p><p><em>0.4 * 2</em>，值为0.8，小数部分0.8，整数部分0</p><p><br></p><p><em>0.8 * 2</em>，值为 <em>1.6</em>，小数部分 <em>0.6</em>，整数部分 <em>1</em></p><p><br></p><p><em>0.6 * 2</em>，值为 <em>1.2</em>，小数部分 <em>0.2</em>，整数部分 <em>1</em></p><p><br></p><p><em>0.2 * 2</em>，值为 <em>0.4</em>，小数部分 <em>0.4</em>，整数部分 <em>0</em></p><p><br></p><p>从 <em>0.2</em> 开始循环</p><p><br></p><p><em>0.2</em>  转换为二进制可以直接参考上述，肯定最后也是一个循环的情况</p><p><br></p><p>所以最终我们能得到两个循环的二进制数：</p><p><br></p><p><em>0.1：0.0001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1100 ...</em></p><p><br></p><p><em>0.2：0.0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 ...</em></p><p><br></p><p>这两个的和的二进制就是：</p><p><br></p><p><em>sum：0.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 ...</em></p><p><br></p><p>最终我们只能得到和的近似值（按照 <em>IEEE 754</em> 标准保留 <em>52</em> 位，按 <em>0</em> 舍 <em>1</em> 入来取值），然后转换为十进制数变成：</p><p><br></p><p>sum ≈ 0.30000000000000004</p><p><br></p><p>再例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">console.log((1.335).toFixed(2)); // 1.33</code></pre></div><p>因为 <em>1.335</em> 其实是 <em>1.33499999999999996447286321199</em>，<em>toFixed</em> 虽然是四舍五入，但是是对 <em>1.33499999999999996447286321199</em> 进行四五入，所以得出 <em>1.33</em>。</p><p><br></p><p>在 <em>Javascript</em> 中，整数精度同样存在问题，先来看看问题：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">console.log(19571992547450991); // 19571992547450990\nconsole.log(19571992547450991===19571992547450992); // true</code></pre></div><p>同样的原因，在 <em>JavaScript</em> 中  <em>number</em> 类型统一按浮点数处理，整数是按最大 <em>54</em> 位来算，</p><ul><li><p>最大( <em>253 - 1</em>，<em>Number.MAX_SAFE_INTEGER</em>、<em>9007199254740991</em>)</p></li><li><p>最小( <em>-(253 - 1)</em>，<em>Number.MIN_SAFE_INTEGER</em>、<em>-9007199254740991</em>)</p></li></ul><p>所以只要超过这个范围，就会存在被舍去的精度问题。</p><p><br></p><p>当然这个问题并不只是在 <em>Javascript</em> 中才会出现，几乎所有的编程语言都采用了 <em>IEEE-754</em> 浮点数表示法，任何使用二进制浮点数的编程语言都会有这个问题。</p><p><br></p><p>只不过在很多其他语言中已经封装好了方法来避免精度的问题，而 <em>JavaScript</em> 是一门弱类型的语言，从设计思想上就没有对浮点数有个严格的数据类型，所以精度误差的问题就显得格外突出。</p><p><br></p><p>通常这种对精度要求高的计算都应该交给后端去计算和存储，因为后端有成熟的库来解决这种计算问题。</p><p><br></p><p>前端也有几个不错的类库：</p><p><br></p><p><strong><em>Math.js</em></strong></p><p><br></p><p><em>Math.js</em> 是专门为 <em>JavaScript</em> 和 <em>Node.js</em> 提供的一个广泛的数学库。它具有灵活的表达式解析器，支持符号计算，配有大量内置函数和常量，并提供集成解决方案来处理不同的数据类型。</p><p><br></p><p>像数字，大数字（超出安全数的数字），复数，分数，单位和矩阵。 功能强大，易于使用。</p><p><br></p><p><strong><em>decimal.js</em></strong></p><p><br></p><p>为 <em>JavaScript</em> 提供十进制类型的任意精度数值。</p><p><br></p><p><strong><em>big.js</em></strong></p><p><br></p><p>不仅能够支持处理 <em>Long</em> 类型的数据，也能够准确的处理小数的运算。</p><h2>真题解答</h2><ul><li><p>为什么 <em>console.log(0.2+0.1==0.3)</em>  得到的值为 <em>false</em></p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>因为浮点数的计算存在 <em>round-off</em>  问题，也就是浮点数不能够进行精确的计算。并且：</p><ul><li><p>不仅 <em>JavaScript</em>，所有遵循 <em>IEEE 754</em> 规范的语言都是如此；</p></li><li><p>在 <em>JavaScript</em> 中，所有的 <em>Number</em> 都是以 <em>64-bit</em> 的双精度浮点数存储的；</p></li><li><p>双精度的浮点数在这 <em>64</em> 位上划分为 <em>3</em> 段，而这 <em>3</em> 段也就确定了一个浮点数的值，<em>64bit</em> 的划分是“<em>1-11-52</em>”的模式，具体来说：</p><ul><li><p>就是 <em>1</em> 位最高位（最左边那一位）表示符号位，<em>0</em> 表示正，<em>1</em> 表示负；</p></li><li><p><em>11</em> 位表示指数部分；</p></li><li><p><em>52</em> 位表示尾数部分，也就是有效域部分</p></li></ul></li></ul></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666077692003",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e542e2fac4881713db3a8"
  },
  "interviewTitle": "什么是 JS 的严格模式？",
  "interviewContent": "<h1>严格模式</h1><h2>经典真题</h2><ul><li><p><em>use strict</em> 是什么意思 ? 使用它区别是什么？</p></li></ul><h2>什么是严格模式</h2><p>严格模式是从 <em>ES5</em> 开始新增的一种方式，是采用具有限制性 <em>JavaScript</em> 变体的一种方式，从而使代码隐式地脱离“马虎模式/稀松模式/懒散模式“（<em>sloppy</em>）模式。</p><p><br></p><p>设立\"严格模式\"的目的，主要有以下几个：</p><ul><li><p>消除 <em>Javascript</em> 语法的一些不合理、不严谨之处，减少一些怪异行为;</p></li><li><p>消除代码运行的一些不安全之处，保证代码运行的安全；</p></li><li><p>提高编译器效率，增加运行速度；</p></li><li><p>为未来新版本的 <em>Javascript</em> 做好铺垫。</p></li></ul><p>“严格模式”体现了 <em>Javascript</em> 更合理、更安全、更严谨的发展方向，支持严格模式的浏览器有：<em>Internet Explorer 10 +、 Firefox 4+ Chrome 13+、 Safari 5.1+、 Opera 12+</em>。</p><p><br></p><p>在“严格模式下”，同样的代码，可能会有不一样的运行结果。一些在“正常模式”下可以运行的语句，在“严格模式”下将不能运行。</p><p><br></p><p>掌握这些内容，有助于更细致深入地理解 <em>Javascript</em>，让你变成一个更好的程序员。</p><h2>开启严格模式</h2><p>进入“严格模式”的标志，是下面这行语句：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">\"use strict\";</code></pre></div><p>老版本的浏览器会把它当作一行普通字符串，加以忽略。</p><p><br></p><p>“严格模式”有两种调用方法，适用于不同的场合。</p><p><br></p><p><strong>针对整个脚本文件</strong></p><p><br></p><p>将 <em>“use strict”</em> 放在脚本文件的第一行，则整个脚本都将以“严格模式”运行。</p><p><br></p><p>如果这行语句不在第一行，则无效，整个脚本以“正常模式”运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">\"use strict\";\nconsole.log(\"这是严格模式。\");</code></pre></div><p>在上面的代码中，我们第一行书写了 <em>“use strict”</em>，所以整个代码会进入到严格模式执行。</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;script&gt;\n  \"use strict\";\n  console.log(\"这是严格模式。\");\n&lt;/script&gt;\n\n&lt;script&gt;\n  console.log(\"这是正常模式。\");\n&lt;/script&gt;</code></pre></div><p>上面的代码表示，一个网页中依次有两段 <em>Javascript</em> 代码。前一个 <em>script</em> 标签是严格模式，后一个不是。</p><p><br></p><p><strong>针对单个函数</strong></p><p><br></p><p>将 <em>“use strict”</em> 放在函数体的第一行，则整个函数以“严格模式”运行。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function strict(){\n  \"use strict\";\n  return \"这是严格模式。\";\n}\n\nfunction notStrict() {\n  return \"这是正常模式。\";\n}</code></pre></div><p><strong>脚本文件的变通写法</strong></p><p><br></p><p>因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">(function (){\n  \"use strict\";\n  // some code here\n})();</code></pre></div><h2>严格模式和普通模式区别</h2><p>接下来，我们就来看一下严格模式下对 <em>Javascript</em> 的语法和行为，都做了哪些改变。</p><p><br></p><p><strong>没有使用 <em>var</em> 声明的变量不能使用</strong></p><p><br></p><p>在普通模式下，我们可以使用一个未声明的变量，此时该变量会成为一个全局变量。但是这种使用方式在严格模式下会报错。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">\"use strict\"\na=10; // ReferenceError: a is not defined\nconsole.log(a)\nfunction sum(){\n\tvar a=10;\n\tconsole.log(a)\n}\nsum()</code></pre></div><p><strong>删除变量和不存在的属性会报错</strong></p><p><br></p><p>在普通模式下，删除变量或者不允许删除的属性虽然也会失败，但是是“静默失败”，也就是说虽然失败了，但是不会给出任何提示。这样其实会产生很多隐藏问题，也给程序员的调错带来了难度。</p><p><br></p><p>在严格模式下则会保存，例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">\"use strict\"\nvar i = 10;\ndelete i; // SyntaxError: Delete of an unqualified identifier in strict mode.\nconsole.log(i); // 10</code></pre></div><p><strong>函数中相同的形参名会报错</strong></p><p><br></p><p>在普通模式下，函数中两个形参名相同也不会报错，只不过后面的形参所接收到的值会覆盖前面的同名形参。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function a(b,b){\n    console.log(b); // 2\n}\na(1, 2)   </code></pre></div><p>但是在严格模式下，相同的形参名会报错。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">\"use strict\"\n// SyntaxError: Duplicate parameter name not allowed in this context\nfunction a(b,b){\n    console.log(b);\n}\na(1, 2)   </code></pre></div><p><strong>对象不能有重名的属性</strong></p><p><br></p><p>正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">\"use strict\";\nvar o = {\n  p: 1,\n  p: 2\n}; // 语法错误</code></pre></div><p><strong>禁止八进制表示法</strong></p><p><br></p><p>正常模式下，整数的第一位如果是 <em>0</em>，表示这是八进制数，比如 <em>010</em> 等于十进制的 <em>8</em>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var i = 010;\nconsole.log(i); // 8</code></pre></div><p>严格模式禁止这种表示法，整数第一位为 <em>0</em>，将报错。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">\"use strict\"\nvar i = 010; // SyntaxError: Octal literals are not allowed in strict mode.\nconsole.log(i);</code></pre></div><p><strong>函数内部 <em>this</em> 值为 <em>undefined</em></strong></p><p><br></p><p>在普通模式下，函数中的 <em>this</em> 在以函数的形式被调用时，指向全局对象。而在严格模式中，得到的值为 <em>undefined</em>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">\"use strict\"\nfunction a(){\n    console.log(this); // undefined\n}\na();</code></pre></div><p><strong>创设 <em>eval</em> 作用域</strong></p><p><br></p><p>正常模式下，<em>Javascript</em> 语言有两种变量作用域（<em>scope</em>）：全局作用域和函数作用域。</p><p><br></p><p>严格模式创设了第三种作用域：<em>eval</em> 作用域。</p><p><br></p><p>正常模式下，<em>eval</em> 语句的作用域，取决于它处于全局作用域，还是处于函数作用域。</p><p><br></p><p>严格模式下，<em>eval</em> 语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于 <em>eval</em> 内部。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">\"use strict\";\nvar x = 2;\nconsole.info(eval(\"var x = 5; x\")); // 5\nconsole.info(x); // 2</code></pre></div><p><strong>保留字</strong></p><p><br></p><p>为了向将来 <em>Javascript</em> 的新版本过渡，严格模式新增了一些保留字：<em>implements, interface, let, package, private, protected, public, static, yield</em>。使用这些词作为变量名将会报错。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">\"use strict\";\nvar public = \"hello world\" // SyntaxError: Unexpected strict mode reserved word\nconsole.log(public);</code></pre></div><p>更多关于严格模式的内容，可以参阅 ：</p><p><br></p><p><em>MDN</em>：<em>https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode</em></p><p><br></p><p>《<em>Javascript</em> 严格模式详解 <em>By</em> 阮一峰》：<em>http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html</em></p><h2>真题解答</h2><ul><li><p><em>use strict</em> 是什么意思 ? 使用它区别是什么？</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p><em>use strict</em> 代表开启严格模式，这种模式使得 <em>Javascript</em> 在更严格的条件下运行，实行更严格解析和错误处理。</p><p><br></p><p>开启“严格模式”的优点：</p><ul><li><p>消除 <em>Javascript</em> 语法的一些不合理、不严谨之处，减少一些怪异行为;</p></li><li><p>消除代码运行的一些不安全之处，保证代码运行的安全；</p></li><li><p>提高编译器效率，增加运行速度；</p></li><li><p>为未来新版本的 <em>Javascript</em> 做好铺垫。</p></li></ul><p>回答一些具体的严格模式下和普通模式之间的区别。</p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666077742387",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e54a72fac4881713db3be"
  },
  "interviewTitle": "什么是函数防抖和节流？",
  "interviewContent": "<h1>函数防抖和节流</h1><h2>经典真题</h2><ul><li><p>防抖，节流是什么，如何实现 （字节）</p></li></ul><h2>什么是函数防抖和节流</h2><p><em>JavaScript</em> 中的函数大多数情况下都是由用户主动调用触发的，除非是函数本身的实现不合理，否则一般不会遇到跟性能相关的问题。</p><p><br></p><p>但是在一些少数情况下，函数的触发不是由用户直接控制的。在这些场景下，函数有可能被非常频繁地调用，而造成大的性能问题。解决性能问题的处理办法就有<strong>函数防抖</strong>和<strong>函数节流</strong>。</p><p><br></p><p>下面是函数被频繁调用的常见的几个场景：</p><ul><li><p><em>mousemove</em> 事件：如果要实现一个拖拽功能，需要一路监听 <em>mousemove</em> 事件，在回调中获取元素当前位置，然后重置 <em>DOM</em> 的位置来进行样式改变。如果不加以控制，每移动一定像素而触发的回调数量非常惊人，回调中又伴随着 DOM 操作，继而引发浏览器的重排与重绘，性能差的浏览器可能就会直接假死。</p></li><li><p><em>window.onresize</em> 事件：为 <em>window</em> 对象绑定了 <em>resize</em> 事件，当浏览器窗口大小被拖动而改变的时候，这个事件触发的频率非常之高。如果在 <em>window.onresize</em> 事件函数里有一些跟 <em>DOM</em> 节点相关的操作，而跟 <em>DOM</em> 节点相关的操作往往是非常消耗性能的，这时候浏览器可能就会吃不消而造成卡顿现象。</p></li><li><p>射击游戏的 <em>mousedown/keydown</em> 事件（单位时间只能发射一颗子弹）</p></li><li><p>搜索联想（<em>keyup</em> 事件）</p></li><li><p>监听滚动事件判断是否到页面底部自动加载更多（<em>scroll</em> 事件）</p></li></ul><p>对于这些情况的解决方案就是函数防抖（<em>debounce</em>）或函数节流（<em>throttle</em>），<strong>其核心就是限制某一个方法的频繁触发</strong>。</p><h2>函数防抖</h2><p>我们首先来看函数防抖。<strong>函数防抖，是指防止函数在极短的时间内反复调用，造成资源的浪费</strong>。</p><p><br></p><p>考虑一下电梯关门的场景，现代的大部分电梯都可以通过红外，感知到是否有人进入，为了避免夹到人，同时为了等待后面的人，电梯关门的时间往往有这么一种规则：**始终保证电梯门在最后一个人进入后 <em>3</em> 秒后关闭。**如果有人进入后，还没有等到 <em>3</em> 秒又有人进来了，电梯门会以最后一次进入的时间为计时起点，重新等待3秒。</p><p><br></p><p>再考虑一个页面上的场景，页面上的某些事件触发频率非常高，比如滚动条滚动、窗口尺寸变化、鼠标移动等，如果我们需要注册这类事件，不得不考虑效率问题，又特别是事件处理中涉及到了大量的操作，比如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">window.onresize = function(){\n    // 大量的 DOM 操作\n}</code></pre></div><p>当窗口尺寸发生变化时，哪怕只变化了一点点，都有可能造成成百上千次对处理函数的调用，这对网页性能的影响是极其巨大的。</p><p><br></p><p>于是，我们可以考虑，每次窗口尺寸变化、滚动条滚动、鼠标移动时，不要立即执行相关操作，而是等一段时间，以窗口尺寸停止变化、滚动条不再滚动、鼠标不再移动为计时起点，一段时间后再去执行操作，就像电梯关门那样。</p><p><br></p><p>再考虑一个搜索的场景（例如百度），当我在一个文本框中输入文字（键盘按下事件）时，需要将文字发送到服务器，并从服务器得到搜索结果，这样的话，用户直接输入搜索文字就可以了，不用再去点搜索按钮，可以提升用户体验，类似于下面的效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-01-014859.gif\" alt=\"5be978627ac99\" contenteditable=\"false\"><br></p><p><br></p><p>上面的效果，我没有点击搜索按钮，也没有按回车键，只是写了一些搜索的文字而已。</p><p><br></p><p>可是如何来实现上面的场景呢？</p><p><br></p><p>如果文本框的文字每次被改变（键盘按下事件），我都要把数据发送到服务器，得到搜索结果，这是非常恐怖的！</p><p><br></p><p>想想看，我搜索 <em>“google”</em> 这样的单词，至少需要按 <em>6</em> 次按键，就这一个词，我需要向服务器请求 <em>6</em> 次，并让服务器去搜索 <em>6</em> 次，但我只需要最后一次的结果就可以了。如果考虑用户按错的情况，发送请求的次数更加恐怖。这样就造成了大量的带宽被占用，浪费了很多资源。</p><p><br></p><p>如何避免这样的问题呢？</p><p><br></p><p>仔细观察，你会发现，真正的搜索行为，并不是每次按键都会触发的，只有当用户停止按键一段事件后才会触发。</p><p><br></p><p>于是，为了满足这种类型场景，我们可以开发一个通用的函数，这个函数要满足以下功能：</p><ol><li><p>调用该函数后，不立即做事，而是一段时间后去做事</p></li><li><p>如果在等待时间内调用了该函数，重新计时</p></li></ol><p>这样的功能，就叫做函数防抖，其实就是防止函数短时间内被调用多次。</p><p><br></p><p>要完成该函数，需要给予两个条件：</p><ol><li><p>告诉我一段时间后要做什么事（这里应该是一个回调函数，即函数作为参数）</p></li><li><p>告诉我要等待多长时间（毫秒）</p></li></ol><p>下面我们就来封装这么一个函数防抖的通用函数：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">/**\n * 函数防抖\n * @param {function} func 一段时间后，要调用的函数\n * @param {number} wait 等待的时间，单位毫秒\n */\nfunction debounce(func, wait) {\n    // 设置变量，记录 setTimeout 得到的 id\n    var timerId = null;\n    return function (...args) {\n        if (timerId) {\n            // 如果有值，说明目前正在等待中，清除它\n            clearTimeout(timerId);\n        }\n        // 重新开始计时\n        timerId = setTimeout(() =&gt; {\n            func(...args);\n        }, wait);\n    }\n}</code></pre></div><p>下面来进行一个测试，测试如下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;input type=\"text\" id=\"txt\"&gt;</code></pre></div><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var txt = document.getElementById(\"txt\");\n// 调用 debounce 函数来将事件处理函数变为一个防抖函数\nvar debounceHandle = debounce(function(event){\n  console.log(event.target.value);\n}, 500)\ntxt.onkeyup = (event)=&gt;{\n  debounceHandle(event);\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-01-020722.gif\" alt=\"2021-10-01 10.06.44\" contenteditable=\"false\"><br></p><h2>函数节流</h2><p>函数节流的目的，也是为了防止一个函数短时间内被频繁的触发。</p><p><br></p><p>和函数防抖的原理不同，函数节流的核心思想是让连续的函数执行，变为固定时间段间断地执行。</p><p><br></p><p>这里做一个形象的的比喻：</p><p><br></p><p>前面我们所介绍的函数防抖，是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。</p><p><br></p><p>而这里我们要介绍的函数节流，指一定时间内函数只执行一次。比如人的眨眼睛，就是一定时间内眨一次。这是函数节流最形象的解释。</p><p><br></p><p>关于节流的实现，有 <em>2</em> 种主流的实现方式，一种是<strong>使用时间戳</strong>，一种是<strong>设置定时器</strong>。</p><p><br></p><p><strong>（1）使用时间戳</strong></p><p><br></p><p>触发事件时，取出当前的时间戳，然后减去之前的时间戳（最一开始值设为 <em>0</em>），如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p><p><br></p><p>下面是封装使用时间戳的函数节流的通用函数：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">/**\n * \n * @param {要进行节流的函数} func \n * @param {间隔时间} wait \n * @returns \n */\nfunction throttle(func, wait) {\n    var args; // 存储函数参数\n    var previous = 0; // 一开始的默认时间\n    return function () {\n        var now = new Date(); // 获取最新的时间戳\n        args = arguments; // 获取参数\n        // 进行时间戳的判断，如果超出规定时间，则执行\n        if (now - previous &gt; wait) {\n            func.apply(null, args);\n            previous = now;\n        }\n    }\n}</code></pre></div><p>下面来实际使用测试一下：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;input type=\"text\" id=\"txt\"&gt;</code></pre></div><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var txt = document.getElementById(\"txt\");\n// 调用 throttle 函数来将事件处理函数变为一个节流函数\nvar throttleHandle = throttle(function (event) {\n  console.log(event.target.value);\n}, 1000)\ntxt.onkeyup = (event) =&gt; {\n  throttleHandle(event);\n}</code></pre></div><p>效果如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-01-022740.gif\" alt=\"2021-10-01 10.27.15\" contenteditable=\"false\"><br></p><p><br></p><p><strong>（2）设置定时器</strong></p><p><br></p><p>第二种方式是设置定时器，触发事件时设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p><p><br></p><p>下面是封装使用定时器的函数节流的通用函数：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">/**\n * \n * @param {要节流执行的函数} func \n * @param {节流的时间间隔} wait \n * @returns \n */\nfunction throttle(func, wait) {\n    // timeout 存储计时器返回值\n    // args 存储参数\n    var timeout, args;\n    return function () {\n        args = arguments;\n        // 如果 timeout 有值，说明上一次的执行间隔时间还没过\n        if (!timeout) {\n            // 进入此 if 说明时间间隔已经过了\n            // 先执行一次要执行的函数\n            func.apply(null, args)\n            // 然后重新设置时间间隔\n            timeout = setTimeout(function () {\n                timeout = null;\n            }, wait);\n        }\n    }\n}</code></pre></div><h2>真题解答</h2><ul><li><p>防抖，节流是什么，如何实现 （字节）</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>我们在平时开发的时候，会有很多场景会频繁触发事件，比如说搜索框实时发请求，<em>onmousemove、resize、onscroll</em> 等，有些时候，我们并不能或者不想频繁触发事件，这时候就应该用到函数防抖和函数节流。</p><p><br></p><p>函数防抖(<em>debounce</em>)，指的是短时间内多次触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行。</p><p><br></p><p>具体实现如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">/**\n * 函数防抖\n * @param {function} func 一段时间后，要调用的函数\n * @param {number} wait 等待的时间，单位毫秒\n */\nfunction debounce(func, wait) {\n    // 设置变量，记录 setTimeout 得到的 id\n    var timerId = null;\n    return function (...args) {\n        if (timerId) {\n            // 如果有值，说明目前正在等待中，清除它\n            clearTimeout(timerId);\n        }\n        // 重新开始计时\n        timerId = setTimeout(() =&gt; {\n            func(...args);\n        }, wait);\n    }\n}</code></pre></div><p>函数节流(<em>throttle</em>)，指连续触发事件但是在 <em>n</em> 秒中只执行一次函数。即 <em>2n</em> 秒内执行 <em>2</em> 次... 。</p><p><br></p><p>节流如字面意思，会稀释函数的执行频率。</p><p><br></p><p>下面是使用时间戳方式的具体实现：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">/**\n * \n * @param {要进行节流的函数} func \n * @param {间隔时间} wait \n * @returns \n */\nfunction throttle(func, wait) {\n    var args; // 存储函数参数\n    var previous = 0; // 一开始的默认时间\n    return function () {\n        var now = new Date(); // 获取最新的时间戳\n        args = arguments; // 获取参数\n        // 进行时间戳的判断，如果超出规定时间，则执行\n        if (now - previous &gt; wait) {\n            func.apply(null, args);\n            previous = now;\n        }\n    }\n}</code></pre></div></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666077863826",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e54d82fac4881713db3c2"
  },
  "interviewTitle": "是否了解 WeakMap 和 WeakSet？",
  "interviewContent": "<h1><em>WeakSet</em> 和 <em>WeakMap</em></h1><h2>经典真题</h2><ul><li><p>是否了解 <em>WeakMap、WeakSet</em>（美团 <em>19</em> 年）</p></li></ul><h2>从对象开始说起</h2><p>首先我们从大家都熟悉的对象开始说起。</p><p><br></p><p>对于对象的使用，大家其实是非常熟悉的，所以我们这里仅简单的过一遍。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const algorithm = { site: \"leetcode\" };\nconsole.log(algorithm.site); // leetcode\n\nfor (const key in algorithm) {\n  console.log(key, algorithm[key]);\n}\n\n// site leetcode\ndelete algorithm.site;\nconsole.log(algorithm.site); // undefined</code></pre></div><p>在上面的代码中，我们有一个 <em>algorithm</em> 对象，它的 <em>key</em> 和 <em>value</em> 是一个字符串类型的值，之后通过点（ . ）进行值的访问。</p><p><br></p><p>另外，<em>for-in</em> 循环也很适合在对象中循环。可以使用中括号（ [ ] ）访问其键对应的值。但是不能使用 <em>for-of</em> 循环，因为对象是不可迭代的。</p><p><br></p><p>对象的属性可以用 <em>delete</em> 关键字来删除。</p><p><br></p><p>好的，我们已经快速讨论了有关对象的一些事项：</p><ul><li><p>如何添加属性</p></li><li><p>如何遍历对象</p></li><li><p>如何删除属性</p></li></ul><p>关于对象的讨论暂时就到这儿。</p><h2><em>Map</em></h2><p><em>Map</em> 是 <em>JavaScript</em> 中新的集合对象，其功能类似于对象。但是，与常规对象相比，存在一些主要差异。</p><p><br></p><p>首先，让我们看一个创建 <em>Map</em> 对象的简单示例。</p><h3>添加属性</h3><p>首先，通过 <em>Map</em> 构造函数，我们可以创建一个 <em>Map</em> 实例对象出来，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const map = new Map();\n// Map(0) {}</code></pre></div><p><em>Map</em> 有一种特殊的方法可在其中添加称为 <em>set</em> 的属性。它有两个参数：键是第一个参数，值是第二个参数。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">map.set('name', 'john');\n// Map(1) {\"name\" =&gt; \"john\"}</code></pre></div><p>但是，它不允许你在其中添加现有数据。如果 <em>Map</em> 对象中已经存在与新数据的键对应的值，则不会添加新数据。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">map.set('phone', 'iPhone');\n// Map(2) {\"name\" =&gt; \"john\", \"phone\" =&gt; \"iPhone\"}\nmap.set('phone', 'iPhone');\n// Map(2) {\"name\" =&gt; \"john\", \"phone\" =&gt; \"iPhone\"}</code></pre></div><p>但是可以用其他值覆盖现有数据。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">map.set('phone', 'Galaxy');\n// Map(2) {\"name\" =&gt; \"john\", \"phone\" =&gt; \"Galaxy\"}</code></pre></div><p>二维数组和 <em>Map</em> 对象之间可以很方便的相互转换。例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var arr = [\n    [1, 2],\n    [3, 4],\n    [5, 6],\n];\n\nvar map = new Map(arr);\nconsole.log(map); //Map { 1 =&gt; 2, 3 =&gt; 4, 5 =&gt; 6 }\nconsole.log(Array.from(map)); //[ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ] ]</code></pre></div><h3>获取属性和长度</h3><p>可以通过 <em>get</em> 方法或者 <em>Map</em> 对象某一条属性的值：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const map = new Map();\nmap.set('name', 'john');\nmap.set('phone', 'iPhone');\nconsole.log(map.get('phone')); // iPhone</code></pre></div><p>可以通过 <em>has</em> 方法来查询是否具有某一条属性：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const map = new Map();\nmap.set('name', 'john');\nmap.set('phone', 'iPhone');\nconsole.log(map.has('phone')); // true</code></pre></div><p>可以通过 <em>size</em> 属性获取 <em>Map</em> 对象的长度：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const map = new Map();\nmap.set('name', 'john');\nmap.set('phone', 'iPhone');\nconsole.log(map.size); // 2</code></pre></div><h3>遍历 <em>Map</em> 对象</h3><p><em>Map</em> 是一个可迭代的对象，这意味着可以使用 <em>for-of</em> 语句将其映射。</p><p><br></p><p><em>Map</em> 以数组形式提供数据，要获取键或值则需要解构数组或以索引的方式来进行访问。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">for (const item of map) {\n  console.dir(item);\n}\n// Array(2) [\"name\", \"john\"]\n// Array(2) [\"phone\", \"Galaxy\"]</code></pre></div><p>要仅获取键或值，还有一些方法可供使用。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">map.keys();\n// MapIterator {\"name\", \"phone\"}\nmap.values();\n// MapIterator {\"john\", \"Galaxy\"}\nmap.entries();\n// MapIterator {\"name\" =&gt; \"john\", \"phone\" =&gt; \"Galaxy\"}</code></pre></div><p>也可以使用 <em>forEach</em> 方法，例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const map = new Map();\nmap.set('name', 'john');\nmap.set('phone', 'iPhone');\nmap.forEach(item=&gt;{\n    console.log(item);\n})\n// john\n// iPhone</code></pre></div><p>可以使用展开操作符(  ...  )来获取 <em>Map</em> 的全部数据，因为展开操作符还可以在幕后与可迭代对象一起工作。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const simpleSpreadedMap = [...map];\n// [Array(2), Array(2)]</code></pre></div><h3>删除属性</h3><p>从 <em>Map</em> 对象中删除数据也很容易，你所需要做的就是调用 <em>delete</em>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">map.delete('phone');\n// true\nmap.delete('fake');\n// false</code></pre></div><p><em>delete</em> 返回布尔值，该布尔值指示 <em>delete</em> 函数是否成功删除了数据。如果是，则返回 <em>true</em>，否则返回 <em>false</em>。</p><p><br></p><p>如果要清空整个 <em>Map</em> 对象，可以使用 <em>clear</em> 方法，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const map = new Map();\nmap.set('name', 'john');\nmap.set('phone', 'iPhone');\nconsole.log(map); // Map(2) { 'name' =&gt; 'john', 'phone' =&gt; 'iPhone' }\nmap.clear();\nconsole.log(map); // Map(0) {}</code></pre></div><h3><em>Map</em> 和 <em>Object</em> 的区别</h3><p>关于 <em>Map</em> 和 <em>Object</em> 的区别，可以参阅下表：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-30-103632.png\" alt=\"image-20210930183632548\" contenteditable=\"false\"><br></p><h2><em>WeakMap</em></h2><p><em>WeakMap</em> 起源于 <em>Map</em>，因此它们彼此非常相似。但是，<em>WeakMap</em> 具有很大的不同。</p><p><br></p><p><em>WeakMap</em> 的名字是怎么来的呢？</p><p><br></p><p>嗯，是因为它与它的引用链接所指向的数据对象的连接或关系没有 <em>Map</em> 的连接或关系那么强，所以它是弱的。</p><p><br></p><p>那么，这到底是什么意思呢？</p><p><br></p><p><strong>差异 <em>1</em>：<em>key</em> 必须是对象</strong></p><p><br></p><p>可以将任何值作为键传入 <em>Map</em> 对象，但 <em>WeakMap</em> 不同，它只接受一个对象作为键，否则，它将返回一个错误。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const John = { name: 'John' };\nconst weakMap = new WeakMap();\nweakMap.set(John, 'student');\n// WeakMap {{...} =&gt; \"student\"}\nweakMap.set('john', 'student');\n// Uncaught TypeError: Invalid value used as weak map key</code></pre></div><p><strong>差异 <em>2</em>：并非 <em>Map</em> 中的所有方法都支持</strong></p><p><br></p><p><em>WeakMap</em> 可以使用的方法如下：</p><ul><li><p><em>delete</em></p></li><li><p><em>get</em></p></li><li><p><em>has</em></p></li><li><p><em>set</em></p></li></ul><p>还有一个最大的不同是 <em>WeakMap</em> 不支持迭代对象的方法。</p><p><br></p><p><strong>差异 <em>3</em>：当 <em>GC</em> 清理引用时，数据会被删除</strong></p><p><br></p><p>这是和 <em>Map</em> 相比最大的不同。</p><p><br></p><p>例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">let John = { major: \"math\" };\n\nconst map = new Map();\nconst weakMap = new WeakMap();\n\nmap.set(John, 'John');\nweakMap.set(John, 'John');\n\nJohn = null;\n/* John 被垃圾收集 */</code></pre></div><p>当 <em>John</em> 对象被垃圾回收时，<em>Map</em> 对象将保持引用链接，而 <em>WeakMap</em> 对象将丢失链接。</p><p><br></p><p>所以当你使用 <em>WeakMap</em> 时，你应该考虑这个特点。</p><h2><em>Set</em></h2><p><em>Set</em> 也非常类似于 <em>Map</em>，但是 <em>Set</em> 对于单个值更有用。</p><h3>添加属性</h3><p>使用 <em>add</em> 方法可以添加属性。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const set = new Set();\n\nset.add(1);\nset.add('john');\nset.add(BigInt(10));\n// Set(4) {1, \"john\", 10n}</code></pre></div><p>与 <em>Map</em> 一样，<em>Set</em> 也不允许添加相同的值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">set.add(5);\n// Set(1) {5}\n\nset.add(5);\n// Set(1) {5}</code></pre></div><p>对于原始数据类型（<em>boolean、number、string、null、undefined</em>），如果储存相同值则只保存一个，对于引用类型,引用地址完全相同则只会存一个。</p><ul><li><p><em>+0</em> 与 <em>-0</em> 在存储判断唯一性的时候是恒等的，所以不可以重复。</p></li><li><p><em>undefined</em> 和 <em>undefined</em> 是恒等的，所以不可以重复。</p></li><li><p><em>NaN</em> 与 <em>NaN</em> 是不恒等的，但是在 <em>Set</em> 中只能存一个不能重复。</p></li></ul><h3>遍历对象</h3><p>由于 <em>Set</em> 是一个可迭代的对象，因此可以使用 <em>for-of</em> 或 <em>forEach</em> 语句。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">for (const val of set) {\n  console.dir(val);\n}\n// 1\n// 'John'\n// 10n\n// 5\n\nset.forEach(val =&gt; console.dir(val));\n// 1\n// 'John'\n// 10n\n// 5</code></pre></div><h3>删除属性</h3><p>这一部分和 <em>Map</em> 的删除完全一样。如果数据被成功删除，它返回 <em>true</em>，否则返回 <em>false</em>。</p><p><br></p><p>当然也可以使用 clear 方法清空 <em>Set</em> 集合。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">set.delete(5); \n// true\nset.delete(function(){});\n// false;\n\nset.clear();</code></pre></div><p>如果你不想将相同的值添加到数组表单中，则 <em>Set</em> 可能会非常有用。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">/* With Set */\nconst set = new Set();\nset.add(1);\nset.add(2);\nset.add(2);\nset.add(3);\nset.add(3);\n// Set {1, 2, 3}\n\n// Converting to Array\nconst arr = [ ...set ];\n// [1, 2, 3]\n\nObject.prototype.toString.call(arr);\n// [object Array]\n\n/* Without Set */\nconst hasSameVal = val =&gt; ar.some(v === val);\nconst ar = [];\n\nif (!hasSameVal(1)) ar.push(1);\nif (!hasSameVal(2)) ar.push(2);\nif (!hasSameVal(3)) ar.push(3);</code></pre></div><h3>应用场景</h3><p>接下来来看一下 <em>Set</em> 常见的应用场景：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">//数组去重\n...new Set([1,1,2,2,3])\n\n//并集\nvar arr1 = [1, 2, 3]\nvar arr2 = [2, 3, 4]\nvar newArr = [...new Set([...arr1, ...arr2])]\n//交集\nvar arr1 = [1, 2, 3]\nvar arr2 = [2, 3, 4]\nvar set1 = new Set(arr1)\nvar set2 = new Set(arr2)\nvar newArr = []\nset1.forEach(item =&gt; {\n    set2.has(item) ? newArr.push(item) : ''\n})\nconsole.log(newArr)\n//差集\nvar arr1 = [1, 2, 3]\nvar arr2 = [2, 3, 4]\nvar set1 = new Set(arr1)\nvar set2 = new Set(arr2)\nvar newArr = []\nset1.forEach(item =&gt; {\n    set2.has(item) ? '' : newArr.push(item)\n})\nset2.forEach(item =&gt; {\n    set1.has(item) ? '' : newArr.push(item)\n})\nconsole.log(newArr)</code></pre></div><h2><em>WeakSet</em></h2><p><em>WeakSet</em> 和 <em>Set</em> 区别如下：</p><ul><li><p><em>WeakSet</em> 只能储存对象引用，不能存放值，而 <em>Set</em> 对象都可以</p></li><li><p><em>WeakSet</em> 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 <em>WeakSet</em> 对该对象的引用，如果没有其他的变量或者属性引用这个对象值，则这个对象将会被垃圾回收掉。（不考虑该对象还存在与 <em>WeakSet</em> 中），所以 <em>WeakSet</em> 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到，被垃圾回收了。因此 <em>ES6</em> 规定，<em>WeakSet</em> 对象是无法被遍历的，也没有办法拿到它包含的所有元素。</p></li></ul><p><em>WeakSet</em> 能够使用的方法如下：</p><ul><li><p><em>add(value)</em> 方法：在 <em>WeakSet</em> 中添加一个元素。如果添加的元素已存在，则不会进行操作。</p></li><li><p><em>delete(value)</em> 方法：删除元素 <em>value</em></p></li><li><p><em>has(value)</em> 方法：判断 <em>WeakSet</em> 对象中是否包含 <em>value</em></p></li><li><p><em>clear( )</em> 方法：清空所有元素</p></li></ul><p>下面来看一下 <em>WeakSet</em> 的代码示例，与 <em>WeakMap</em> 一样，<em>WeakSet</em> 也将丢失对内部数据的访问链接（如果内部数据已被垃圾收集）。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">let John = { major: \"math\" };\n\nconst set = new Set();\nconst weakSet = new WeakSet();\n\nset.add(John);\n// Set {{...}}\nweakSet.add(John);\n// WeakSet {{...}}\n\nJohn = null;\n/* John 被垃圾收集 */</code></pre></div><p>一旦对象 <em>John</em> 被垃圾回收，<em>WeakSet</em> 就无法访问其引用 <em>John</em> 的数据。而且 <em>WeakSet</em> 不支持 <em>for-of</em> 或 <em>forEach</em>，因为它不可迭代。</p><h2>比较总结</h2><ul><li><p><em>Map</em></p><ul><li><p>键名唯一不可重复</p></li><li><p>类似于集合，键值对的集合，任何值都可以作为一个键或者一个值</p></li><li><p>可以遍历，可以转换各种数据格式，方法 <em>get、set、has、delete</em></p></li></ul></li><li><p><em>WeakMap</em></p><ul><li><p>只接受对象为键名，不接受其他类型的值作为键名，键值可以是任意</p></li><li><p>键名是拖引用，键名所指向的对象，会被垃圾回收机制回收</p></li><li><p>不能遍历，方法 <em>get、set、has、delete</em></p></li></ul></li><li><p><em>Set</em></p><ul><li><p>成员唯一，无序且不会重复</p></li><li><p>类似于数组集合，键值和键名是一致的（只有键值。没有键名）</p></li><li><p>可以遍历，方法有 <em>add、delete、has</em></p></li></ul></li><li><p><em>WeakSet</em></p><ul><li><p>只能存储对应引用，不能存放值</p></li><li><p>成员都是弱引用，会被垃圾回收机制回收</p></li><li><p>不能遍历，方法有 <em>add、delete、has</em></p></li></ul></li></ul><h2>真题解答</h2><ul><li><p>是否了解 <em>WeakMap、WeakSet</em>（美团 <em>19</em> 年）</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p><em>WeakSet</em> 对象是一些对象值的集合, 并且其中的每个对象值都只能出现一次。在 <em>WeakSet</em> 的集合中是唯一的</p><p><br></p><p>它和 <em>Set</em> 对象的区别有两点:</p><ul><li><p>与 <em>Set</em> 相比，<em>WeakSet</em> 只能是<strong>对象的集合</strong>，而不能是任何类型的任意值。</p></li><li><p><em>WeakSet</em> 持弱引用：集合中对象的引用为弱引用。 如果没有其他的对 <em>WeakSet</em> 中对象的引用，那么这些对象会被当成垃圾回收掉。 这也意味着 <em>WeakSet</em> 中没有存储当前对象的列表。 正因为这样，<em>WeakSet</em> 是不可枚举的。</p></li></ul><p><em>WeakMap</em> 对象也是键值对的集合。它的<strong>键必须是对象类型</strong>，值可以是任意类型。它的键被弱保持，也就是说，当其键所指对象没有其他地方引用的时候，它会被 <em>GC</em> 回收掉。<em>WeakMap</em> 提供的接口与 <em>Map</em> 相同。</p><p><br></p><p>与 <em>Map</em> 对象不同的是，<em>WeakMap</em> 的键是不可枚举的。不提供列出其键的方法。列表是否存在取决于垃圾回收器的状态，是不可预知的。</p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666077912853",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e55042fac4881713db3c6"
  },
  "interviewTitle": "深拷贝和浅拷贝的区别？如何实现 ？",
  "interviewContent": "<h1>深浅拷贝</h1><h2>经典真题</h2><ul><li><p>深拷贝和浅拷贝的区别？如何实现</p></li></ul><h2>深拷贝和浅拷贝概念</h2><p>首先，我们需要明确深拷贝和浅拷贝的概念。</p><ul><li><p><strong>浅拷贝</strong>：只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做浅拷贝(浅复制)。浅拷贝只复制指向某个对象的指针（引用地址），而不复制对象本身，新旧对象还是共享同一块内存。</p></li><li><p><strong>深拷贝</strong>：在堆中重新分配内存，并且把源对象所有属性都进行新建拷贝，以保证深拷贝的对象的引用图不包含任何原有对象或对象图上的任何对象，拷贝后的对象与原来的对象是完全隔离，互不影响。</p></li></ul><h2>浅拷贝方法</h2><p>接下来我们来看一下对象有哪些浅拷贝方法。</p><p><br></p><p><strong>1. 直接赋值</strong></p><p><br></p><p>直接赋值是最常见的一种浅拷贝方式。例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var stu = {\n    name: 'xiejie',\n    age: 18\n}\n// 直接赋值\nvar stu2 = stu;\nstu2.name = \"zhangsan\";\nconsole.log(stu); // { name: 'zhangsan', age: 18 }\nconsole.log(stu2); // { name: 'zhangsan', age: 18 }</code></pre></div><p><strong>2. <em>Object.assign</em> 方法</strong></p><p><br></p><p>我们先来看一下 <em>Object.assign</em> 方法的基本用法。</p><p><br></p><p>该方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。</p><p><br></p><p>如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var stu = {\n    name: 'xiejie'\n}\nvar stu2 = Object.assign(stu, { age: 18 }, { gender: 'male' })\nconsole.log(stu2); // { name: 'xiejie', age: 18, gender: 'male' }</code></pre></div><p>在上面的代码中，我们有一个对象 <em>stu</em>，然后使用 <em>Object.assign</em> 方法将后面两个对象的属性值分配到 <em>stu</em> 目标对象上面。</p><p><br></p><p>最终得到 <em>{ name: 'xiejie', age: 18, gender: 'male' }</em> 这个对象。</p><p><br></p><p>通过这个方法，我们就可以实现一个对象的拷贝。例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const stu = {\n    name: 'xiejie',\n    age: 18\n}\nconst stu2 = Object.assign({}, stu)\nstu2.name = 'zhangsan';\nconsole.log(stu); // { name: 'xiejie', age: 18 }\nconsole.log(stu2); // { name: 'zhangsan', age: 18 }</code></pre></div><p>在上面的代码中，我们使用 <em>Object.assign</em> 方法来对 <em>stu</em> 方法进行拷贝，并且可以看到修改拷贝后对象的值，并没有影响原来的对象，这仿佛实现了一个深拷贝。</p><p><br></p><p>然而，<em>Object.assign</em> 方法事实上是一个浅拷贝。</p><p><br></p><p>当对象的属性值对应的是一个对象时，该方法拷贝的是对象的属性的引用，而不是对象本身。</p><p><br></p><p>例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const stu = {\n    name: 'xiejie',\n    age: 18,\n    stuInfo: {\n        No: 1,\n        score: 100\n    }\n}\nconst stu2 = Object.assign({}, stu)\nstu2.name = 'zhangsan';\nstu2.stuInfo.score = 90;\nconsole.log(stu); // { name: 'xiejie', age: 18, stuInfo: { No: 1, score: 90 } }\nconsole.log(stu2); // { name: 'zhangsan', age: 18, stuInfo: { No: 1, score: 90 } }</code></pre></div><p><strong>3. <em>ES6</em> 扩展运算符</strong></p><p><br></p><p>首先我们还是来回顾一下 <em>ES6</em> 扩展运算符的基本用法。</p><p><br></p><p>ES6 扩展运算符可以将数组表达式或者 <em>string</em> 在语法层面展开，还可以在构造字面量对象时，将对象表达式按 <em>key-value</em> 的方式展开。</p><p><br></p><p>例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var arr = [1, 2, 3];\nvar arr2 = [3, 5, 8, 1, ...arr]; // 展开数组\nconsole.log(arr2); // [3, 5, 8, 1, 1, 2, 3]\n\nvar stu = {\n    name: 'xiejie',\n    age: 18\n}\nvar stu2 = { ...stu, score: 100 }; // 展开对象\nconsole.log(stu2); // { name: 'xiejie', age: 18, score: 100 }</code></pre></div><p>接下来我们来使用扩展运算符来实现对象的拷贝，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const stu = {\n    name: 'xiejie',\n    age: 18\n}\nconst stu2 = {...stu}\nstu2.name = 'zhangsan';\nconsole.log(stu); // { name: 'xiejie', age: 18 }\nconsole.log(stu2); // { name: 'zhangsan', age: 18 }</code></pre></div><p>但是和 <em>Object.assign</em> 方法一样，如果对象中某个属性对应的值为引用类型，那么直接拷贝的是引用地址。如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const stu = {\n    name: 'xiejie',\n    age: 18,\n    stuInfo: {\n        No: 1,\n        score: 100\n    }\n}\nconst stu2 = {...stu}\nstu2.name = 'zhangsan';\nstu2.stuInfo.score = 90;\nconsole.log(stu); // { name: 'xiejie', age: 18, stuInfo: { No: 1, score: 90 } }\nconsole.log(stu2); // { name: 'zhangsan', age: 18, stuInfo: { No: 1, score: 90 } }</code></pre></div><p><strong>4. 数组的 <em>slice</em> 和 <em>concat</em> 方法</strong></p><p><br></p><p>在 <em>javascript</em> 中，数组也是一种对象，所以也会涉及到深浅拷贝的问题。</p><p><br></p><p>在 <em>Array</em> 中的 <em>slice</em> 和 <em>concat</em> 方法，不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。</p><p><br></p><p>例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// concat 拷贝数组\nvar arr1 = [1, true, 'Hello'];\nvar arr2 = arr1.concat();\nconsole.log(arr1); // [ 1, true, 'Hello' ]\nconsole.log(arr2); // [ 1, true, 'Hello' ]\n\narr2[0] = 2;\nconsole.log(arr1); // [ 1, true, 'Hello' ]\nconsole.log(arr2); // [ 2, true, 'Hello' ]</code></pre></div><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// slice 拷贝数组\nvar arr1 = [1, true, 'Hello'];\nvar arr2 = arr1.slice();\nconsole.log(arr1); // [ 1, true, 'Hello' ]\nconsole.log(arr2); // [ 1, true, 'Hello' ]\n\narr2[0] = 2;\nconsole.log(arr1); // [ 1, true, 'Hello' ]\nconsole.log(arr2); // [ 2, true, 'Hello' ]</code></pre></div><p>但是，这两个方法仍然是浅拷贝。如果一旦涉及到数组里面的元素是引用类型，那么这两个方法是直接拷贝的引用地址。如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// concat 拷贝数组\nvar arr1 = [1, true, 'Hello', { name: 'xiejie', age: 18 }];\nvar arr2 = arr1.concat();\nconsole.log(arr1); // [ 1, true, 'Hello', { name: 'xiejie', age: 18 } ]\nconsole.log(arr2); // [ 1, true, 'Hello', { name: 'xiejie', age: 18 } ]\n\narr2[0] = 2;\narr2[3].age = 19;\nconsole.log(arr1); // [ 1, true, 'Hello', { name: 'xiejie', age: 19 } ]\nconsole.log(arr2); // [ 2, true, 'Hello', { name: 'xiejie', age: 19 } ]</code></pre></div><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// concat 拷贝数组\nvar arr1 = [1, true, 'Hello', { name: 'xiejie', age: 18 }];\nvar arr2 = arr1.slice();\nconsole.log(arr1); // [ 1, true, 'Hello', { name: 'xiejie', age: 18 } ]\nconsole.log(arr2); // [ 1, true, 'Hello', { name: 'xiejie', age: 18 } ]\n\narr2[0] = 2;\narr2[3].age = 19;\nconsole.log(arr1); // [ 1, true, 'Hello', { name: 'xiejie', age: 19 } ]\nconsole.log(arr2); // [ 2, true, 'Hello', { name: 'xiejie', age: 19 } ]</code></pre></div><p><strong>5.  <em>jQuery</em> 中的 <em>$.extend</em></strong></p><p><br></p><p>在 <em>jQuery</em> 中，<em>$.extend(deep,target,object1,objectN)</em> 方法可以进行深浅拷贝。各参数说明如下：</p><ul><li><p><em>deep</em>：如过设为 <em>true</em> 为深拷贝，默认是 <em>false</em> 浅拷贝</p></li><li><p><em>target</em>：要拷贝的目标对象</p></li><li><p><em>object1</em>：待拷贝到第一个对象的对象</p></li><li><p><em>objectN</em>：待拷贝到第N个对象的对象</p></li></ul><p>来看一个具体的示例：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">&lt;body&gt;\n    &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n        const obj = {\n            name: 'wade',\n            age: 37,\n            friend: {\n                name: 'james',\n                age: 34\n            }\n        }\n        const cloneObj = {};\n        // deep 默认为 false 为浅拷贝\n        $.extend(cloneObj, obj);\n        obj.friend.name = 'rose';\n        console.log(obj);\n        console.log(cloneObj);\n    &lt;/script&gt;\n&lt;/body&gt;</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-31-053219.png\" alt=\"image-20210831133219541\" contenteditable=\"false\"><br></p><h2>深拷贝方法</h2><p>说完了浅拷贝，接下来我们来看如何实现深拷贝。</p><p><br></p><p>总结一下，大致有如下的方式。</p><p><br></p><p><strong>1. <em>JSON.parse(JSON.stringify)</em></strong></p><p><br></p><p>这是一个广为流传的深拷贝方式，用 <em>JSON.stringify</em> 将对象转成 <em>JSON</em> 字符串，再用 <em>JSON.parse</em> 方法把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。</p><p><br></p><p>示例如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const stu = {\n    name: 'xiejie',\n    age: 18,\n    stuInfo: {\n        No: 1,\n        score: 100\n    }\n}\nconst stu2 = JSON.parse(JSON.stringify(stu));\nstu2.name = 'zhangsan';\nstu2.stuInfo.score = 90;\nconsole.log(stu); // { name: 'xiejie', age: 18, stuInfo: { No: 1, score: 100 } }\nconsole.log(stu2); // { name: 'zhangsan', age: 18, stuInfo: { No: 1, score: 90 } }</code></pre></div><p>这种方式看似能够解决问题，但是这种方法也有一个缺点，那就是不能处理函数。</p><p><br></p><p>这是因为 <em>JSON.stringify</em> 方法是将一个 <em>javascript</em> 值（对象或者数组）转换为一个 <em>JSON</em> 字符串，而 <em>JSON</em> 字符串是不能够接受函数的。同样，正则对象也一样，在 <em>JSON.parse</em> 解析时会发生错误。</p><p><br></p><p>例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const stu = {\n    name: 'xiejie',\n    age: 18,\n    stuInfo: {\n        No: 1,\n        score: 100,\n        saySth: function () {\n            console.log('我是一个学生');\n        }\n    }\n}\nconst stu2 = JSON.parse(JSON.stringify(stu));\nstu2.name = 'zhangsan';\nstu2.stuInfo.score = 90;\nconsole.log(stu); // { name: 'xiejie', age: 18, stuInfo: { No: 1, score: 100, saySth: [Function: saySth] }}\nconsole.log(stu2); // { name: 'zhangsan', age: 18, stuInfo: { No: 1, score: 90 } }</code></pre></div><p>可以看到，在原对象中有方法，拷贝之后，新对象中没有方法了。</p><p><br></p><p><strong>2. <em>$.extend(deep,target,object1,objectN)</em></strong></p><p><br></p><p>前面在介绍浅拷贝时提到了 <em>jQuery</em> 的这个方法，该方法既能实现浅拷贝，也能实现深拷贝。要实现深拷贝，只需要将第一个参数设置为 <em>true</em> 即可。例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">&lt;body&gt;\n    &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n        const obj = {\n            name: 'wade',\n            age: 37,\n            friend: {\n                name: 'james',\n                age: 34\n            }\n        }\n        const cloneObj = {};\n        // deep 设为 true 为深拷贝\n        $.extend(true, cloneObj, obj);\n        obj.friend.name = 'rose';\n        console.log(obj);\n        console.log(cloneObj);\n    &lt;/script&gt;\n&lt;/body&gt;</code></pre></div><p>效果：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-31-054115.png\" alt=\"image-20210831134114926\" contenteditable=\"false\"><br></p><p><br></p><p><strong>3. 手写递归方法</strong></p><p><br></p><p>最终，还是只有靠我们自己手写递归方法来实现深拷贝。</p><p><br></p><p>示例如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function deepClone(target) {\n    var result;\n    // 判断是否是对象类型\n    if (typeof target === 'object') {\n        // 判断是否是数组类型\n        if (Array.isArray(target)) {\n            result = []; // 如果是数组,创建一个空数组\n            // 遍历数组的键\n            for (var i in target) {\n                // 递归调用\n                result.push(deepClone(target[i]))\n            }\n        } else if (target === null) {\n            // 再判断是否是 null\n            // 如果是，直接等于 null\n            result = null;\n        } else if (target.constructor === RegExp) {\n            // 判断是否是正则对象\n            // 如果是,直接赋值拷贝\n            result = target;\n        } else if (target.constructor === Date) {\n            // 判断是否是日期对象\n            // 如果是,直接赋值拷贝\n            result = target;\n        } else {\n            // 则是对象\n            // 创建一个空对象\n            result = {};\n            // 遍历该对象的每一个键\n            for (var i in target) {\n                // 递归调用\n                result[i] = deepClone(target[i]);\n            }\n        }\n    } else {\n        // 表示不是对象类型，则是简单数据类型  直接赋值\n        result = target;\n    }\n    // 返回结果\n    return result;\n}</code></pre></div><p>在上面的代码中，我们封装了一个名为 <em>deepClone</em> 的方法，在该方法中，通过递归调用的形式来深度拷贝一个对象。</p><p><br></p><p>下面是 <em>2</em> 段测试代码：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// 测试1\nconst stu = {\n    name: 'xiejie',\n    age: 18,\n    stuInfo: {\n        No: 1,\n        score: 100,\n        saySth: function () {\n            console.log('我是一个学生');\n        }\n    }\n}\nconst stu2 = deepClone(stu)\nstu2.name = 'zhangsan';\nstu2.stuInfo.score = 90;\nconsole.log(stu); // { name: 'xiejie', age: 18, stuInfo: { No: 1, score: 100, saySth: [Function: saySth] }}\nconsole.log(stu2); // { name: 'xiejie', age: 18, stuInfo: { No: 1, score: 90, saySth: [Function: saySth] }}</code></pre></div><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// 测试2\nvar arr1 = [1, true, 'Hello', { name: 'xiejie', age: 18 }];\nvar arr2 = deepClone(arr1)\nconsole.log(arr1); // [ 1, true, 'Hello', { name: 'xiejie', age: 18 } ]\nconsole.log(arr2); // [ 1, true, 'Hello', { name: 'xiejie', age: 18 } ]\n\narr2[0] = 2;\narr2[3].age = 19;\nconsole.log(arr1); // [ 1, true, 'Hello', { name: 'xiejie', age: 18 } ]\nconsole.log(arr2); // [ 2, true, 'Hello', { name: 'xiejie', age: 19 } ]</code></pre></div><h2>真题解答</h2><ul><li><p>深拷贝和浅拷贝的区别？如何实现</p></li></ul><blockquote><p>参考答案：</p><ul><li><p><strong>浅拷贝</strong>：只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做浅拷贝（浅复制）</p><p><br></p><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</p></li><li><p><strong>深拷贝</strong>：在堆中重新分配内存，并且把源对象所有属性都进行新建拷贝，以保证深拷贝的对象的引用图不包含任何原有对象或对象图上的任何对象，拷贝后的对象与原来的对象是完全隔离，互不影响。</p></li></ul><p><strong>浅拷贝方法</strong></p><ol><li><p>直接赋值</p></li><li><p><em>Object.assign</em> 方法：可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。当拷贝的 <em>object</em> 只有一层的时候，是深拷贝，但是当拷贝的对象属性值又是一个引用时，换句话说有多层时，就是一个浅拷贝。</p></li><li><p><em>ES6</em> 扩展运算符，当 <em>object</em> 只有一层的时候，也是深拷贝。有多层时是浅拷贝。</p></li><li><p><em>Array.prototype.concat</em> 方法</p></li><li><p><em>Array.prototype.slice</em> 方法</p></li><li><p><em>jQuery</em> 中的 <em>$.extend</em>：在 <em>jQuery</em> 中，<em>$.extend(deep,target,object1,objectN)</em> 方法可以进行深浅拷贝。<em>deep</em> 如过设为 <em>true</em> 为深拷贝，默认是 <em>false</em> 浅拷贝。</p></li></ol><p><strong>深拷贝方法</strong></p><ol><li><p><em>$.extend(deep,target,object1,objectN)</em>，将 <em>deep</em> 设置为 <em>true</em></p></li><li><p><em>JSON.parse(JSON.stringify)</em>：用 <em>JSON.stringify</em> 将对象转成 <em>JSON</em> 字符串，再用 <em>JSON.parse</em> 方法把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。</p></li><li><p>手写递归</p></li></ol><p>示例代码如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function deepCopy(oldObj, newobj) {\n    for (var key in oldObj) {\n        var item = oldObj[key];\n        // 判断是否是对象\n        if (item instanceof Object) {\n            if (item instanceof Function) {\n                newobj[key] = oldObj[key];\n            } else {\n                newobj[key] = {};  //定义一个空的对象来接收拷贝的内容\n                deepCopy(item, newobj[key]); //递归调用\n            }\n\n            // 判断是否是数组\n        } else if (item instanceof Array) {\n            newobj[key] = [];  //定义一个空的数组来接收拷贝的内容\n            deepCopy(item, newobj[key]); //递归调用\n        } else {\n            newobj[key] = oldObj[key];\n        }\n    }\n}</code></pre></div></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666077956733",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e55352fac4881713db3ca"
  },
  "interviewTitle": "什么是函数柯里化？",
  "interviewContent": "<h1>函数柯里化</h1><h2>经典真题</h2><ul><li><p>什么是函数柯里化？</p></li></ul><h2>什么是函数柯里化</h2><p>在计算机科学中，柯里化（英语：<em>Currying</em>），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p><p><br></p><p>这个技术由克里斯托弗·斯特雷奇以逻辑学家哈斯凯尔·加里命名的，尽管它是 <em>Moses Schönfinkel</em> 和戈特洛布·弗雷格发明的。</p><p><br></p><p>在直觉上，柯里化声称如果你固定某些参数，你将得到接受余下参数的一个函数。</p><p><br></p><p>我们姑且叫它返回函数，在调用返回函数的时候，它将判断当前的参数和之前被柯里化函数固定的参数拼起来之后，是否达到了原本函数的参数个数。</p><p><br></p><p>如果是，则执行原本的函数，得到结果；如果没有达到，则要继续调用柯里化函数来固定目前的参数。</p><p><br></p><p>在理论计算机科学中，柯里化提供了在简单的理论模型中，比如：只接受一个单一参数的 <em>lambda</em> 演算中，研究带有多个参数的函数的方式。</p><p><br></p><p>函数柯里化的对偶是<em>Uncurrying</em>，一种使用匿名单参数函数来实现多参数函数的方法。</p><h2>柯里化快速入门</h2><p>接下来，我们来通过一个简单的示例，让大家快速体会函数柯里化。</p><p><br></p><p>假设我们有一个求取两个数之和的函数：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function add(x, y) {\n    return x + y;\n}\nconsole.log(add(1, 2)); // 3\nconsole.log(add(5, 7)); // 12</code></pre></div><p>在上面的示例中，我们有一个 <em>add</em> 函数，接收两个形参，返回两形参的和。</p><p><br></p><p>在调用的时候，我们每次也需要传递两个参数。</p><p><br></p><p>现在，我们对其进行柯里化，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function add(x) {\n    return function (y) {\n        return x + y;\n    }\n}\nconsole.log(add(1)(2)); // 3\nconsole.log(add(5)(7)); // 3</code></pre></div><p>在上面的代码中，我们对 <em>add</em> 函数进行了柯里化改造，只接受一个参数，但是返回的也不是值了，而是返回一个函数，这个函数也接收一个参数，然后利用闭包的特性，可以访问到最开始传入的 <em>x</em> 的值，最终返回 <em>x</em> 和 <em>y</em> 的和。</p><p><br></p><p>所以，通过上面的这个示例，我们能够体会到前面所说的柯里化函数的特点：</p><p><br></p><p>一个柯里化的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。</p><h2>函数柯里化实际应用</h2><p>通过上面的例子，我们体验到了什么是柯里化函数。</p><p><br></p><p>但是问题来了，费这么大劲封装一层，到底有什么用处呢？</p><p><br></p><p>没有好处想让我们程序员多干事情是不可能滴，这辈子都不可能。</p><p><br></p><p>所以接下来我们就来看一下函数柯里化的一个实际应用。</p><p><br></p><p><strong>参数复用</strong></p><p><br></p><p>就是将相同的参数固定下来。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// 正常正则验证字符串 reg.test(txt)\n\n// 函数封装后\nfunction check(reg, txt) {\n    return reg.test(txt)\n}\n\n// 即使是相同的正则表达式，也需要重新传递一次\nconsole.log(check(/\\d+/g, 'test1')); // true\nconsole.log(check(/\\d+/g, 'testtest')); // false\nconsole.log(check(/[a-z]+/g, 'test')); // true\n\n// Currying后\nfunction curryingCheck(reg) {\n    return function (txt) {\n        return reg.test(txt)\n    }\n}\n\n// 正则表达式通过闭包保存了起来\nvar hasNumber = curryingCheck(/\\d+/g)\nvar hasLetter = curryingCheck(/[a-z]+/g)\n\nconsole.log(hasNumber('test1')); // true\nconsole.log(hasNumber('testtest'));  // false\nconsole.log(hasLetter('21212')); // false</code></pre></div><p>上面的示例是一个正则的校验，正常来说直接调用 <em>check</em> 函数就可以了，但是如果我有很多地方都要校验是否有数字，其实就是需要将第一个参数 <em>reg</em> 进行复用，这样别的地方就能够直接调用 <em>hasNumber、hasLetter</em> 等函数，让参数能够复用，调用起来也更方便。</p><p><br></p><p><strong>提前确认</strong></p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">/**\n * \n * @param {要绑定事件的 DOM 元素} element \n * @param {绑定什么事件} event \n * @param {事件处理函数} handler \n */\nvar on = function (element, event, handler) {\n    if (document.addEventListener) {\n        if (element &amp;&amp; event &amp;&amp; handler) {\n            element.addEventListener(event, handler, false);\n        }\n    } else {\n        if (element &amp;&amp; event &amp;&amp; handler) {\n            element.attachEvent('on' + event, handler);\n        }\n    }\n}\n\non(div, 'click', function(){})\n\n\nvar on = (function () {\n    if (document.addEventListener) {\n        return function (element, event, handler) {\n            if (element &amp;&amp; event &amp;&amp; handler) {\n                element.addEventListener(event, handler, false);\n            }\n        };\n    } else {\n        return function (element, event, handler) {\n            if (element &amp;&amp; event &amp;&amp; handler) {\n                element.attachEvent('on' + event, handler);\n            }\n        };\n    }\n})();\n\non(div, 'click', function(){})\n\n//换一种写法可能比较好理解一点，上面就是把 isSupport 这个参数给先确定下来了\nvar on = function (isSupport, element, event, handler) {\n    isSupport = isSupport || document.addEventListener;\n    if (isSupport) {\n        return element.addEventListener(event, handler, false);\n    } else {\n        return element.attachEvent('on' + event, handler);\n    }\n}\non(true, div, 'click', function(){})\non(true, div, 'click', function(){})\non(true, div, 'click', function(){})</code></pre></div><p>我们在做项目的过程中，封装一些 <em>DOM</em> 操作可以说再常见不过，上面第一种写法也是比较常见，但是我们看看第二种写法，它相对于第一种写法就是自执行然后返回一个新的函数，这样其实就是提前确定了会走哪一个方法，避免每次都进行判断。</p><h2>封装通用柯里化函数</h2><p>接下来我们来封装一个通用的柯里化函数。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function curry() {\n    var fn = arguments[0]; // 获取要执行的函数\n    var args = [].slice.call(arguments, 1); // 获取传递的参数，构成一个参数数组\n    // 如果传递的参数已经等于执行函数所需的参数数量\n    if (args.length === fn.length) {\n        return fn.apply(this, args)\n    }\n    // 参数不够向外界返回的函数\n    function _curry(){\n        // 推入之前判断\n        // 将新接收到的参数推入到参数数组中\n        args.push(...arguments);\n        if(args.length === fn.length){\n            return fn.apply(this, args)\n        }\n        return _curry;\n    }\n    return _curry;\n}</code></pre></div><p>对上面的代码进行测试：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// 测试 1\nfunction add(a, b, c) {\n    return a + b + c;\n}\n\nconsole.log(curry(add)(1)(2)(3)); // 6\nconsole.log(curry(add, 1)(2)(3)); // 6\nconsole.log(curry(add, 1, 2, 3)); // 6\nconsole.log(curry(add, 1)(3, 4)); // 8\n\nvar addCurrying = curry(add)(2);\nconsole.log(addCurrying(7)(8)); // 17\n\n// 测试 2\nfunction check(reg, txt) {\n    return reg.test(txt)\n}\nvar hasNumber = curry(check)(/\\d+/g);\nconsole.log(hasNumber('test1'));// true</code></pre></div><h2>一道经典的柯里化面试题</h2><p>实现一个 <em>add</em> 方法，使计算结果能够满足如下预期：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">add(1)(2)(3) = 6;\nadd(1, 2, 3)(4) = 10;\nadd(1)(2)(3)(4)(5) = 15;</code></pre></div><p>要完成上面的需求，我们就可以使用柯里化函数：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function add() {\n    // 第一次执行时，定义一个数组专门用来存储所有的参数\n    var _args = Array.prototype.slice.call(arguments);\n\n    // 在内部声明一个函数，利用闭包的特性保存 _args 并收集所有的参数值\n    var _adder = function () {\n        _args.push(...arguments);\n        return _adder;\n    };\n\n    // 这个是最后输出的时候被调用的，return 后面如果是函数体，\n    // 为了输出函数体字符串会自动调用 toString 方法\n    // 利用 toString 隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回\n    _adder.toString = function () {\n        return _args.reduce(function (a, b) {\n            return a + b;\n        });\n    }\n\n    // 这个 return 是第一次调用的时候返回上面的函数体，\n    // 这样后面所有的括号再执行的时候就是执行 _adder 函数体\n    return _adder;\n}\nconsole.log(add(1)(2)(3).toString()); // 6\nconsole.log(add(1, 2, 3)(4).toString()); // 10\nconsole.log(add(1)(2)(3)(4)(5).toString()); // 15\nconsole.log(add(2, 6)(1).toString()); // 9</code></pre></div><h2>真题详解</h2><ul><li><p>什么是函数柯里化？</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p>柯里化（<em>currying</em>）又称部分求值。一个柯里化的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。</p><p><br></p><p>举个例子，就是把原本：</p><p><br></p><p><em>function(arg1,arg2)</em> 变成 <em>function(arg1)(arg2)</em></p><p><em>function(arg1,arg2,arg3)</em> 变成 <em>function(arg1)(arg2)(arg3)</em></p><p><em>function(arg1,arg2,arg3,arg4)</em> 变成 <em>function(arg1)(arg2)(arg3)(arg4)</em></p><p><br></p><p>总而言之，就是将：</p><p><br></p><p><em>function(arg1,arg2,…,argn)</em> 变成 <em>function(arg1)(arg2)…(argn)</em></p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666078005854",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
},
{
  "_id": {
    "$oid": "634e556b2fac4881713db3ce"
  },
  "interviewTitle": "Node.js 中的事件循环和浏览器环境的事件循环有何不同？",
  "interviewContent": "<h1><em>Node</em> 事件循环</h1><h2>经典真题</h2><ul><li><p>请简述一下 <em>Node.js</em> 中的事件循环，和浏览器环境的事件循环有何不同？</p></li></ul><h2><em>Node.js</em> 与浏览器的事件循环有何区别？</h2><h3>进程与线程</h3><p>我们经常说 <em>JavaScript</em> 是一门单线程语言，指的是一个进程里只有一个主线程，那到底什么是线程？什么是进程？</p><p><br></p><p>首先需要把这个问题搞明白。</p><p><br></p><p>进程是 <em>CPU</em> 资源分配的最小单位，而线程是 <em>CPU</em> 调度的最小单位。举个例子，看下面的图：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-15-032136.png\" alt=\"image-20211015112136231\" contenteditable=\"false\"><br></p><ul><li><p>进程好比图中的工厂，有单独的专属自己的工厂资源。</p></li><li><p>线程好比图中的工人，多个工人在一个工厂中协作工作，工厂与工人是 <em>1:n</em> 的关系。也就是说<strong>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线</strong>。</p></li><li><p>工厂的空间是工人们共享的，这象征<strong>一个进程的内存空间是共享的，每个线程都可用这些共享内存</strong>。</p></li><li><p>多个工厂之间独立存在。</p></li></ul><p>接下来我们回过头来看多进程和多线程的概念：</p><ul><li><p>多进程：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。</p></li><li><p>多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</p></li></ul><p>以 <em>Chrome</em> 浏览器中为例，当你打开一个 <em>Tab</em> 页时，其实就是创建了一个进程。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-15-032547.png\" alt=\"image-20211015112546949\" contenteditable=\"false\"><br></p><p><br></p><p>一个进程中可以有多个线程，比如渲染线程、<em>JS</em> 引擎线程、<em>HTTP</em> 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p><h3>浏览器内核</h3><p>简单来说浏览器内核是通过取得页面内容、整理信息（应用 <em>CSS</em> ）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。</p><p><br></p><p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p><ul><li><p><em>GUI</em> 渲染线程</p></li><li><p><em>JavaScript</em> 引擎线程</p></li><li><p>定时触发器线程</p></li><li><p>事件触发线程</p></li><li><p>异步 <em>http</em> 请求线程</p></li></ul><h4><em>GUI</em> 渲染线程</h4><ul><li><p>主要负责页面的渲染，解析 <em>HTML</em>、<em>CSS</em>，构建 <em>DOM</em> 树，布局和绘制等。</p></li><li><p>当界面需要重绘或者由于某种操作引发回流时，将执行该线程。</p></li><li><p>该线程与 <em>JS</em> 引擎线程互斥，当执行 <em>JS</em> 引擎线程时，<em>GUI</em> 渲染会被挂起，当任务队列空闲时，主线程才会去执行 <em>GUI</em> 渲染。</p></li></ul><h4><em>JavaScript</em> 引擎线程</h4><ul><li><p>该线程当然是主要负责处理  <em>JavaScript</em>  脚本，执行代码。</p></li><li><p>也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 <em>JS</em> 引擎线程的执行。</p></li><li><p>当然，该线程与 <em>GUI</em> 渲染线程互斥，当 <em>JS</em> 引擎线程执行 <em>JavaScript</em> 脚本时间过长，将导致页面渲染的阻塞。</p></li></ul><h4>定时触发器线程</h4><ul><li><p>负责执行异步定时器一类的函数的线程，如：<em>setTimeout、setInterval</em>。</p></li><li><p>主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待 <em>JS</em> 引擎线程执行。</p></li></ul><h4>事件触发线程</h4><ul><li><p>主要负责将准备好的事件交给 <em>JS</em> 引擎线程执行。</p></li></ul><p>比如 <em>setTimeout</em> 定时器计数结束， <em>ajax</em> 等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 <em>JS</em> 引擎线程的执行。</p><h4>异步 <em>http</em> 请求线程</h4><ul><li><p>负责执行异步请求一类的函数的线程，如：<em>Promise、fetch、ajax</em> 等。</p></li><li><p>主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待 <em>JS</em> 引擎线程执行。</p></li></ul><h3>浏览器中的事件循环</h3><h4>宏任务和微任务</h4><p>事件循环中的异步队列有两种：宏任务（ <em>macro</em> ）队列和微任务（ <em>micro</em> ）队列。</p><p><br></p><p><strong>宏任务队列有一个，微任务队列只有一个</strong>。</p><ul><li><p>常见的宏任务有：<em>setTimeout、setInterval、requestAnimationFrame、script</em>等。</p></li><li><p>常见的微任务有：<em>new Promise( ).then(回调)、MutationObserver</em> 等。</p></li></ul><h4>事件循环流程</h4><p>一个完整的事件循环过程，可以概括为以下阶段：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-15-041213.png\" alt=\"image-20211015121213384\" contenteditable=\"false\"><br></p><ul><li><p>一开始执行栈空，我们可以把<strong>执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</strong>。微任务队列空，宏任务队列里有且只有一个 <em>script</em> 脚本（整体代码）。</p></li><li><p>全局上下文（ <em>script</em> 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的宏任务与微任务，它们会分别被推入各自的任务队列里。同步代码执行完了，<em>script</em> 脚本会被移出宏任务队列，这个过程本质上是队列的宏任务的执行和出队的过程。</p></li><li><p>上一步我们出队的是一个宏任务，这一步我们处理的是微任务。但需要注意的是：当一个宏任务执行完毕后，会执行所有的微任务，也就是将整个微任务队列清空。</p></li><li><p>执行渲染操作，更新界面</p></li><li><p>检查是否存在 <em>Web worker</em> 任务，如果有，则对其进行处理</p></li><li><p>上述过程循环往复，直到两个队列都清空</p></li></ul><p>宏任务和微任务的执行流程，总结起来就是：</p><p><br></p><p><strong>当某个宏任务执行完后，会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。</strong></p><p><br></p><p>执行流程如下图所示：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-15-034206.png\" alt=\"image-20211015114206131\" contenteditable=\"false\"><br></p><p><br></p><p>这里我们可以来看两道具体的代码题目加深理解：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">console.log('script start');\nsetTimeout(function() {\n    console.log('setTimeout');\n}, 0);\n\nPromise.resolve().then(function() {\n    console.log('promise1');\n}).then(function() {\n    console.log('promise2');\n});\n\nconsole.log('script end');</code></pre></div><p>上面的代码输出的结果为：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">script start\nscript end\npromise1\npromise2\nsetTimeout</code></pre></div><p>原因很简单，首先会执行同步的任务，输出 <em>script start</em> 以及 <em>script end</em>。接下来是处理异步任务，异步任务分为宏任务队列和微任务队列，在执行宏任务队列中的每个宏任务之前先把微任务清空一遍，由于 <em>promise</em> 是微任务，所以会先被执行，而 <em>setTimeout</em> 由于是一个宏任务，会在微任务队列被清空后再执行。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">Promise.resolve().then(()=&gt;{\n  console.log('Promise1')\n  setTimeout(()=&gt;{\n    console.log('setTimeout2')\n  },0)\n})\nsetTimeout(()=&gt;{\n  console.log('setTimeout1')\n  Promise.resolve().then(()=&gt;{\n    console.log('Promise2')\n  })\n},0)</code></pre></div><p>上面的代码输出的结果为：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">Promise1\nsetTimeout1\nPromise2\nsetTimeout2</code></pre></div><p>一开始执行栈的同步任务（这属于宏任务）执行完毕，会去查看是否有微任务队列，上题中存在（有且只有一个），然后执行微任务队列中的所有任务输出 <em>Promise1</em>，同时会生成一个宏任务 <em>setTimeout2</em>。</p><p><br></p><p>然后去查看宏任务队列，宏任务 <em>setTimeout1</em> 在 <em>setTimeout2</em> 之前，先执行宏任务 <em>setTimeout1</em>，输出 <em>setTimeout1</em>。在执行宏任务 <em>setTimeout1</em> 时会生成微任务 <em>Promise2</em> ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 <em>Promise2</em>。</p><p><br></p><p>清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 <em>setTimeout2</em>。</p><h3><em>Node.js</em> 中的事件循环</h3><h4><em>Node.js</em> 事件循环介绍</h4><p><em>Node.js</em> 中的事件循环和浏览器中的是完全不相同的东西。</p><p><br></p><p><em>Node.js</em> 采用 <em>V8</em> 作为 <em>JS</em> 的解析引擎，而 <em>I/O</em> 处理方面使用了自己设计的 <em>libuv</em>，<em>libuv</em> 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的 <em>API</em>，事件循环机制也是它里面的实现。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-15-041258.png\" alt=\"image-20211015121258759\" contenteditable=\"false\"><br></p><p><br></p><p>可以看出 <em>Node.JS</em> 的事件循环比浏览器端复杂很多。<em>Node.js</em> 的运行机制如下:</p><ul><li><p><em>V8</em> 引擎解析 <em>JavaScript</em> 脚本。</p></li><li><p>解析后的代码，调用 <em>Node API</em>。</p></li><li><p><em>libuv</em> 库负责 <em>Node API</em> 的执行。它将不同的任务分配给不同的线程，形成一个事件循环，以异步的方式将任务的执行结果返回给 <em>V8</em> 引擎。</p></li><li><p><em>V8</em> 引擎再将结果返回给用户。</p></li></ul><p>整个架构图如下所示：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-29-080543.png\" alt=\"image-20211029160543365\" contenteditable=\"false\"><br></p><h4>事件循环的 <em>6</em> 个阶段</h4><p>其中 <em>libuv</em> 引擎中的事件循环分为 <em>6</em> 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-15-054611.jpg\" alt=\"node\" contenteditable=\"false\"><br></p><p><br></p><p>从上图中，大致看出 <em>Node.js</em> 中的事件循环的顺序：</p><p><br></p><p>外部输入数据 –-&gt; 轮询阶段（ <em>poll</em> ）-–&gt; 检查阶段（ <em>check</em> ）-–&gt; 关闭事件回调阶段（ <em>close callback</em> ）–-&gt; 定时器检测阶段（ <em>timer</em> ）–-&gt; <em>I/O</em> 事件回调阶段（ <em>I/O callbacks</em> ）-–&gt;闲置阶段（ <em>idle、prepare</em> ）–-&gt;轮询阶段（按照该顺序反复运行）...</p><p><br></p><p>以上 <em>6</em> 个阶段所做的事情如下：</p><ul><li><p><em>timers</em> 阶段：这个阶段执行 <em>timer</em>（ <em>setTimeout、setInterval</em> ）的回调</p></li><li><p><em>I/O callbacks</em> 阶段：处理一些上一轮循环中的少数未执行的 <em>I/O</em> 回调</p></li><li><p><em>idle、prepare</em> 阶段：仅 <em>Node.js</em> 内部使用</p></li><li><p><em>poll</em> 阶段：获取新的 <em>I/O</em> 事件, 适当的条件下 <em>Node.js</em> 将阻塞在这里</p></li><li><p><em>check</em> 阶段：执行 <em>setImmediate( )</em> 的回调</p></li><li><p><em>close callbacks</em> 阶段：执行 <em>socket</em> 的 <em>close</em> 事件回调</p></li></ul><p>注意：<strong>上面六个阶段都不包括 <em>process.nextTick( )</em></strong></p><p><br></p><p>接下去我们详细介绍 <em>timers、poll、check</em> 这 <em>3</em> 个阶段，因为日常开发中的绝大部分异步任务都是在这 <em>3</em> 个阶段处理的。</p><p><br></p><p><strong><em>timer</em> 阶段</strong></p><p><br></p><p><em>timers</em> 阶段会执行 <em>setTimeout</em> 和 <em>setInterval</em> 回调，并且是由 <em>poll</em> 阶段控制的。同样，<strong>在 <em>Node.js</em> 中定时器指定的时间也不是准确时间，只能是尽快执行</strong>。</p><p><br></p><p><strong><em>poll</em> 阶段</strong></p><p><br></p><p><em>poll</em> 是一个至关重要的阶段，这一阶段中，系统会做两件事情：</p><ul><li><p>回到 <em>timer</em> 阶段执行回调</p></li><li><p>执行 <em>I/O</em> 回调</p></li></ul><p>并且在进入该阶段时如果没有设定了 <em>timer</em> 的话，会发生以下两件事情：</p><ul><li><p>如果 <em>poll</em> 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</p></li><li><p>如果 <em>poll</em> 队列为空时，会有两件事发生：</p><ul><li><p>如果有 <em>setImmediate</em> 回调需要执行，<em>poll</em> 阶段会停止并且进入到 <em>check</em> 阶段执行回调</p></li><li><p>如果没有 <em>setImmediate</em> 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</p></li></ul></li></ul><p>当然设定了 <em>timer</em> 的话且 <em>poll</em> 队列为空，则会判断是否有 <em>timer</em> 超时，如果有的话会回到 <em>timer</em> 阶段执行回调。</p><p><br></p><p>假设 <em>poll</em> 被堵塞，那么即使 <em>timer</em> 已经到时间了也只能等着，这也是为什么上面说定时器指定的时间并不是准确的时间。例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const start = Date.now();\nsetTimeout(function f1() {\n    console.log(\"setTimeout\", Date.now() - start);\n}, 200);\n\nconst fs = require('fs');\n\nfs.readFile('./index.js', 'utf-8', function f2() {\n    console.log('readFile');\n    const start = Date.now();\n    // 强行延时 500 毫秒\n    while (Date.now() - start &lt; 500) { }\n})</code></pre></div><p><strong><em>check</em> 阶段</strong></p><p><br></p><p><em>setImmediate( )</em> 的回调会被加入 <em>check</em> 队列中，从事件循环的阶段图可以知道，<em>check</em> 阶段的执行顺序在 <em>poll</em> 阶段之后。</p><p><br></p><p>我们先来看个例子：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">console.log('start')\nsetTimeout(() =&gt; {\n  console.log('timer1')\n  Promise.resolve().then(function() {\n    console.log('promise1')\n  })\n}, 0)\nsetTimeout(() =&gt; {\n  console.log('timer2')\n  Promise.resolve().then(function() {\n    console.log('promise2')\n  })\n}, 0)\nPromise.resolve().then(function() {\n  console.log('promise3')\n})\nconsole.log('end')\n// 输出结果：start =&gt; end =&gt; promise3 =&gt; timer1 =&gt; promise1 =&gt; timer2 =&gt; promise2</code></pre></div><p>一开始执行同步任务，依次打印出 <em>start end</em>，并将 <em>2</em> 个 <em>timer</em> 依次放入 <em>timer</em> 队列，之后会立即执行微任务队列，所以打印出 <em>promise3</em>。</p><p><br></p><p>然后进入 <em>timers</em> 阶段，执行 <em>timer1</em> 的回调函数，打印 <em>timer1</em>，发现有一个 <em>promise.then</em> 回调将其加入到微任务队列并且立即执行，之后同样的步骤执行 <em>timer2</em>，打印 <em>timer2</em> 以及 <em>promise2</em>。</p><h4>一些注意点</h4><p><strong><em>setTimeout</em> 和 <em>setImmediate</em> 区别</strong></p><p><br></p><p>二者非常相似，区别主要在于调用时机不同。</p><ul><li><p><em>setImmediate</em> 设计在 <em>poll</em> 阶段完成时执行，即 <em>check</em> 阶段</p></li><li><p><em>setTimeout</em> 设计在 <em>poll</em> 阶段为空闲时，且设定时间到达后执行，但它在 <em>timer</em> 阶段执行</p></li></ul><p>来看一个具体的示例：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">setTimeout(function timeout () {\n  console.log('timeout');\n},0);\nsetImmediate(function immediate () {\n  console.log('immediate');\n});</code></pre></div><p>对于以上代码来说，<em>setTimeout</em> 可能执行在前，也可能执行在后。首先 <em>setTimeout(fn, 0) === setTimeout(fn, 1)</em>，这是由源码决定的，进入事件循环也是需要成本的，如果在准备时候花费了大于 <em>1ms</em> 的时间，那么在 <em>timer</em> 阶段就会直接执行 <em>setTimeout</em> 回调。如果准备时间花费小于 <em>1ms</em>，那么就是 <em>setImmediate</em> 回调先执行了。</p><p><br></p><p>但当二者在异步 <em>I/O callback</em> 内部调用时，总是先执行 <em>setImmediate</em>，再执行 <em>setTimeout</em>，例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const fs = require('fs')\nfs.readFile(__filename, () =&gt; {\n    setTimeout(() =&gt; {\n        console.log('timeout');\n    }, 0)\n    setImmediate(() =&gt; {\n        console.log('immediate')\n    })\n})\n// immediate\n// timeout</code></pre></div><p>在上述代码中，<em>setImmediate</em> 永远先执行。因为两个代码写在 <em>I/O</em> 回调中，<em>I/O</em> 回调是在 <em>poll</em> 阶段执行，当回调执行完毕后队列为空，发现存在 <em>setImmediate</em> 回调，所以就直接跳转到 <em>check</em> 阶段去执行回调了。</p><p><br></p><p><strong><em>process.nextTick</em></strong></p><p><br></p><p>这个函数其实是独立于事件循环之外的，它有一个自己的队列。当每个阶段完成后，如果存在 <em>nextTick</em> 队列，就会清空队列中的所有回调函数，并且优先于其他 <em>microtask</em> 执行。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">setTimeout(() =&gt; {\n console.log('timer1')\n Promise.resolve().then(function() {\n   console.log('promise1')\n })\n}, 0)\nprocess.nextTick(() =&gt; {\n console.log('nextTick')\n process.nextTick(() =&gt; {\n   console.log('nextTick')\n   process.nextTick(() =&gt; {\n     console.log('nextTick')\n     process.nextTick(() =&gt; {\n       console.log('nextTick')\n     })\n   })\n })\n})\n// nextTick =&gt; nextTick =&gt; nextTick =&gt; nextTick =&gt; timer1 =&gt; promise1</code></pre></div><p><strong><em>Promise.then</em></strong></p><p><br></p><p><em>Promise.then</em> 也是独立于事件循环之外的，有一个自己的队列，但是优先级要比 <em>process.nextTick</em> 要低，所以当微任务中同时存在 <em>process.nextTick</em> 和 <em>Promise.then</em> 时，会优先执行前者。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">setTimeout(()=&gt;{\n    console.log('timer1')\n    Promise.resolve().then(function() {\n        console.log('promise1')\n    })\n    process.nextTick(() =&gt; {\n        console.log('nexttick');\n    })\n}, 0)\nsetTimeout(()=&gt;{\n    console.log('timer2')\n    Promise.resolve().then(function() {\n        console.log('promise2')\n    })\n}, 0)\n// timer1、nexttick、promise1、timer2、promise2</code></pre></div><h4><em>Node.js</em> 与浏览器的事件队列的差异</h4><p>浏览器环境下，就两个队列，一个宏任务队列，一个微任务队列。微任务的任务队列是每个宏任务执行完之后执行。（因为在浏览器环境中，script 标签也算是一个宏任务）</p><p><br></p><p>在 <em>Node.js</em> 中，每个任务队列的每个任务执行完毕之后，就会清空这个微任务队列。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-15-060748.png\" alt=\"eventloop\" contenteditable=\"false\"><br></p><h2>真题解答</h2><ul><li><p>请简述一下 <em>Node.js</em> 中的事件循环，和浏览器环境的事件循环有何不同？</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p><em>Node.JS</em> 的事件循环分为 <em>6</em> 个阶段：</p><ul><li><p><em>timers</em> 阶段：这个阶段执行 <em>timer</em>（ <em>setTimeout、setInterval</em> ）的回调</p></li><li><p><em>I/O callbacks</em> 阶段：处理一些上一轮循环中的少数未执行的 <em>I/O</em> 回调</p></li><li><p><em>idle、prepare</em> 阶段：仅 <em>Node.js</em> 内部使用</p></li><li><p><em>poll</em> 阶段：获取新的 <em>I/O</em> 事件, 适当的条件下 <em>Node.js</em> 将阻塞在这里</p></li><li><p><em>check</em> 阶段：执行 <em>setImmediate( )</em> 的回调</p></li><li><p><em>close callbacks</em> 阶段：执行 <em>socket</em> 的 <em>close</em> 事件回调</p></li></ul><p>事件循环的执行顺序为：</p><p><br></p><p>外部输入数据 –-&gt; 轮询阶段（ <em>poll</em> ）-–&gt; 检查阶段（ <em>check</em> ）-–&gt; 关闭事件回调阶段（ <em>close callback</em> ）–-&gt; 定时器检测阶段（ <em>timer</em> ）–-&gt; <em>I/O</em> 事件回调阶段（ <em>I/O callbacks</em> ）-–&gt;闲置阶段（ <em>idle、prepare</em> ）–-&gt;轮询阶段（按照该顺序反复运行）...</p><p><br></p><p>浏览器和 <em>Node.js</em> 环境下，微任务任务队列的执行时机不同</p><ul><li><p>在 <em>Node.js</em> 中，每个任务队列的每个任务执行完毕之后，就会清空这个微任务队列。</p></li><li><p>浏览器环境下，就两个队列，一个宏任务队列，一个微任务队列。微任务的任务队列是每个宏任务执行完之后执行。</p></li></ul></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666078059098",
  "typeId": {
    "$oid": "634d809b7797638ec96fe307"
  }
},
{
  "_id": {
    "$oid": "634e55942fac4881713db3d2"
  },
  "interviewTitle": "JS 中的 eval 方法是什么？",
  "interviewContent": "<h1><em>eval</em></h1><h2>经典真题</h2><ul><li><p><em>JavaScript</em> 中的 <em>eval</em> 方法是啥？一般什么场景下使用？</p></li></ul><h2>关于 <em>eval</em> 你所需要知道的内容</h2><h3><em>eval</em> 的基本用法</h3><p>首先我们来看一下 <em>eval( )</em> 函数的基本用法。</p><p><br></p><p><em>eval( )</em> 函数接收一个字符串作为参数，该字符串一个表示 <em>JavaScript</em> 表达式、语句或一系列语句的字符串。表达式可以包含变量与已存在对象的属性。</p><p><br></p><p>示例如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">eval('console.log(\"Hello!\")'); // Hello!\n\nvar str = `\n    var a = 1;\n    var b = 2;\n    if(a &gt; b) {\n        console.log('a &gt; b');\n    } else {\n        console.log('a&lt;b');\n    }\n`;\neval(str); // a&lt;b\n\nconsole.log(eval('2 + 2')); // 4（ number 类型 ）\n\n\nconsole.log(eval(new String('Hello'))); // [String: 'Hello']\n\n\nconsole.log(eval('2 + 2') === eval('4')); // true\n\n\nconsole.log(eval('2 + 2') === eval(new String('2 + 2'))); // false</code></pre></div><p>通过上面的代码我们可以发现，<em>eval( )</em> 会将传入的字符串作为 <em>JavaScript</em> 来进行执行。</p><p><br></p><p>如果 <em>eval( )</em> 的参数不是字符串， <em>eval( )</em> 会将参数原封不动地返回。例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">console.log(eval(true)); // true\nconsole.log(eval(5)); // 5</code></pre></div><p>如果传入的字符串不是 <em>JavaScript</em> 代码，那么也会将此字符串原封不动的返回。例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var Hello = 5;\nconsole.log(eval('Hello')); // 5</code></pre></div><h3><em>eval</em> 作用域</h3><p><em>eval</em> 里面的代码在当前词法环境中执行，因此它可以看到外部变量：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">let a = 1;\n\nfunction f() {\n  let a = 2;\n\n  eval('console.log(a)'); // 2\n}\n\nf();</code></pre></div><p>它也可以改变外部变量：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">let x = 5;\neval(\"x = 10\");\nconsole.log(x); // 10, value modified</code></pre></div><p>在严格模式下， <em>eval</em> 有自己的词法环境。因此，在 <em>eval</em> 内部声明的函数和变量在外部不可见：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">eval(\"let x = 5; function f() {}\");\n\nconsole.log(typeof x); // undefined (no such variable)</code></pre></div><p>如果没有 <em>use strict</em>，<em>eval</em> 没有自己的词法环境，所以我们会在外面看到 <em>x</em> 和 <em>f</em> :</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">eval(\"var x = 5; function f() {}\");\n\nconsole.log(x); // 5\nconsole.log(typeof x); // number </code></pre></div><h3>永远不要使用 <em>eval</em></h3><p>明白了 <em>eval( )</em> 函数的基本用法后，你心里一定会有这么一个疑问，那就是这玩意儿用来干嘛？</p><p><br></p><p>在现代编程中，<em>eval</em> 的使用非常谨慎。人们常说“ <em>eval is evil（eval 是邪恶的）</em> ”。</p><p><br></p><p>原因很简单：很久很久以前，<em>JavaScript</em> 是一种弱得多的语言，很多事情只能用 <em>eval</em> 来完成。但那段时间已经过去十年了。</p><p><br></p><p>现在，几乎没有理由使用 <em>eval</em>。如果有人使用了它，那么一个更好的选择是用现代语言结构或 <em>JavaScript</em> 模块替换它。</p><p><br></p><p>总结起来，有如下的理由让我们不要使用 <em>eval</em>：</p><ul><li><p><em>eval</em> 是一个危险的函数， 它使用与调用者相同的权限执行代码。如果你用 <em>eval</em> 运行的字符串代码被恶意方（不怀好意的人）修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。（不安全）</p></li><li><p><em>eval</em> 通常比其他替代方法更慢，因为它必须调用 <em>JS</em> 解释器，而许多其他结构则可被现代 <em>JS</em> 引擎进行优化。使用 <em>eval</em> 往往比普通 <em>JavaScript</em> 代码慢几个数量级。（性能不好）</p></li><li><p>产生混乱的代码逻辑</p></li></ul><h2>真题解答</h2><ul><li><p><em>JavaScript</em> 中的 <em>eval</em> 方法是啥？一般什么场景下使用？</p></li></ul><blockquote><p>参考答案：</p><p><br></p><p><em>eval</em> 是 <em>JavaScript</em> 中的一个全局函数，它将指定的字符串计算为 <em>JavaScript</em> 代码并执行它。</p><p><br></p><p>在现代 <em>JavaScript</em> 编程中，我们应该尽量避免使用 <em>eval</em>，之前所有使用 <em>eval</em> 的地方都有更好的方式来进行代替，所以在现代 <em>JavaScript</em> 编程中，<em>eval</em> 没有什么使用场景存在，也就是说，并不存在某些场景必须要使用 <em>eval</em> 才能实现的。</p></blockquote><p>-<em>EOF</em>-</p>",
  "onShelfDate": "1666078100765",
  "typeId": {
    "$oid": "634d7fcc7797638ec96fe2f1"
  }
}]